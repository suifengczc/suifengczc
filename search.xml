<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PS学习笔记</title>
      <link href="/2020/10/05/Skill/PS/start_ps/"/>
      <url>/2020/10/05/Skill/PS/start_ps/</url>
      
        <content type="html"><![CDATA[<h1 id="PS学习笔记"><a href="#PS学习笔记" class="headerlink" title="PS学习笔记"></a>PS学习笔记</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-5-3"><a href="#1-5-3" class="headerlink" title="1.5.3"></a>1.5.3</h3><p>使用抓手工具下的抓手功能时<br>按住<code>CTRL</code>并单击鼠标左键可以放大窗口<br>按住<code>ALT</code>并单击鼠标左键可以缩小窗口<br>当图片放大超过100%时可以拖拽图片</p><p>使用抓手工具下的旋转视图工具可以旋转图片<br><img src="/2020/10/05/Skill/PS/start_ps/zhuashou.png" alt="抓手工具"></p><p>在工具栏可以设置抓手工具旋转的效果<br><img src="/2020/10/05/Skill/PS/start_ps/xuanzhuan.png" alt="抓手工具旋转功能"></p><h3 id="1-5-4"><a href="#1-5-4" class="headerlink" title="1.5.4"></a>1.5.4</h3><p>使用缩放工具可以缩放图片的大小</p><p>按住<code>ALT</code>键可以暂时切换为相反的操作<br><img src="/2020/10/05/Skill/PS/start_ps/fangdajing.png" alt="缩放工具"></p>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Skill </tag>
            
            <tag> PS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Groovy 面向对象</title>
      <link href="/2020/07/14/Language/Groovy/ObjectOrientation/"/>
      <url>/2020/07/14/Language/Groovy/ObjectOrientation/</url>
      
        <content type="html"><![CDATA[<h1 id="Groovy-面向对象"><a href="#Groovy-面向对象" class="headerlink" title="Groovy 面向对象"></a>Groovy 面向对象</h1><p><a href="http://www.groovy-lang.org/objectorientation.html" target="_blank" rel="noopener">面向对象</a>阅读笔记。</p><h2 id="1-类型"><a href="#1-类型" class="headerlink" title="1.类型"></a>1.类型</h2><h3 id="1-1-基础类型"><a href="#1-1-基础类型" class="headerlink" title="1.1.基础类型"></a>1.1.基础类型</h3><ul><li>整型: <code>byte</code>(8bit), <code>short</code>(16bit), <code>int</code>(32bit), <code>long</code>(64bit)</li><li>浮点型: <code>float</code>(32bit), <code>double</code>(64bit)</li><li>boolean</li><li>char(16bit): 可作为数字类型使用，代表UTF-16编码</li></ul><p>Groovy使用和Java相同的装箱和拆箱。对应如下:</p><table><thead><tr><th align="center">基础类型</th><th align="center">包装类型</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">Boolean</td></tr><tr><td align="center">char</td><td align="center">Character</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr></tbody></table><h3 id="1-2类"><a href="#1-2类" class="headerlink" title="1.2类"></a>1.2类</h3><p>Groovy与Java的区别:</p><ul><li><p>没有可见性修饰符的类或方法默认为公共修饰符</p></li><li><p>没有可见性修饰符的字段会转换为属性，属性没有显式的getter和setter方法。</p></li><li><p>类的包名可以和类文件的路径名不相同</p></li><li><p>一个源文件可以包含一个或多个类。但如果一个源文件中出现不在类中的代码时将被是为脚本<br>脚本是具有一些特殊约定的类，它的名称和原文件相同，因此不要在脚本中定义与源文件同名的类</p></li></ul><pre><code class="Groovy">class Person {    String name    Integer age    def increaseAge(Integer years) {        this.age += years    }}</code></pre><h3 id="1-2-1普通类"><a href="#1-2-1普通类" class="headerlink" title="1.2.1普通类"></a>1.2.1普通类</h3><p>普通类是指顶层和具体的类。普通类只能是公开的</p><h3 id="1-2-2内部类"><a href="#1-2-2内部类" class="headerlink" title="1.2.2内部类"></a>1.2.2内部类</h3><p>内部类可以访问外部类的成员，即使是私有的。<br>外部类以外的类不允许访问内部类。</p><pre><code class="Groovy">class Outer {    private String privateStr    def callInnerMethod() {        new Inner().methodA()    }    class Inner {        def methodA() {            println &quot;${privateStr}.&quot;        }    }}</code></pre><p>存疑：<br>原文中说</p><blockquote><p>Inner classes are defined within another classes. The enclosing class can use the inner class as usual. On the other side, a inner class can access members of its enclosing class, even if they are private. Classes other than the enclosing class are not allowed to access inner classes</p></blockquote><p>翻译是：<br><code>内部类在另一个类中定义。封闭类可以照常使用内部类。另一方面，内部类可以访问其封闭类的成员，即使它们是私有的。封闭类以外的类不允许访问内部类。</code></p><p>但在如下代码中却可以访问内部类:</p><pre><code class="Groovy">class Demo {    public static void main(String[] args) {        def demo = new Demo()        demo.run()    }    public void run() {        def list = [new Outer.Inner(), new Outer.Inner(), new Outer.Inner(), new Outer.Inner()]        list.each { it -&gt; println it.a }    }}</code></pre><p>从Groovy3.0开始，支持用于非静态内部类实例语法:</p><pre><code class="Groovy">class Computer {    class Cpu {        int coreNumber        Cpu(int coreNumber) {            this.coreNumber = coreNumber        }    }}assert 4 == new Computer().new Cpu(4).coreNumber</code></pre>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> Groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Groovy 程序结构</title>
      <link href="/2020/07/12/Language/Groovy/Structure/"/>
      <url>/2020/07/12/Language/Groovy/Structure/</url>
      
        <content type="html"><![CDATA[<h1 id="Groovy-程序结构"><a href="#Groovy-程序结构" class="headerlink" title="Groovy 程序结构"></a>Groovy 程序结构</h1><p>本篇是<a href="http://www.groovy-lang.org/structure.html" target="_blank" rel="noopener">程序结构</a>的阅读笔记。</p><h2 id="1-包名"><a href="#1-包名" class="headerlink" title="1.包名"></a>1.包名</h2><p>包名和Java相同</p><h2 id="2-Import"><a href="#2-Import" class="headerlink" title="2.Import"></a>2.Import</h2><h3 id="2-1-默认导入"><a href="#2-1-默认导入" class="headerlink" title="2.1.默认导入"></a>2.1.默认导入</h3><p>Groovy默认导入了</p><pre><code class="Groovy">import java.lang.*import java.util.*import java.io.*import java.net.*import groovy.lang.*import groovy.util.*import java.math.BigIntegerimport java.math.BigDecimal</code></pre><h3 id="2-2-简单导入"><a href="#2-2-简单导入" class="headerlink" title="2.2.简单导入"></a>2.2.简单导入</h3><p>全限定名导入类</p><h3 id="2-3-星号导入"><a href="#2-3-星号导入" class="headerlink" title="2.3.星号导入"></a>2.3.星号导入</h3><pre><code class="Groovy">import groovy.xml.*def markupBuilder = new MarkupBuilder()assert markupBuilder != nullassert new StreamingMarkupBuilder() != null</code></pre><h3 id="2-4-静态导入"><a href="#2-4-静态导入" class="headerlink" title="2.4.静态导入"></a>2.4.静态导入</h3><p>Groovy允许静态导入类并且与导入方法同名的方法，只要类型不同:</p><pre><code class="Groovy">import static java.lang.String.formatclass SomeClass {    String format(Integer i) {        i.toString()    }    static void main(String[] args) {        assert format(&#39;String&#39;) == &#39;String&#39;        assert new SomeClass().format(Integer.valueOf(1)) == &#39;1&#39;    }}</code></pre><p>如果具有相同的类型，以导入的类优先。</p><h3 id="2-5-静态导入别名"><a href="#2-5-静态导入别名" class="headerlink" title="2.5.静态导入别名"></a>2.5.静态导入别名</h3><pre><code class="Groovy">import static Calendar.getInstance as nowassert now().class == Calendar.getInstance().class</code></pre><h3 id="2-6-静态星号导入"><a href="#2-6-静态星号导入" class="headerlink" title="2.6.静态星号导入"></a>2.6.静态星号导入</h3><pre><code class="Groovy">import static java.lang.Math.*assert sin(0) == 0.0assert cos(0) == 1.0</code></pre><h3 id="2-7-导入别名"><a href="#2-7-导入别名" class="headerlink" title="2.7.导入别名"></a>2.7.导入别名</h3><pre><code class="Groovy">import java.util.Dateimport java.sql.Date as SQLDateDate utilDate = new Date(1000L)SQLDate sqlDate = new SQLDate(1000L)assert utilDate instanceof java.util.Dateassert sqlDate instanceof java.sql.Date</code></pre><h2 id="3-脚本与类"><a href="#3-脚本与类" class="headerlink" title="3.脚本与类"></a>3.脚本与类</h2><h3 id="3-1-public-static-void-main-和-脚本"><a href="#3-1-public-static-void-main-和-脚本" class="headerlink" title="3.1. public static void main 和 脚本"></a>3.1. public static void main 和 脚本</h3><p>Groovy的类形式:</p><pre><code class="Groovy">class Main {    static void main(String... args) {        println &#39;Groovy world!&#39;    }}</code></pre><p>Groovy的脚本形式:</p><pre><code class="Groovy">println &#39;Groovy world!&#39;</code></pre><p>脚本无需定义一个类来执行</p><h3 id="3-2-脚本类"><a href="#3-2-脚本类" class="headerlink" title="3.2.脚本类"></a>3.2.脚本类</h3><pre><code class="Groovy">import org.codehaus.groovy.runtime.InvokerHelperclass Main extends Script {    def run() {        println &#39;Groovy world!&#39;    }    static void main(String[] args) {        InvokerHelper.runScript(Main, args)    }}</code></pre><h3 id="3-3-方法"><a href="#3-3-方法" class="headerlink" title="3.3.方法"></a>3.3.方法</h3><p>脚本中可以定义方法。</p><h3 id="3-4-变量"><a href="#3-4-变量" class="headerlink" title="3.4.变量"></a>3.4.变量</h3><p>脚本中得变量不需要定义类型，因此:</p><pre><code class="Groovy">int x = 1int y = 2assert x+y == 3</code></pre><p>和</p><pre><code class="Groovy">x = 1y = 2assert x+y == 3</code></pre><p>是一样的。</p><p>但是两者直接还是存在一定得差异</p><ul><li><p>在第一种写法中，参数将被定义为局部变量，并且在run方法之外不可访问。</p><pre><code class="Groovy">  public Object run() {      CallSite[] var1 = $getCallSiteArray();      int x = 1;      int y = 2;      return BytecodeInterface8.isOrigInt() &amp;&amp; !__$stMC &amp;&amp; !BytecodeInterface8.disabledStandardMetaClass() ? var1[3].callCurrent(this, x + y) : var1[1].callCurrent(this, var1[2].call(Integer.valueOf(x), Integer.valueOf(y)));  }</code></pre><p>以上是第一种写法的脚本中的<code>run</code>方法，可以看到<code>x</code>和<code>y</code>被定义成了方法中的变量。</p></li><li><p>在第二种写法中，参数被定义成脚本的属性，在脚本类中都可以访问到。</p><pre><code class="Groovy">      public Object run() {      CallSite[] var1 = $getCallSiteArray();      byte var2 = 1;      ScriptBytecodeAdapter.setGroovyObjectProperty(Integer.valueOf(var2), Five.class, this, (String)&quot;x&quot;);      byte var3 = 2;      ScriptBytecodeAdapter.setGroovyObjectProperty(Integer.valueOf(var3), Five.class, this, (String)&quot;y&quot;);      return var1[1].callCurrent(this, var1[2].call(var1[3].callGroovyObjectGetProperty(this), var1[4].callGroovyObjectGetProperty(this)));  }</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> Groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Groovy运算符</title>
      <link href="/2020/07/05/Language/Groovy/Operators/"/>
      <url>/2020/07/05/Language/Groovy/Operators/</url>
      
        <content type="html"><![CDATA[<h1 id="Groovy运算符"><a href="#Groovy运算符" class="headerlink" title="Groovy运算符"></a>Groovy运算符</h1><p><a href="http://www.groovy-lang.org/operators.html" target="_blank" rel="noopener">Groovy运算符</a>阅读笔记，非全文翻译。</p><h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1.算术运算符"></a>1.算术运算符</h2><p>Groovy支持常见的算术运算符，和所有Java支持的运算符。</p><h3 id="1-1-普通算术运算符"><a href="#1-1-普通算术运算符" class="headerlink" title="1.1.普通算术运算符"></a>1.1.普通算术运算符</h3><p>Groovy支持的二元运算符:</p><table><thead><tr><th align="center">运算符</th><th align="center">用途</th><th align="left">备注</th></tr></thead><tbody><tr><td align="center"><code>+</code></td><td align="center">加</td><td align="left"></td></tr><tr><td align="center"><code>-</code></td><td align="center"></td><td align="left"></td></tr><tr><td align="center"><code>*</code></td><td align="center">乘</td><td align="left"></td></tr><tr><td align="center"><code>/</code></td><td align="center">除</td><td align="left">整数除法用的是<code>intdiv()</code>,更多的除法返回值类型参看<a href="https://docs.groovy-lang.org/latest/html/documentation/core-syntax.html#integer_division" target="_blank" rel="noopener">integer division</a></td></tr><tr><td align="center"><code>%</code></td><td align="center">取余</td><td align="left"></td></tr><tr><td align="center"><code>**</code></td><td align="center">乘方</td><td align="left">参看<a href="https://docs.groovy-lang.org/latest/html/documentation/core-syntax.html#power_operator" target="_blank" rel="noopener">the power operation</a>了解更多关于乘方返回值类型</td></tr></tbody></table><h3 id="1-2-一元运算符"><a href="#1-2-一元运算符" class="headerlink" title="1.2.一元运算符"></a>1.2.一元运算符</h3><p><code>+</code>和<code>-</code>都可以作为一元运算符。并支持<code>++</code>和<code>--</code>方式的前缀和后缀</p><h3 id="1-3-赋值运算符"><a href="#1-3-赋值运算符" class="headerlink" title="1.3.赋值运算符"></a>1.3.赋值运算符</h3><p>上面的二元运算符也可以作为赋值运算符使用:</p><ul><li><p><code>+=</code></p></li><li><p><code>-=</code></p></li><li><p><code>*=</code></p></li><li><p><code>/=</code></p></li><li><p><code>%=</code></p></li><li><p><code>**=</code></p></li></ul><h2 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2.关系运算符"></a>2.关系运算符</h2><table><thead><tr><th align="center">操作符</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center"><code>==</code></td><td align="center">相等</td></tr><tr><td align="center"><code>!=</code></td><td align="center">不相等</td></tr><tr><td align="center"><code>&lt;</code></td><td align="center">小于</td></tr><tr><td align="center"><code>&lt;=</code></td><td align="center">小于等于</td></tr><tr><td align="center"><code>&gt;</code></td><td align="center">大于</td></tr><tr><td align="center"><code>&gt;=</code></td><td align="center">大于等于</td></tr><tr><td align="center"><code>===</code></td><td align="center">完全相同</td></tr><tr><td align="center"><code>!==</code></td><td align="center">不完全相同</td></tr></tbody></table><p><code>===</code>和<code>!==</code>的效果等同于调用<code>is()</code>方法。</p><p>在Groovy中 <code>==</code> 操作符是调用了对象的<code>equals()</code>方法做比较，<code>===</code>操作符是比较对象的内存地址是否相同</p><p>而在Java中，<code>==</code>是比较对象的地址，如果需要比较对象的值是否相同则是调用对象的<code>equals()</code>方法做比较。并且该对象需要重写<code>equals()</code>和<code>hashCode()</code>方法。</p><h2 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3.逻辑运算符"></a>3.逻辑运算符</h2><p>逻辑运算符有<code>&amp;&amp;</code>,<code>||</code>,<code>!</code></p><h3 id="3-1-优先级"><a href="#3-1-优先级" class="headerlink" title="3.1.优先级"></a>3.1.优先级</h3><p><code>!</code> &gt; <code>&amp;&amp;</code> &gt; <code>||</code></p><pre><code class="Groovy">assert (!false &amp;&amp; false) == false // ! &gt; &amp;&amp;, 结果为falseassert true || true &amp;&amp; false // &amp;&amp; &gt; ||, 结果为true</code></pre><h3 id="3-2-短路"><a href="#3-2-短路" class="headerlink" title="3.2.短路"></a>3.2.短路</h3><p>对于<code>||</code>, 当运算符左边的值为true时，不会计算右边的值。只有左边的值为false时才会计算有百年的值。<br>对于<code>&amp;&amp;</code>, 只有当左边的值为ture时才会计算右边的值。</p><h2 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4.位运算符"></a>4.位运算符</h2><p>Groovy提供了四种位运算符</p><ul><li><p><code>&amp;</code> : 按位和</p></li><li><p><code>|</code> : 按位或</p></li><li><p><code>^</code> : 按位异或</p></li><li><p><code>~</code> : 按位取反</p></li></ul><p>Groovy的基础类型遵循Java的规范，基础类型都是有符号数，所以在使用按位取反的时候，使用mask来对指定的位置取反。</p><h2 id="5-条件运算符"><a href="#5-条件运算符" class="headerlink" title="5.条件运算符"></a>5.条件运算符</h2><h3 id="5-1-否操作符"><a href="#5-1-否操作符" class="headerlink" title="5.1.否操作符"></a>5.1.否操作符</h3><p>使用<code>!</code>反转结果</p><h3 id="5-2-三元运算符"><a href="#5-2-三元运算符" class="headerlink" title="5.2.三元运算符"></a>5.2.三元运算符</h3><p><code>result = string ? &#39;Found&#39; : &#39;Not found&#39;</code></p><p><code>string?</code>判断字符串是否为空</p><h3 id="5-3-Elvis操作符"><a href="#5-3-Elvis操作符" class="headerlink" title="5.3.Elvis操作符"></a>5.3.Elvis操作符</h3><p>Groovy 3.0.0引入了Elvis操作符，这是对三元表达式的进一步简化:</p><pre><code class="Groovy">import groovy.transform.ToString@ToStringclass Element {    String name    int atomicNumber}def he = new Element(name: &#39;Helium&#39;)he.with {    name = name ?: &#39;Hydrogen&#39;   // existing Elvis operator    atomicNumber ?= 2           // new Elvis assignment shorthand}assert he.toString() == &#39;Element(Helium, 2)&#39;</code></pre><h2 id="6-对象操作符"><a href="#6-对象操作符" class="headerlink" title="6.对象操作符"></a>6.对象操作符</h2><h3 id="6-1-空安全操作符"><a href="#6-1-空安全操作符" class="headerlink" title="6.1.空安全操作符"></a>6.1.空安全操作符</h3><p>空安全操作符可以规避<code>NullPointerException</code>.</p><pre><code class="Groovy">def person = Person.find { it.id == 123 }def name = person?.nameassert name == null</code></pre><h3 id="6-2-直接访问操作符"><a href="#6-2-直接访问操作符" class="headerlink" title="6.2.直接访问操作符"></a>6.2.直接访问操作符</h3><pre><code class="Groovy">class User {    public final String name    User(String name) { this.name = name}    String getName() { &quot;Name: $name&quot; }}def user = new User(&#39;Bob&#39;)assert user.name == &#39;Name: Bob&#39;</code></pre><p>对于上面的例子，在访问<code>name</code>属性时实际是调用了对应的get方法。如果想要直接获取字段而不是调用方法，可以使用<code>.@</code>操作符。<br>通过<code>.@</code>可以直接访问字段而不是通过get方法</p><h3 id="6-3-方法指针操作符"><a href="#6-3-方法指针操作符" class="headerlink" title="6.3.方法指针操作符"></a>6.3.方法指针操作符</h3><pre><code class="Groovy">def str = &#39;example of method reference&#39;def fun = str.&amp;toUpperCase // 将str的toUpperCase方法整体作为一个变量保存在fun中def upper = fun() // 像调用常规方法一样调用fun方法assert upper == str.toUpperCase() // fun方法的结果和str.toUpperCase()结果相同</code></pre><p>方法指针是<code>groovy.lang.Closure</code>类型的，因此可以在任何使用闭包的位置使用。</p><pre><code class="Groovy">def transform(List elements, Closure action) {    def result = []    elements.each {        result &lt;&lt; action(it)    }    result}//定义describe方法，作用是输出Person的信息String describe(Person p) {    &quot;$p.name is $p.age&quot;}//方法指针保存在action中def action = this.&amp;describedef list = [    new Person(name: &#39;Bob&#39;,   age: 42),    new Person(name: &#39;Julia&#39;, age: 35)]//把方法指针作为闭包传入方法assert transform(list, action) == [&#39;Bob is 42&#39;, &#39;Julia is 35&#39;]</code></pre><p>方法指针与接收者和方法名绑定。对于重载方法，在运行时Groovy会根据传参选择正确的方法。</p><pre><code class="Groovy">def doSomething(String str) { str.toUpperCase() }def doSomething(Integer x) { 2*x }def reference = this.&amp;doSomethingassert reference(&#39;foo&#39;) == &#39;FOO&#39;assert reference(123)   == 246</code></pre><p>在Groovy3.0及以上，可以使用<code>new</code>作为一个方法名来指向一个构造函数。<br>例如:</p><pre><code class="Groovy">def foo  = BigInteger.&amp;newdef fortyTwo = foo(&#39;42&#39;)assert fortyTwo == 42G</code></pre><p>在Groovy3.0及以上，可以使用方法指针指向一个类的实例方法，这个方法指针接收一个接收者类型的实例作为参数。例如:</p><pre><code class="Groovy">def instanceMethod = String.&amp;toUpperCase // 指向实例方法的方法指针assert instanceMethod(&#39;foo&#39;) == &#39;FOO&#39; // 方法指针接收一个实例</code></pre><p>总结一下:</p><ul><li><p>方法指针可以指向一个具体实例的方法，例如</p><pre><code class="Groovy">  def str = &#39;example of method reference&#39;  def fun = str.&amp;toUpperCase</code></pre></li><li><p>方法指针可以指向当前脚本的方法，例如:</p><pre><code class="Groovy">  String describe(Person p) {  &quot;$p.name is $p.age&quot;  }  def action = this.&amp;describe</code></pre></li><li><p>方法指针可以指向多个重载方法，在运行时根据传参选择正确的方法执行</p></li><li><p>方法指针可以使用<code>new</code>来指向一个构造方法</p></li><li><p>方法指针可以指向一个实例方法。</p></li></ul><h3 id="6-4-方法引用运算符"><a href="#6-4-方法引用运算符" class="headerlink" title="6.4.方法引用运算符"></a>6.4.方法引用运算符</h3><p>在Groovy 3.0及以上支持Java8以上的<code>::</code>运算符。</p><pre><code class="vGroovy">import groovy.transform.CompileStaticimport static java.util.stream.Collectors.toList@CompileStaticvoid methodRefs() {    assert 6G == [1G, 2G, 3G].stream().reduce(0G, BigInteger::add)    assert [4G, 5G, 6G] == [1G, 2G, 3G].stream().map(3G::add).collect(toList())    assert [1G, 2G, 3G] == [1L, 2L, 3L].stream().map(BigInteger::valueOf).collect(toList())      assert [1G, 2G, 3G] == [1L, 2L, 3L].stream().map(3G::valueOf).collect(toList())}methodRefs()</code></pre><pre><code class="Groovy">@CompileStaticvoid constructorRefs() {    assert [1, 2, 3] == [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].stream().map(Integer::new).collect(toList())   // 使用类构造函数    def result = [1, 2, 3].stream().toArray(Integer[]::new) // 使用数组构造函数    assert result instanceof Integer[]    assert result.toString() == &#39;[1, 2, 3]&#39;}constructorRefs()</code></pre><h2 id="7-正则表达式运算符"><a href="#7-正则表达式运算符" class="headerlink" title="7.正则表达式运算符"></a>7.正则表达式运算符</h2><h3 id="7-1-Pattern运算符"><a href="#7-1-Pattern运算符" class="headerlink" title="7.1.Pattern运算符"></a>7.1.Pattern运算符</h3><p>Groovy中使用<code>~</code>简化了创建<code>java.util.regex.Pattern</code>实例。</p><pre><code class="Groovy">def p = ~/foo/assert p instanceof Pattern</code></pre><p><code>~</code>支持Groovy中的任意String类型:</p><pre><code class="Groovy">    p = ~&#39;foo&#39;    p = ~&quot;foo&quot;    p = ~$/dollar/slashy $ string/$    p = ~&quot;${pattern}&quot;</code></pre><h3 id="7-2-查找运算符"><a href="#7-2-查找运算符" class="headerlink" title="7.2.查找运算符"></a>7.2.查找运算符</h3><p>除了<code>~</code>方式，还可以使用<code>=~</code>运算符直接创建一个<code>java.util.regex.Matcher</code>实例。</p><pre><code class="Groovy">def text = &quot;some text to match&quot;def m = text =~ /match/ // 使用=~右侧的正则表达式创建匹配assert m instanceof Matcher // 返回的类型是Matcherif (!m) { // 等效于if (!m.find(0))    throw new RuntimeException(&quot;Oops, text not found!&quot;)}</code></pre><h3 id="7-3-匹配运算符"><a href="#7-3-匹配运算符" class="headerlink" title="7.3.匹配运算符"></a>7.3.匹配运算符</h3><p><code>==~</code>是Match.find的简单实用方式，它只返回布尔值。<code>==~</code>是严格匹配的。</p><pre><code class="Groovy">m = text ==~ /match/assert m instanceof Booleanif (m) {    throw new RuntimeException(&quot;Should not reach that point!&quot;)}</code></pre><h2 id="8-其他运算符"><a href="#8-其他运算符" class="headerlink" title="8.其他运算符"></a>8.其他运算符</h2><h3 id="8-1-扩展运算符"><a href="#8-1-扩展运算符" class="headerlink" title="8.1.扩展运算符"></a>8.1.扩展运算符</h3><p>扩展点运算符<code>*.</code>通常作用于集合对象。它会对集合的每一项都做同一运算并将结果保存在一个集合中。</p><pre><code class="Groovy">class Car {    String make    String model}def cars = [       new Car(make: &#39;Peugeot&#39;, model: &#39;508&#39;),       new Car(make: &#39;Renault&#39;, model: &#39;Clio&#39;)]def makes = cars*.make //访问cars中的每一个元素的makeassert makes == [&#39;Peugeot&#39;, &#39;Renault&#39;] //将cars中的每个元素的make字段值添加到列表中。</code></pre><p>这里的<code>cars*.make</code>等同于<code>cars.collect{ it.make }</code>。当要访问聊表中元素的属性时，Groovy的GPath表示法允许使用这样的快捷方式来访问，它会自动扩展到每一个元素。<br>在上面的例子中使用<code>cars.make</code>也可以使用，但是更推荐显式地保留<code>*.</code>运算符。</p><p><code>*.</code>运算符是空安全的，对于空元素会返回<code>null</code>而不是空异常。</p><p><code>*.</code>可以用于所有实现了<code>Iterable</code>的类。</p><pre><code class="Groovy">class Component {    Long id    String name}class CompositeObject implements Iterable&lt;Component&gt; {    def components = [        new Component(id: 1, name: &#39;Foo&#39;),        new Component(id: 2, name: &#39;Bar&#39;)]    @Override    Iterator&lt;Component&gt; iterator() {        components.iterator()    }}def composite = new CompositeObject()assert composite*.id == [1,2]assert composite*.name == [&#39;Foo&#39;,&#39;Bar&#39;]</code></pre><p>当数据包含了多层结构时，使用多次<code>*.</code>调用来访问数据。</p><pre><code class="Groovy">class Make {    String name    List&lt;Model&gt; models}@Canonicalclass Model {    String name}def cars = [    new Make(name: &#39;Peugeot&#39;,             models: [new Model(&#39;408&#39;), new Model(&#39;508&#39;)]),    new Make(name: &#39;Renault&#39;,             models: [new Model(&#39;Clio&#39;), new Model(&#39;Captur&#39;)])]def makes = cars*.nameassert makes == [&#39;Peugeot&#39;, &#39;Renault&#39;]def models = cars*.models*.nameassert models == [[&#39;408&#39;, &#39;508&#39;], [&#39;Clio&#39;, &#39;Captur&#39;]]assert models.sum() == [&#39;408&#39;, &#39;508&#39;, &#39;Clio&#39;, &#39;Captur&#39;] // flatten one levelassert models.flatten() == [&#39;408&#39;, &#39;508&#39;, &#39;Clio&#39;, &#39;Captur&#39;] // flatten all levels (one in this case)</code></pre><p>也可以使用<code>collectNested</code>方法来获取所有元素的属性。</p><pre><code class="Groovy">class Car {    String make    String model}def cars = [   [       new Car(make: &#39;Peugeot&#39;, model: &#39;408&#39;),       new Car(make: &#39;Peugeot&#39;, model: &#39;508&#39;)   ], [       new Car(make: &#39;Renault&#39;, model: &#39;Clio&#39;),       new Car(make: &#39;Renault&#39;, model: &#39;Captur&#39;)   ]]def models = cars.collectNested{ it.model }assert models == [[&#39;408&#39;, &#39;508&#39;], [&#39;Clio&#39;, &#39;Captur&#39;]]</code></pre><h4 id="8-1-1-扩展方法参数"><a href="#8-1-1-扩展方法参数" class="headerlink" title="8.1.1.扩展方法参数"></a>8.1.1.扩展方法参数</h4><p>当方法传参于列表的各项一一对应时，可以使用扩展方法参数的方式调用方法，而不需要从列表中逐个取出参数传入方法。</p><pre><code class="Groovy">int function(int x, int y, int z){    x * y + z}def args = [4, 5, 6]assert function(*args) == 26</code></pre><p>另外可以将正常参数和扩展参数混合使用:</p><pre><code class="Groovy">args = [4]assert function(*args, 5, 6) == 26</code></pre><h4 id="8-1-2-扩展列表"><a href="#8-1-2-扩展列表" class="headerlink" title="8.1.2.扩展列表"></a>8.1.2.扩展列表</h4><pre><code class="Groovy">def items = [4, 5]def list = [1, 2, 3, *items, 6]assert list == [1, 2, 3, 4, 5, 6]</code></pre><h4 id="8-1-3-扩展map"><a href="#8-1-3-扩展map" class="headerlink" title="8.1.3.扩展map"></a>8.1.3.扩展map</h4><p>使用<code>*:</code>的方式将一个map内联到另一个map内。</p><pre><code class="Groovy">def m1 = [c:3, d:4]def map = [a:1, b:2, *:m1]assert map == [a:1, b:2, c:3, d:4]</code></pre><pre><code class="Groovy">def m1 = [c:3, d:4]def map = [a:1, b:2, *:m1, d: 8]assert map == [a:1, b:2, c:3, d:8]</code></pre><p>由<code>*:</code>方式内联进来的元素支持被覆盖。</p><h3 id="8-2-范围运算符"><a href="#8-2-范围运算符" class="headerlink" title="8.2.范围运算符"></a>8.2.范围运算符</h3><p>Groovy支持使用<code>..</code>来创建一个Range</p><pre><code class="Groovy">def range = 0..5 // 从0到5的列表assert (0..5).collect() == [0, 1, 2, 3, 4, 5]assert (0..&lt;5).collect() == [0, 1, 2, 3, 4] // 从0到4的列表assert (0..5) instanceof Listassert (0..5).size() == 6</code></pre><p>任何可比较对象都可以使用<code>..</code></p><h3 id="8-3-Spaceship运算符"><a href="#8-3-Spaceship运算符" class="headerlink" title="8.3.Spaceship运算符"></a>8.3.Spaceship运算符</h3><p><code>&lt;=&gt;</code>是对<code>compareTo</code>方法的代理</p><pre><code class="Groovy">assert (1 &lt;=&gt; 1) == 0assert (1 &lt;=&gt; 2) == -1assert (2 &lt;=&gt; 1) == 1assert (&#39;a&#39; &lt;=&gt; &#39;z&#39;) == -1</code></pre><h3 id="8-4-下标运算符"><a href="#8-4-下标运算符" class="headerlink" title="8.4.下标运算符"></a>8.4.下标运算符</h3><p><code>[]</code>是<code>getAt</code>和<code>putAt</code>的简写，取决于在赋值符号的左边还是右边调用。</p><pre><code class="Groovy">def list = [0,1,2,3,4]assert list[2] == 2list[2] = 4assert list[0..2] == [0,1,4]list[0..2] = [6,6,6]assert list == [6,6,6,3,4]</code></pre><p>重写类的<code>getAt</code>和<code>putAt</code>方法，可以使用下标来访问属性。</p><pre><code class="Groovy">class User {    Long id    String name    def getAt(int i) {        switch (i) {            case 0: return id            case 1: return name        }        throw new IllegalArgumentException(&quot;No such element $i&quot;)    }    void putAt(int i, def value) {        switch (i) {            case 0: id = value; return            case 1: name = value; return        }        throw new IllegalArgumentException(&quot;No such element $i&quot;)    }}def user = new User(id: 1, name: &#39;Alex&#39;)assert user[0] == 1assert user[1] == &#39;Alex&#39;user[1] = &#39;Bob&#39;assert user.name == &#39;Bob&#39;</code></pre><h3 id="8-5-安全索引运算符"><a href="#8-5-安全索引运算符" class="headerlink" title="8.5.安全索引运算符"></a>8.5.安全索引运算符</h3><p>Groovy3.0引入了安全索引运算符:<code>?[]</code>, 和<code>?.</code>相似。</p><pre><code class="Groovy">String[] array = [&#39;a&#39;, &#39;b&#39;]assert &#39;b&#39; == array?[1]      // get using normal array indexarray?[1] = &#39;c&#39;              // set using normal array indexassert &#39;c&#39; == array?[1]array = nullassert null == array?[1]     // return null for all index valuesarray?[1] = &#39;c&#39;              // quietly ignore attempt to set valueassert null == array?[1]def personInfo = [name: &#39;Daniel.Sun&#39;, location: &#39;Shanghai&#39;]assert &#39;Daniel.Sun&#39; == personInfo?[&#39;name&#39;]      // get using normal map indexpersonInfo?[&#39;name&#39;] = &#39;sunlan&#39;                  // set using normal map indexassert &#39;sunlan&#39; == personInfo?[&#39;name&#39;]personInfo = nullassert null == personInfo?[&#39;name&#39;]              // return null for all map valuespersonInfo?[&#39;name&#39;] = &#39;sunlan&#39;                  // quietly ignore attempt to set valueassert null == personInfo?[&#39;name&#39;]</code></pre><h3 id="8-6-成员运算符"><a href="#8-6-成员运算符" class="headerlink" title="8.6.成员运算符"></a>8.6.成员运算符</h3><p>成员运算符<code>in</code>可以判断该列表中是否包含该值。等同于<code>isCase</code>和列表的<code>contais</code>方法。</p><pre><code class="Groovy">def list = [&#39;Grace&#39;,&#39;Rob&#39;,&#39;Emmy&#39;]assert (&#39;Emmy&#39; in list)assert list.isCase(&#39;Emmy&#39;)assert list.contains(&#39;Emmy&#39;)</code></pre><h3 id="8-7-相等运算符"><a href="#8-7-相等运算符" class="headerlink" title="8.7.相等运算符"></a>8.7.相等运算符</h3><p>在Groovy使用<code>==</code>判断是否相等和Java中不同，使用<code>==</code>实际是调用了实例的<code>equals</code>方法。<br>如果需要判断是否为相同引用，应该使用<code>is</code>。</p><pre><code class="Groovy">def list1 = [&#39;Groovy 1.8&#39;,&#39;Groovy 2.0&#39;,&#39;Groovy 2.3&#39;]def list2 = [&#39;Groovy 1.8&#39;,&#39;Groovy 2.0&#39;,&#39;Groovy 2.3&#39;]assert list1 == list2assert !list1.is(list2)</code></pre><h3 id="8-8-强转运算符"><a href="#8-8-强转运算符" class="headerlink" title="8.8.强转运算符"></a>8.8.强转运算符</h3><p>强转运算符<code>as</code>是类型强转的变体，但不同于类型强转。</p><pre><code class="Groovy">Integer x = 123String s = (String) x // Integer不能强转成String，会抛出ClassCastException</code></pre><pre><code class="Groovy">Integer x = 123String s = x as Stringprintln sassert &quot;123&quot; == s // 使用as成功把Integer转换成了String</code></pre><p>当对象被强制转换为另一个对象时，除非目标类型与源类型相同，否则强制将返回一个新对象。强制规则因源类型和目标类型而异，如果未找到转换规则，则强制可能会失败。自定义转换规则可以由asType方法实现:</p><pre><code class="Groovy">class Identifiable {    String name}class User {    Long id    String name    def asType(Class target) {        if (target == Identifiable) {            return new Identifiable(name: name)        }        throw new ClassCastException(&quot;User cannot be coerced into $target&quot;)    }}def u = new User(name: &#39;Xavier&#39;)def p = u as Identifiableassert p instanceof Identifiableassert !(p instanceof User)</code></pre><h3 id="8-9-尖括号运算符"><a href="#8-9-尖括号运算符" class="headerlink" title="8.9.尖括号运算符"></a>8.9.尖括号运算符</h3><p>尖括号运算符<code>&lt;&gt;</code>是仅添加语法的糖运算符，以支持与Java 7中同名运算符的兼容性。它用于指示应从声明中推断出泛型类型：</p><pre><code class="Groovy">List&lt;String&gt; strings = new LinkedList&lt;&gt;()</code></pre><p>在动态Groovy中，这是完全未使用的。 在静态类型检查的Groovy中，它也是可选的，因为Groovy类型检查器会执行类型推断，无论是否存在此运算符。</p><h3 id="8-10-Call运算符"><a href="#8-10-Call运算符" class="headerlink" title="8.10.Call运算符"></a>8.10.Call运算符</h3><p><code>()</code>运算符是隐式地调用<code>call</code>方法。对于任意定义了<code>call</code>方法的对象，可以省略<code>.call</code>的部分，而直接使用Call运算符。</p><pre><code class="Groovy">class MyCallable {    int call(int x) { // 在MyCallable中定义了call方法        2*x    }}def mc = new MyCallable()assert mc.call(2) == 4 // 使用传统的调用方式调用call方法assert mc(2) == 4 // 省略.call直接使用()运算符</code></pre><h2 id="9-运算符优先级"><a href="#9-运算符优先级" class="headerlink" title="9.运算符优先级"></a>9.运算符优先级</h2><p>下面列出了Groovy 操作符的优先级</p><table><thead><tr><th align="left">Level</th><th align="left">Operator(s)</th><th align="left">Name(s)</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><code>new</code>  <code>()</code></td><td align="left">object creation, explicit parentheses</td></tr><tr><td align="left"></td><td align="left"><code>()</code>  <code>{}</code>  <code>[]</code></td><td align="left">method call, closure, literal list/map</td></tr><tr><td align="left"></td><td align="left"><code>.</code>  <code>.&amp;</code>  <code>.@</code></td><td align="left">member access, method closure, field/attribute access</td></tr><tr><td align="left"></td><td align="left"><code>?.</code>  <code>*</code>  <code>*.</code>  <code>*:</code></td><td align="left">safe dereferencing, spread, spread-dot, spread-map</td></tr><tr><td align="left"></td><td align="left"><code>~</code>  <code>!</code>  <code>(type)</code></td><td align="left">bitwise negate/pattern, not, typecast</td></tr><tr><td align="left"></td><td align="left"><code>[]</code>  <code>?[]</code>  <code>++</code>  <code>--</code></td><td align="left">list/map/array (safe) index, post inc/decrement</td></tr><tr><td align="left">2</td><td align="left"><code>**</code></td><td align="left">power</td></tr><tr><td align="left">3</td><td align="left"><code>++</code>  <code>--</code>  <code>+</code>  <code>-</code></td><td align="left">pre inc/decrement, unary plus, unary minus</td></tr><tr><td align="left">4</td><td align="left"><code>*</code>  <code>/</code>  <code>%</code></td><td align="left">multiply, div, remainder</td></tr><tr><td align="left">5</td><td align="left"><code>+</code>  <code>-</code></td><td align="left">addition, subtraction</td></tr><tr><td align="left">6</td><td align="left"><code>&lt;&lt;</code>  <code>&gt;&gt;</code>  <code>&gt;&gt;&gt;</code>  <code>..</code>  <code>..&lt;</code></td><td align="left">left/right (unsigned) shift, inclusive/exclusive range</td></tr><tr><td align="left">7</td><td align="left"><code>&lt;</code>  <code>&lt;=</code>  <code>&gt;</code>  <code>&gt;=</code>  <code>in</code>  <code>!in</code>  <code>instanceof</code>  <code>!instanceof</code>  <code>as</code></td><td align="left">less/greater than/or equal, in, not in, instanceof, not instanceof, type coercion</td></tr><tr><td align="left">8</td><td align="left"><code>==</code>  <code>!=</code>  <code>&lt;=&gt;</code>  <code>===</code>  <code>!==</code></td><td align="left">equals, not equals, compare to, identical to, not identical to</td></tr><tr><td align="left"></td><td align="left"><code>=~</code>  <code>==~</code></td><td align="left">regex find, regex match</td></tr><tr><td align="left">9</td><td align="left"><code>&amp;</code></td><td align="left">binary/bitwise and</td></tr><tr><td align="left">10</td><td align="left"><code>^</code></td><td align="left">binary/bitwise xor</td></tr><tr><td align="left">11</td><td align="left">`</td><td align="left">`</td></tr><tr><td align="left">12</td><td align="left"><code>&amp;&amp;</code></td><td align="left">logical and</td></tr><tr><td align="left">13</td><td align="left">`</td><td align="left"></td></tr><tr><td align="left">14</td><td align="left"><code>? :</code></td><td align="left">ternary conditional</td></tr><tr><td align="left"></td><td align="left"><code>?:</code></td><td align="left">elvis operator</td></tr><tr><td align="left">15</td><td align="left"><code>=</code>  <code>**=</code>  <code>*=</code>  <code>/=</code>  <code>%=</code>  <code>+=</code>  <code>-=</code>  <code>&lt;&lt;=</code>  <code>&gt;&gt;=</code>  <code>&gt;&gt;&gt;=</code>  <code>&amp;=</code>  <code>^=</code>  `</td><td align="left">=<code>   </code>?=`</td></tr></tbody></table><h2 id="10-运算符重载"><a href="#10-运算符重载" class="headerlink" title="10.运算符重载"></a>10.运算符重载</h2><p>Groovy允许多种运算符的重载。</p><pre><code class="Groovy">class Bucket {    int size    Bucket(int size) { this.size = size }    Bucket plus(Bucket other) { // Bucket实现了一个plus方法        return new Bucket(this.size + other.size)    }}def b1 = new Bucket(4)def b2 = new Bucket(11)assert (b1 + b2).size == 15 // 因为实现了plus方法，所以可以使用+运算符</code></pre><p>下面是运算符及其对应方法的完整列表:</p><table><thead><tr><th align="left">Operator</th><th align="left">Method</th><th align="left">Operator</th><th align="left">Method</th></tr></thead><tbody><tr><td align="left"><code>+</code></td><td align="left">a.plus(b)</td><td align="left"><code>a[b]</code></td><td align="left">a.getAt(b)</td></tr><tr><td align="left"><code>-</code></td><td align="left">a.minus(b)</td><td align="left"><code>a[b] = c</code></td><td align="left">a.putAt(b, c)</td></tr><tr><td align="left"><code>*</code></td><td align="left">a.multiply(b)</td><td align="left"><code>a in b</code></td><td align="left">b.isCase(a)</td></tr><tr><td align="left"><code>/</code></td><td align="left">a.div(b)</td><td align="left"><code>&lt;&lt;</code></td><td align="left">a.leftShift(b)</td></tr><tr><td align="left"><code>%</code></td><td align="left">a.mod(b)</td><td align="left"><code>&gt;&gt;</code></td><td align="left">a.rightShift(b)</td></tr><tr><td align="left"><code>**</code></td><td align="left">a.power(b)</td><td align="left"><code>&gt;&gt;&gt;</code></td><td align="left">a.rightShiftUnsigned(b)</td></tr><tr><td align="left">`</td><td align="left">`</td><td align="left">a.or(b)</td><td align="left"><code>++</code></td></tr><tr><td align="left"><code>&amp;</code></td><td align="left">a.and(b)</td><td align="left"><code>--</code></td><td align="left">a.previous()</td></tr><tr><td align="left"><code>^</code></td><td align="left">a.xor(b)</td><td align="left"><code>+a</code></td><td align="left">a.positive()</td></tr><tr><td align="left"><code>as</code></td><td align="left">a.asType(b)</td><td align="left"><code>-a</code></td><td align="left">a.negative()</td></tr><tr><td align="left"><code>a()</code></td><td align="left">a.call()</td><td align="left"><code>~a</code></td><td align="left">a.bitwiseNegate()</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> Groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/05/hello-world/"/>
      <url>/2020/07/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown中指定文字特性</title>
      <link href="/2020/06/29/Tools/markdown/FontProperties/"/>
      <url>/2020/06/29/Tools/markdown/FontProperties/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown指定文字颜色"><a href="#markdown指定文字颜色" class="headerlink" title="markdown指定文字颜色"></a>markdown指定文字颜色</h1><p>注: 因为Hexo不支持Latex，所以在Hexo网页上得效果不行</p><p>如果只是想修改文字颜色可以使用<br><code>$\color{颜色名称或者RGB值}{文字内容}}$</code><br>方式来修改。<br>例如:<br>这是一个$\color{red}{红色}$的字<br>这是一个$\color{#0066AA}{蓝色}$的字</p><p>当文字中存在<code>#</code>时需要用<code>\</code>转义</p><table><thead><tr><th align="center">颜色名</th><th align="center">十六进制颜色值</th><th align="center">RGB值</th><th align="center">颜色</th></tr></thead><tbody><tr><td align="center">$\color{#020202}{AliceBlue}$</td><td align="center">$\color{AliceBlue}\text{#F0F8FF}$</td><td align="center">$\color{AliceBlue}\text{rgb(240, 248, 255)}$</td><td align="center">$\colorbox{AliceBlue}{\color{AliceBlue}\texttt{#F0F8FF}}$</td></tr><tr><td align="center">$\color{#020202}{AntiqueWhite}$</td><td align="center">$\color{AntiqueWhite}\text{#FAEBD7}$</td><td align="center">$\color{AntiqueWhite}\text{rgb(250, 235, 215)}$</td><td align="center">$\colorbox{AntiqueWhite}{\color{AntiqueWhite}\texttt{#FAEBD7}}$</td></tr><tr><td align="center">$\color{#020202}{Aqua}$</td><td align="center">$\color{Aqua}\text{#00FFFF}$</td><td align="center">$\color{Aqua}\text{rgb(0, 255, 255)}$</td><td align="center">$\colorbox{Aqua}{\color{Aqua}\texttt{#00FFFF}}$</td></tr><tr><td align="center">$\color{#020202}{Aquamarine}$</td><td align="center">$\color{Aquamarine}\text{#7FFFD4}$</td><td align="center">$\color{Aquamarine}\text{rgb(127, 255, 212)}$</td><td align="center">$\colorbox{Aquamarine}{\color{Aquamarine}\texttt{#7FFFD4}}$</td></tr><tr><td align="center">$\color{#020202}{Azure}$</td><td align="center">$\color{Azure}\text{#F0FFFF}$</td><td align="center">$\color{Azure}\text{rgb(240, 255, 255)}$</td><td align="center">$\colorbox{Azure}{\color{Azure}\texttt{#F0FFFF}}$</td></tr><tr><td align="center">$\color{#020202}{Beige}$</td><td align="center">$\color{Beige}\text{#F5F5DC}$</td><td align="center">$\color{Beige}\text{rgb(245, 245, 220)}$</td><td align="center">$\colorbox{Beige}{\color{Beige}\texttt{#F5F5DC}}$</td></tr><tr><td align="center">$\color{#020202}{Bisque}$</td><td align="center">$\color{Bisque}\text{#FFE4C4}$</td><td align="center">$\color{Bisque}\text{rgb(255, 228, 196)}$</td><td align="center">$\colorbox{Bisque}{\color{Bisque}\texttt{#FFE4C4}}$</td></tr><tr><td align="center">$\color{#020202}{Black}$</td><td align="center">$\color{Black}\text{#000000}$</td><td align="center">$\color{Black}\text{rgb(0, 0, 0)}$</td><td align="center">$\colorbox{Black}{\color{Black}\texttt{#000000}}$</td></tr><tr><td align="center">$\color{#020202}{BlanchedAlmond}$</td><td align="center">$\color{BlanchedAlmond}\text{#FFEBCD}$</td><td align="center">$\color{BlanchedAlmond}\text{rgb(255, 235, 205)}$</td><td align="center">$\colorbox{BlanchedAlmond}{\color{BlanchedAlmond}\texttt{#FFEBCD}}$</td></tr><tr><td align="center">$\color{#020202}{Blue}$</td><td align="center">$\color{Blue}\text{#0000FF}$</td><td align="center">$\color{Blue}\text{rgb(0, 0, 255)}$</td><td align="center">$\colorbox{Blue}{\color{Blue}\texttt{#0000FF}}$</td></tr><tr><td align="center">$\color{#020202}{BlueViolet}$</td><td align="center">$\color{BlueViolet}\text{#8A2BE2}$</td><td align="center">$\color{BlueViolet}\text{rgb(138, 43, 226)}$</td><td align="center">$\colorbox{BlueViolet}{\color{BlueViolet}\texttt{#8A2BE2}}$</td></tr><tr><td align="center">$\color{#020202}{Brown}$</td><td align="center">$\color{Brown}\text{#A52A2A}$</td><td align="center">$\color{Brown}\text{rgb(165, 42, 42)}$</td><td align="center">$\colorbox{Brown}{\color{Brown}\texttt{#A52A2A}}$</td></tr><tr><td align="center">$\color{#020202}{BurlyWood}$</td><td align="center">$\color{BurlyWood}\text{#DEB887}$</td><td align="center">$\color{BurlyWood}\text{rgb(222, 184, 135)}$</td><td align="center">$\colorbox{BurlyWood}{\color{BurlyWood}\texttt{#DEB887}}$</td></tr><tr><td align="center">$\color{#020202}{CadetBlue}$</td><td align="center">$\color{CadetBlue}\text{#5F9EA0}$</td><td align="center">$\color{CadetBlue}\text{rgb(95, 158, 160)}$</td><td align="center">$\colorbox{CadetBlue}{\color{CadetBlue}\texttt{#5F9EA0}}$</td></tr><tr><td align="center">$\color{#020202}{Chartreuse}$</td><td align="center">$\color{Chartreuse}\text{#7FFF00}$</td><td align="center">$\color{Chartreuse}\text{rgb(127, 255, 0)}$</td><td align="center">$\colorbox{Chartreuse}{\color{Chartreuse}\texttt{#7FFF00}}$</td></tr><tr><td align="center">$\color{#020202}{Chocolate}$</td><td align="center">$\color{Chocolate}\text{#D2691E}$</td><td align="center">$\color{Chocolate}\text{rgb(210, 105, 30)}$</td><td align="center">$\colorbox{Chocolate}{\color{Chocolate}\texttt{#D2691E}}$</td></tr><tr><td align="center">$\color{#020202}{Coral}$</td><td align="center">$\color{Coral}\text{#FF7F50}$</td><td align="center">$\color{Coral}\text{rgb(255, 127, 80)}$</td><td align="center">$\colorbox{Coral}{\color{Coral}\texttt{#FF7F50}}$</td></tr><tr><td align="center">$\color{#020202}{CornflowerBlue}$</td><td align="center">$\color{CornflowerBlue}\text{#6495ED}$</td><td align="center">$\color{CornflowerBlue}\text{rgb(100, 149, 237)}$</td><td align="center">$\colorbox{CornflowerBlue}{\color{CornflowerBlue}\texttt{#6495ED}}$</td></tr><tr><td align="center">$\color{#020202}{Cornsilk}$</td><td align="center">$\color{Cornsilk}\text{#FFF8DC}$</td><td align="center">$\color{Cornsilk}\text{rgb(255, 248, 220)}$</td><td align="center">$\colorbox{Cornsilk}{\color{Cornsilk}\texttt{#FFF8DC}}$</td></tr><tr><td align="center">$\color{#020202}{Crimson}$</td><td align="center">$\color{Crimson}\text{#DC143C}$</td><td align="center">$\color{Crimson}\text{rgb(220, 20, 60)}$</td><td align="center">$\colorbox{Crimson}{\color{Crimson}\texttt{#DC143C}}$</td></tr><tr><td align="center">$\color{#020202}{Cyan}$</td><td align="center">$\color{Cyan}\text{#00FFFF}$</td><td align="center">$\color{Cyan}\text{rgb(0, 255, 255)}$</td><td align="center">$\colorbox{Cyan}{\color{Cyan}\texttt{#00FFFF}}$</td></tr><tr><td align="center">$\color{#020202}{DarkBlue}$</td><td align="center">$\color{DarkBlue}\text{#00008B}$</td><td align="center">$\color{DarkBlue}\text{rgb(0, 0, 139)}$</td><td align="center">$\colorbox{DarkBlue}{\color{DarkBlue}\texttt{#00008B}}$</td></tr><tr><td align="center">$\color{#020202}{DarkCyan}$</td><td align="center">$\color{DarkCyan}\text{#008B8B}$</td><td align="center">$\color{DarkCyan}\text{rgb(0, 139, 139)}$</td><td align="center">$\colorbox{DarkCyan}{\color{DarkCyan}\texttt{#008B8B}}$</td></tr><tr><td align="center">$\color{#020202}{DarkGoldenRod}$</td><td align="center">$\color{DarkGoldenRod}\text{#B8860B}$</td><td align="center">$\color{DarkGoldenRod}\text{rgb(184, 134, 11)}$</td><td align="center">$\colorbox{DarkGoldenRod}{\color{DarkGoldenRod}\texttt{#B8860B}}$</td></tr><tr><td align="center">$\color{#020202}{DarkGray}$</td><td align="center">$\color{DarkGray}\text{#A9A9A9}$</td><td align="center">$\color{DarkGray}\text{rgb(169, 169, 169)}$</td><td align="center">$\colorbox{DarkGray}{\color{DarkGray}\texttt{#A9A9A9}}$</td></tr><tr><td align="center">$\color{#020202}{DarkGreen}$</td><td align="center">$\color{DarkGreen}\text{#006400}$</td><td align="center">$\color{DarkGreen}\text{rgb(0, 100, 0)}$</td><td align="center">$\colorbox{DarkGreen}{\color{DarkGreen}\texttt{#006400}}$</td></tr><tr><td align="center">$\color{#020202}{DarkKhaki}$</td><td align="center">$\color{DarkKhaki}\text{#BDB76B}$</td><td align="center">$\color{DarkKhaki}\text{rgb(189, 183, 107)}$</td><td align="center">$\colorbox{DarkKhaki}{\color{DarkKhaki}\texttt{#BDB76B}}$</td></tr><tr><td align="center">$\color{#020202}{DarkMagenta}$</td><td align="center">$\color{DarkMagenta}\text{#8B008B}$</td><td align="center">$\color{DarkMagenta}\text{rgb(139, 0, 139)}$</td><td align="center">$\colorbox{DarkMagenta}{\color{DarkMagenta}\texttt{#8B008B}}$</td></tr><tr><td align="center">$\color{#020202}{DarkOliveGreen}$</td><td align="center">$\color{DarkOliveGreen}\text{#556B2F}$</td><td align="center">$\color{DarkOliveGreen}\text{rgb(85, 107, 47)}$</td><td align="center">$\colorbox{DarkOliveGreen}{\color{DarkOliveGreen}\texttt{#556B2F}}$</td></tr><tr><td align="center">$\color{#020202}{Darkorange}$</td><td align="center">$\color{Darkorange}\text{#FF8C00}$</td><td align="center">$\color{Darkorange}\text{rgb(255, 140, 0)}$</td><td align="center">$\colorbox{Darkorange}{\color{Darkorange}\texttt{#FF8C00}}$</td></tr><tr><td align="center">$\color{#020202}{DarkOrchid}$</td><td align="center">$\color{DarkOrchid}\text{#9932CC}$</td><td align="center">$\color{DarkOrchid}\text{rgb(153, 50, 204)}$</td><td align="center">$\colorbox{DarkOrchid}{\color{DarkOrchid}\texttt{#9932CC}}$</td></tr><tr><td align="center">$\color{#020202}{DarkRed}$</td><td align="center">$\color{DarkRed}\text{#8B0000}$</td><td align="center">$\color{DarkRed}\text{rgb(139, 0, 0)}$</td><td align="center">$\colorbox{DarkRed}{\color{DarkRed}\texttt{#8B0000}}$</td></tr><tr><td align="center">$\color{#020202}{DarkSalmon}$</td><td align="center">$\color{DarkSalmon}\text{#E9967A}$</td><td align="center">$\color{DarkSalmon}\text{rgb(233, 150, 122)}$</td><td align="center">$\colorbox{DarkSalmon}{\color{DarkSalmon}\texttt{#E9967A}}$</td></tr><tr><td align="center">$\color{#020202}{DarkSeaGreen}$</td><td align="center">$\color{DarkSeaGreen}\text{#8FBC8F}$</td><td align="center">$\color{DarkSeaGreen}\text{rgb(143, 188, 143)}$</td><td align="center">$\colorbox{DarkSeaGreen}{\color{DarkSeaGreen}\texttt{#8FBC8F}}$</td></tr><tr><td align="center">$\color{#020202}{DarkSlateBlue}$</td><td align="center">$\color{DarkSlateBlue}\text{#483D8B}$</td><td align="center">$\color{DarkSlateBlue}\text{rgb(72, 61, 139)}$</td><td align="center">$\colorbox{DarkSlateBlue}{\color{DarkSlateBlue}\texttt{#483D8B}}$</td></tr><tr><td align="center">$\color{#020202}{DarkSlateGray}$</td><td align="center">$\color{DarkSlateGray}\text{#2F4F4F}$</td><td align="center">$\color{DarkSlateGray}\text{rgb(47, 79, 79)}$</td><td align="center">$\colorbox{DarkSlateGray}{\color{DarkSlateGray}\texttt{#2F4F4F}}$</td></tr><tr><td align="center">$\color{#020202}{DarkTurquoise}$</td><td align="center">$\color{DarkTurquoise}\text{#00CED1}$</td><td align="center">$\color{DarkTurquoise}\text{rgb(0, 206, 209)}$</td><td align="center">$\colorbox{DarkTurquoise}{\color{DarkTurquoise}\texttt{#00CED1}}$</td></tr><tr><td align="center">$\color{#020202}{DarkViolet}$</td><td align="center">$\color{DarkViolet}\text{#9400D3}$</td><td align="center">$\color{DarkViolet}\text{rgb(148, 0, 211)}$</td><td align="center">$\colorbox{DarkViolet}{\color{DarkViolet}\texttt{#9400D3}}$</td></tr><tr><td align="center">$\color{#020202}{DeepPink}$</td><td align="center">$\color{DeepPink}\text{#FF1493}$</td><td align="center">$\color{DeepPink}\text{rgb(255, 20, 147)}$</td><td align="center">$\colorbox{DeepPink}{\color{DeepPink}\texttt{#FF1493}}$</td></tr><tr><td align="center">$\color{#020202}{DeepSkyBlue}$</td><td align="center">$\color{DeepSkyBlue}\text{#00BFFF}$</td><td align="center">$\color{DeepSkyBlue}\text{rgb(0, 191, 255)}$</td><td align="center">$\colorbox{DeepSkyBlue}{\color{DeepSkyBlue}\texttt{#00BFFF}}$</td></tr><tr><td align="center">$\color{#020202}{DimGray}$</td><td align="center">$\color{DimGray}\text{#696969}$</td><td align="center">$\color{DimGray}\text{rgb(105, 105, 105)}$</td><td align="center">$\colorbox{DimGray}{\color{DimGray}\texttt{#696969}}$</td></tr><tr><td align="center">$\color{#020202}{DodgerBlue}$</td><td align="center">$\color{DodgerBlue}\text{#1E90FF}$</td><td align="center">$\color{DodgerBlue}\text{rgb(30, 144, 255)}$</td><td align="center">$\colorbox{DodgerBlue}{\color{DodgerBlue}\texttt{#1E90FF}}$</td></tr><tr><td align="center">$\color{#020202}{Feldspar}$</td><td align="center">$\color{Feldspar}\text{#D19275}$</td><td align="center">$\color{Feldspar}\text{rgb(209, 146, 117)}$</td><td align="center">$\colorbox{Feldspar}{\color{Feldspar}\texttt{#D19275}}$</td></tr><tr><td align="center">$\color{#020202}{FireBrick}$</td><td align="center">$\color{FireBrick}\text{#B22222}$</td><td align="center">$\color{FireBrick}\text{rgb(178, 34, 34)}$</td><td align="center">$\colorbox{FireBrick}{\color{FireBrick}\texttt{#B22222}}$</td></tr><tr><td align="center">$\color{#020202}{FloralWhite}$</td><td align="center">$\color{FloralWhite}\text{#FFFAF0}$</td><td align="center">$\color{FloralWhite}\text{rgb(255, 250, 240)}$</td><td align="center">$\colorbox{FloralWhite}{\color{FloralWhite}\texttt{#FFFAF0}}$</td></tr><tr><td align="center">$\color{#020202}{ForestGreen}$</td><td align="center">$\color{ForestGreen}\text{#228B22}$</td><td align="center">$\color{ForestGreen}\text{rgb(34, 139, 34)}$</td><td align="center">$\colorbox{ForestGreen}{\color{ForestGreen}\texttt{#228B22}}$</td></tr><tr><td align="center">$\color{#020202}{Fuchsia}$</td><td align="center">$\color{Fuchsia}\text{#FF00FF}$</td><td align="center">$\color{Fuchsia}\text{rgb(255, 0, 255)}$</td><td align="center">$\colorbox{Fuchsia}{\color{Fuchsia}\texttt{#FF00FF}}$</td></tr><tr><td align="center">$\color{#020202}{Gainsboro}$</td><td align="center">$\color{Gainsboro}\text{#DCDCDC}$</td><td align="center">$\color{Gainsboro}\text{rgb(220, 220, 220)}$</td><td align="center">$\colorbox{Gainsboro}{\color{Gainsboro}\texttt{#DCDCDC}}$</td></tr><tr><td align="center">$\color{#020202}{GhostWhite}$</td><td align="center">$\color{GhostWhite}\text{#F8F8FF}$</td><td align="center">$\color{GhostWhite}\text{rgb(248, 248, 255)}$</td><td align="center">$\colorbox{GhostWhite}{\color{GhostWhite}\texttt{#F8F8FF}}$</td></tr><tr><td align="center">$\color{#020202}{Gold}$</td><td align="center">$\color{Gold}\text{#FFD700}$</td><td align="center">$\color{Gold}\text{rgb(255, 215, 0)}$</td><td align="center">$\colorbox{Gold}{\color{Gold}\texttt{#FFD700}}$</td></tr><tr><td align="center">$\color{#020202}{GoldenRod}$</td><td align="center">$\color{GoldenRod}\text{#DAA520}$</td><td align="center">$\color{GoldenRod}\text{rgb(218, 165, 32)}$</td><td align="center">$\colorbox{GoldenRod}{\color{GoldenRod}\texttt{#DAA520}}$</td></tr><tr><td align="center">$\color{#020202}{Gray}$</td><td align="center">$\color{Gray}\text{#808080}$</td><td align="center">$\color{Gray}\text{rgb(128, 128, 128)}$</td><td align="center">$\colorbox{Gray}{\color{Gray}\texttt{#808080}}$</td></tr><tr><td align="center">$\color{#020202}{Green}$</td><td align="center">$\color{Green}\text{#008000}$</td><td align="center">$\color{Green}\text{rgb(0, 128, 0)}$</td><td align="center">$\colorbox{Green}{\color{Green}\texttt{#008000}}$</td></tr><tr><td align="center">$\color{#020202}{GreenYellow}$</td><td align="center">$\color{GreenYellow}\text{#ADFF2F}$</td><td align="center">$\color{GreenYellow}\text{rgb(173, 255, 47)}$</td><td align="center">$\colorbox{GreenYellow}{\color{GreenYellow}\texttt{#ADFF2F}}$</td></tr><tr><td align="center">$\color{#020202}{HoneyDew}$</td><td align="center">$\color{HoneyDew}\text{#F0FFF0}$</td><td align="center">$\color{HoneyDew}\text{rgb(240, 255, 240)}$</td><td align="center">$\colorbox{HoneyDew}{\color{HoneyDew}\texttt{#F0FFF0}}$</td></tr><tr><td align="center">$\color{#020202}{HotPink}$</td><td align="center">$\color{HotPink}\text{#FF69B4}$</td><td align="center">$\color{HotPink}\text{rgb(255, 105, 180)}$</td><td align="center">$\colorbox{HotPink}{\color{HotPink}\texttt{#FF69B4}}$</td></tr><tr><td align="center">$\color{#020202}{IndianRed}$</td><td align="center">$\color{IndianRed}\text{#CD5C5C}$</td><td align="center">$\color{IndianRed}\text{rgb(205, 92, 92)}$</td><td align="center">$\colorbox{IndianRed}{\color{IndianRed}\texttt{#CD5C5C}}$</td></tr><tr><td align="center">$\color{#020202}{Indigo}$</td><td align="center">$\color{Indigo}\text{#4B0082}$</td><td align="center">$\color{Indigo}\text{rgb(75, 0, 130)}$</td><td align="center">$\colorbox{Indigo}{\color{Indigo}\texttt{#4B0082}}$</td></tr><tr><td align="center">$\color{#020202}{Ivory}$</td><td align="center">$\color{Ivory}\text{#FFFFF0}$</td><td align="center">$\color{Ivory}\text{rgb(255, 255, 240)}$</td><td align="center">$\colorbox{Ivory}{\color{Ivory}\texttt{#FFFFF0}}$</td></tr><tr><td align="center">$\color{#020202}{Khaki}$</td><td align="center">$\color{Khaki}\text{#F0E68C}$</td><td align="center">$\color{Khaki}\text{rgb(240, 230, 140)}$</td><td align="center">$\colorbox{Khaki}{\color{Khaki}\texttt{#F0E68C}}$</td></tr><tr><td align="center">$\color{#020202}{Lavender}$</td><td align="center">$\color{Lavender}\text{#E6E6FA}$</td><td align="center">$\color{Lavender}\text{rgb(230, 230, 250)}$</td><td align="center">$\colorbox{Lavender}{\color{Lavender}\texttt{#E6E6FA}}$</td></tr><tr><td align="center">$\color{#020202}{LavenderBlush}$</td><td align="center">$\color{LavenderBlush}\text{#FFF0F5}$</td><td align="center">$\color{LavenderBlush}\text{rgb(255, 240, 245)}$</td><td align="center">$\colorbox{LavenderBlush}{\color{LavenderBlush}\texttt{#FFF0F5}}$</td></tr><tr><td align="center">$\color{#020202}{LawnGreen}$</td><td align="center">$\color{LawnGreen}\text{#7CFC00}$</td><td align="center">$\color{LawnGreen}\text{rgb(124, 252, 0)}$</td><td align="center">$\colorbox{LawnGreen}{\color{LawnGreen}\texttt{#7CFC00}}$</td></tr><tr><td align="center">$\color{#020202}{LemonChiffon}$</td><td align="center">$\color{LemonChiffon}\text{#FFFACD}$</td><td align="center">$\color{LemonChiffon}\text{rgb(255, 250, 205)}$</td><td align="center">$\colorbox{LemonChiffon}{\color{LemonChiffon}\texttt{#FFFACD}}$</td></tr><tr><td align="center">$\color{#020202}{LightBlue}$</td><td align="center">$\color{LightBlue}\text{#ADD8E6}$</td><td align="center">$\color{LightBlue}\text{rgb(173, 216, 230)}$</td><td align="center">$\colorbox{LightBlue}{\color{LightBlue}\texttt{#ADD8E6}}$</td></tr><tr><td align="center">$\color{#020202}{LightCoral}$</td><td align="center">$\color{LightCoral}\text{#F08080}$</td><td align="center">$\color{LightCoral}\text{rgb(240, 128, 128)}$</td><td align="center">$\colorbox{LightCoral}{\color{LightCoral}\texttt{#F08080}}$</td></tr><tr><td align="center">$\color{#020202}{LightCyan}$</td><td align="center">$\color{LightCyan}\text{#E0FFFF}$</td><td align="center">$\color{LightCyan}\text{rgb(224, 255, 255)}$</td><td align="center">$\colorbox{LightCyan}{\color{LightCyan}\texttt{#E0FFFF}}$</td></tr><tr><td align="center">$\color{#020202}{LightGoldenRodYellow}$</td><td align="center">$\color{LightGoldenRodYellow}\text{#FAFAD2}$</td><td align="center">$\color{LightGoldenRodYellow}\text{rgb(250, 250, 210)}$</td><td align="center">$\colorbox{LightGoldenRodYellow}{\color{LightGoldenRodYellow}\texttt{#FAFAD2}}$</td></tr><tr><td align="center">$\color{#020202}{LightGrey}$</td><td align="center">$\color{LightGrey}\text{#D3D3D3}$</td><td align="center">$\color{LightGrey}\text{rgb(211, 211, 211)}$</td><td align="center">$\colorbox{LightGrey}{\color{LightGrey}\texttt{#D3D3D3}}$</td></tr><tr><td align="center">$\color{#020202}{LightGreen}$</td><td align="center">$\color{LightGreen}\text{#90EE90}$</td><td align="center">$\color{LightGreen}\text{rgb(144, 238, 144)}$</td><td align="center">$\colorbox{LightGreen}{\color{LightGreen}\texttt{#90EE90}}$</td></tr><tr><td align="center">$\color{#020202}{LightPink}$</td><td align="center">$\color{LightPink}\text{#FFB6C1}$</td><td align="center">$\color{LightPink}\text{rgb(255, 182, 193)}$</td><td align="center">$\colorbox{LightPink}{\color{LightPink}\texttt{#FFB6C1}}$</td></tr><tr><td align="center">$\color{#020202}{LightSalmon}$</td><td align="center">$\color{LightSalmon}\text{#FFA07A}$</td><td align="center">$\color{LightSalmon}\text{rgb(255, 160, 122)}$</td><td align="center">$\colorbox{LightSalmon}{\color{LightSalmon}\texttt{#FFA07A}}$</td></tr><tr><td align="center">$\color{#020202}{LightSeaGreen}$</td><td align="center">$\color{LightSeaGreen}\text{#20B2AA}$</td><td align="center">$\color{LightSeaGreen}\text{rgb(32, 178, 170)}$</td><td align="center">$\colorbox{LightSeaGreen}{\color{LightSeaGreen}\texttt{#20B2AA}}$</td></tr><tr><td align="center">$\color{#020202}{LightSkyBlue}$</td><td align="center">$\color{LightSkyBlue}\text{#87CEFA}$</td><td align="center">$\color{LightSkyBlue}\text{rgb(135, 206, 250)}$</td><td align="center">$\colorbox{LightSkyBlue}{\color{LightSkyBlue}\texttt{#87CEFA}}$</td></tr><tr><td align="center">$\color{#020202}{LightSlateBlue}$</td><td align="center">$\color{LightSlateBlue}\text{#8470FF}$</td><td align="center">$\color{LightSlateBlue}\text{rgb(132, 112, 255)}$</td><td align="center">$\colorbox{LightSlateBlue}{\color{LightSlateBlue}\texttt{#8470FF}}$</td></tr><tr><td align="center">$\color{#020202}{LightSlateGray}$</td><td align="center">$\color{LightSlateGray}\text{#778899}$</td><td align="center">$\color{LightSlateGray}\text{rgb(119, 136, 153)}$</td><td align="center">$\colorbox{LightSlateGray}{\color{LightSlateGray}\texttt{#778899}}$</td></tr><tr><td align="center">$\color{#020202}{LightSteelBlue}$</td><td align="center">$\color{LightSteelBlue}\text{#B0C4DE}$</td><td align="center">$\color{LightSteelBlue}\text{rgb(176, 196, 222)}$</td><td align="center">$\colorbox{LightSteelBlue}{\color{LightSteelBlue}\texttt{#B0C4DE}}$</td></tr><tr><td align="center">$\color{#020202}{LightYellow}$</td><td align="center">$\color{LightYellow}\text{#FFFFE0}$</td><td align="center">$\color{LightYellow}\text{rgb(255, 255, 224)}$</td><td align="center">$\colorbox{LightYellow}{\color{LightYellow}\texttt{#FFFFE0}}$</td></tr><tr><td align="center">$\color{#020202}{Lime}$</td><td align="center">$\color{Lime}\text{#00FF00}$</td><td align="center">$\color{Lime}\text{rgb(0, 255, 0)}$</td><td align="center">$\colorbox{Lime}{\color{Lime}\texttt{#00FF00}}$</td></tr><tr><td align="center">$\color{#020202}{LimeGreen}$</td><td align="center">$\color{LimeGreen}\text{#32CD32}$</td><td align="center">$\color{LimeGreen}\text{rgb(50, 205, 50)}$</td><td align="center">$\colorbox{LimeGreen}{\color{LimeGreen}\texttt{#32CD32}}$</td></tr><tr><td align="center">$\color{#020202}{Linen}$</td><td align="center">$\color{Linen}\text{#FAF0E6}$</td><td align="center">$\color{Linen}\text{rgb(250, 240, 230)}$</td><td align="center">$\colorbox{Linen}{\color{Linen}\texttt{#FAF0E6}}$</td></tr><tr><td align="center">$\color{#020202}{Magenta}$</td><td align="center">$\color{Magenta}\text{#FF00FF}$</td><td align="center">$\color{Magenta}\text{rgb(255, 0, 255)}$</td><td align="center">$\colorbox{Magenta}{\color{Magenta}\texttt{#FF00FF}}$</td></tr><tr><td align="center">$\color{#020202}{Maroon}$</td><td align="center">$\color{Maroon}\text{#800000}$</td><td align="center">$\color{Maroon}\text{rgb(128, 0, 0)}$</td><td align="center">$\colorbox{Maroon}{\color{Maroon}\texttt{#800000}}$</td></tr><tr><td align="center">$\color{#020202}{MediumAquaMarine}$</td><td align="center">$\color{MediumAquaMarine}\text{#66CDAA}$</td><td align="center">$\color{MediumAquaMarine}\text{rgb(102, 205, 170)}$</td><td align="center">$\colorbox{MediumAquaMarine}{\color{MediumAquaMarine}\texttt{#66CDAA}}$</td></tr><tr><td align="center">$\color{#020202}{MediumBlue}$</td><td align="center">$\color{MediumBlue}\text{#0000CD}$</td><td align="center">$\color{MediumBlue}\text{rgb(0, 0, 205)}$</td><td align="center">$\colorbox{MediumBlue}{\color{MediumBlue}\texttt{#0000CD}}$</td></tr><tr><td align="center">$\color{#020202}{MediumOrchid}$</td><td align="center">$\color{MediumOrchid}\text{#BA55D3}$</td><td align="center">$\color{MediumOrchid}\text{rgb(186, 85, 211)}$</td><td align="center">$\colorbox{MediumOrchid}{\color{MediumOrchid}\texttt{#BA55D3}}$</td></tr><tr><td align="center">$\color{#020202}{MediumPurple}$</td><td align="center">$\color{MediumPurple}\text{#9370D8}$</td><td align="center">$\color{MediumPurple}\text{rgb(147, 112, 216)}$</td><td align="center">$\colorbox{MediumPurple}{\color{MediumPurple}\texttt{#9370D8}}$</td></tr><tr><td align="center">$\color{#020202}{MediumSeaGreen}$</td><td align="center">$\color{MediumSeaGreen}\text{#3CB371}$</td><td align="center">$\color{MediumSeaGreen}\text{rgb(60, 179, 113)}$</td><td align="center">$\colorbox{MediumSeaGreen}{\color{MediumSeaGreen}\texttt{#3CB371}}$</td></tr><tr><td align="center">$\color{#020202}{MediumSlateBlue}$</td><td align="center">$\color{MediumSlateBlue}\text{#7B68EE}$</td><td align="center">$\color{MediumSlateBlue}\text{rgb(123, 104, 238)}$</td><td align="center">$\colorbox{MediumSlateBlue}{\color{MediumSlateBlue}\texttt{#7B68EE}}$</td></tr><tr><td align="center">$\color{#020202}{MediumSpringGreen}$</td><td align="center">$\color{MediumSpringGreen}\text{#00FA9A}$</td><td align="center">$\color{MediumSpringGreen}\text{rgb(0, 250, 154)}$</td><td align="center">$\colorbox{MediumSpringGreen}{\color{MediumSpringGreen}\texttt{#00FA9A}}$</td></tr><tr><td align="center">$\color{#020202}{MediumTurquoise}$</td><td align="center">$\color{MediumTurquoise}\text{#48D1CC}$</td><td align="center">$\color{MediumTurquoise}\text{rgb(72, 209, 204)}$</td><td align="center">$\colorbox{MediumTurquoise}{\color{MediumTurquoise}\texttt{#48D1CC}}$</td></tr><tr><td align="center">$\color{#020202}{MediumVioletRed}$</td><td align="center">$\color{MediumVioletRed}\text{#C71585}$</td><td align="center">$\color{MediumVioletRed}\text{rgb(199, 21, 133)}$</td><td align="center">$\colorbox{MediumVioletRed}{\color{MediumVioletRed}\texttt{#C71585}}$</td></tr><tr><td align="center">$\color{#020202}{MidnightBlue}$</td><td align="center">$\color{MidnightBlue}\text{#191970}$</td><td align="center">$\color{MidnightBlue}\text{rgb(25, 25, 112)}$</td><td align="center">$\colorbox{MidnightBlue}{\color{MidnightBlue}\texttt{#191970}}$</td></tr><tr><td align="center">$\color{#020202}{MintCream}$</td><td align="center">$\color{MintCream}\text{#F5FFFA}$</td><td align="center">$\color{MintCream}\text{rgb(245, 255, 250)}$</td><td align="center">$\colorbox{MintCream}{\color{MintCream}\texttt{#F5FFFA}}$</td></tr><tr><td align="center">$\color{#020202}{MistyRose}$</td><td align="center">$\color{MistyRose}\text{#FFE4E1}$</td><td align="center">$\color{MistyRose}\text{rgb(255, 228, 225)}$</td><td align="center">$\colorbox{MistyRose}{\color{MistyRose}\texttt{#FFE4E1}}$</td></tr><tr><td align="center">$\color{#020202}{Moccasin}$</td><td align="center">$\color{Moccasin}\text{#FFE4B5}$</td><td align="center">$\color{Moccasin}\text{rgb(255, 228, 181)}$</td><td align="center">$\colorbox{Moccasin}{\color{Moccasin}\texttt{#FFE4B5}}$</td></tr><tr><td align="center">$\color{#020202}{NavajoWhite}$</td><td align="center">$\color{NavajoWhite}\text{#FFDEAD}$</td><td align="center">$\color{NavajoWhite}\text{rgb(255, 222, 173)}$</td><td align="center">$\colorbox{NavajoWhite}{\color{NavajoWhite}\texttt{#FFDEAD}}$</td></tr><tr><td align="center">$\color{#020202}{Navy}$</td><td align="center">$\color{Navy}\text{#000080}$</td><td align="center">$\color{Navy}\text{rgb(0, 0, 128)}$</td><td align="center">$\colorbox{Navy}{\color{Navy}\texttt{#000080}}$</td></tr><tr><td align="center">$\color{#020202}{OldLace}$</td><td align="center">$\color{OldLace}\text{#FDF5E6}$</td><td align="center">$\color{OldLace}\text{rgb(253, 245, 230)}$</td><td align="center">$\colorbox{OldLace}{\color{OldLace}\texttt{#FDF5E6}}$</td></tr><tr><td align="center">$\color{#020202}{Olive}$</td><td align="center">$\color{Olive}\text{#808000}$</td><td align="center">$\color{Olive}\text{rgb(128, 128, 0)}$</td><td align="center">$\colorbox{Olive}{\color{Olive}\texttt{#808000}}$</td></tr><tr><td align="center">$\color{#020202}{OliveDrab}$</td><td align="center">$\color{OliveDrab}\text{#6B8E23}$</td><td align="center">$\color{OliveDrab}\text{rgb(107, 142, 35)}$</td><td align="center">$\colorbox{OliveDrab}{\color{OliveDrab}\texttt{#6B8E23}}$</td></tr><tr><td align="center">$\color{#020202}{Orange}$</td><td align="center">$\color{Orange}\text{#FFA500}$</td><td align="center">$\color{Orange}\text{rgb(255, 165, 0)}$</td><td align="center">$\colorbox{Orange}{\color{Orange}\texttt{#FFA500}}$</td></tr><tr><td align="center">$\color{#020202}{OrangeRed}$</td><td align="center">$\color{OrangeRed}\text{#FF4500}$</td><td align="center">$\color{OrangeRed}\text{rgb(255, 69, 0)}$</td><td align="center">$\colorbox{OrangeRed}{\color{OrangeRed}\texttt{#FF4500}}$</td></tr><tr><td align="center">$\color{#020202}{Orchid}$</td><td align="center">$\color{Orchid}\text{#DA70D6}$</td><td align="center">$\color{Orchid}\text{rgb(218, 112, 214)}$</td><td align="center">$\colorbox{Orchid}{\color{Orchid}\texttt{#DA70D6}}$</td></tr><tr><td align="center">$\color{#020202}{PaleGoldenRod}$</td><td align="center">$\color{PaleGoldenRod}\text{#EEE8AA}$</td><td align="center">$\color{PaleGoldenRod}\text{rgb(238, 232, 170)}$</td><td align="center">$\colorbox{PaleGoldenRod}{\color{PaleGoldenRod}\texttt{#EEE8AA}}$</td></tr><tr><td align="center">$\color{#020202}{PaleGreen}$</td><td align="center">$\color{PaleGreen}\text{#98FB98}$</td><td align="center">$\color{PaleGreen}\text{rgb(152, 251, 152)}$</td><td align="center">$\colorbox{PaleGreen}{\color{PaleGreen}\texttt{#98FB98}}$</td></tr><tr><td align="center">$\color{#020202}{PaleTurquoise}$</td><td align="center">$\color{PaleTurquoise}\text{#AFEEEE}$</td><td align="center">$\color{PaleTurquoise}\text{rgb(175, 238, 238)}$</td><td align="center">$\colorbox{PaleTurquoise}{\color{PaleTurquoise}\texttt{#AFEEEE}}$</td></tr><tr><td align="center">$\color{#020202}{PaleVioletRed}$</td><td align="center">$\color{PaleVioletRed}\text{#D87093}$</td><td align="center">$\color{PaleVioletRed}\text{rgb(216, 112, 147)}$</td><td align="center">$\colorbox{PaleVioletRed}{\color{PaleVioletRed}\texttt{#D87093}}$</td></tr><tr><td align="center">$\color{#020202}{PapayaWhip}$</td><td align="center">$\color{PapayaWhip}\text{#FFEFD5}$</td><td align="center">$\color{PapayaWhip}\text{rgb(255, 239, 213)}$</td><td align="center">$\colorbox{PapayaWhip}{\color{PapayaWhip}\texttt{#FFEFD5}}$</td></tr><tr><td align="center">$\color{#020202}{PeachPuff}$</td><td align="center">$\color{PeachPuff}\text{#FFDAB9}$</td><td align="center">$\color{PeachPuff}\text{rgb(255, 218, 185)}$</td><td align="center">$\colorbox{PeachPuff}{\color{PeachPuff}\texttt{#FFDAB9}}$</td></tr><tr><td align="center">$\color{#020202}{Peru}$</td><td align="center">$\color{Peru}\text{#CD853F}$</td><td align="center">$\color{Peru}\text{rgb(205, 133, 63)}$</td><td align="center">$\colorbox{Peru}{\color{Peru}\texttt{#CD853F}}$</td></tr><tr><td align="center">$\color{#020202}{Pink}$</td><td align="center">$\color{Pink}\text{#FFC0CB}$</td><td align="center">$\color{Pink}\text{rgb(255, 192, 203)}$</td><td align="center">$\colorbox{Pink}{\color{Pink}\texttt{#FFC0CB}}$</td></tr><tr><td align="center">$\color{#020202}{Plum}$</td><td align="center">$\color{Plum}\text{#DDA0DD}$</td><td align="center">$\color{Plum}\text{rgb(221, 160, 221)}$</td><td align="center">$\colorbox{Plum}{\color{Plum}\texttt{#DDA0DD}}$</td></tr><tr><td align="center">$\color{#020202}{PowderBlue}$</td><td align="center">$\color{PowderBlue}\text{#B0E0E6}$</td><td align="center">$\color{PowderBlue}\text{rgb(176, 224, 230)}$</td><td align="center">$\colorbox{PowderBlue}{\color{PowderBlue}\texttt{#B0E0E6}}$</td></tr><tr><td align="center">$\color{#020202}{Purple}$</td><td align="center">$\color{Purple}\text{#800080}$</td><td align="center">$\color{Purple}\text{rgb(128, 0, 128)}$</td><td align="center">$\colorbox{Purple}{\color{Purple}\texttt{#800080}}$</td></tr><tr><td align="center">$\color{#020202}{Red}$</td><td align="center">$\color{Red}\text{#FF0000}$</td><td align="center">$\color{Red}\text{rgb(255, 0, 0)}$</td><td align="center">$\colorbox{Red}{\color{Red}\texttt{#FF0000}}$</td></tr><tr><td align="center">$\color{#020202}{RosyBrown}$</td><td align="center">$\color{RosyBrown}\text{#BC8F8F}$</td><td align="center">$\color{RosyBrown}\text{rgb(188, 143, 143)}$</td><td align="center">$\colorbox{RosyBrown}{\color{RosyBrown}\texttt{#BC8F8F}}$</td></tr><tr><td align="center">$\color{#020202}{RoyalBlue}$</td><td align="center">$\color{RoyalBlue}\text{#4169E1}$</td><td align="center">$\color{RoyalBlue}\text{rgb(65, 105, 225)}$</td><td align="center">$\colorbox{RoyalBlue}{\color{RoyalBlue}\texttt{#4169E1}}$</td></tr><tr><td align="center">$\color{#020202}{SaddleBrown}$</td><td align="center">$\color{SaddleBrown}\text{#8B4513}$</td><td align="center">$\color{SaddleBrown}\text{rgb(139, 69, 19)}$</td><td align="center">$\colorbox{SaddleBrown}{\color{SaddleBrown}\texttt{#8B4513}}$</td></tr><tr><td align="center">$\color{#020202}{Salmon}$</td><td align="center">$\color{Salmon}\text{#FA8072}$</td><td align="center">$\color{Salmon}\text{rgb(250, 128, 114)}$</td><td align="center">$\colorbox{Salmon}{\color{Salmon}\texttt{#FA8072}}$</td></tr><tr><td align="center">$\color{#020202}{SandyBrown}$</td><td align="center">$\color{SandyBrown}\text{#F4A460}$</td><td align="center">$\color{SandyBrown}\text{rgb(244, 164, 96)}$</td><td align="center">$\colorbox{SandyBrown}{\color{SandyBrown}\texttt{#F4A460}}$</td></tr><tr><td align="center">$\color{#020202}{SeaGreen}$</td><td align="center">$\color{SeaGreen}\text{#2E8B57}$</td><td align="center">$\color{SeaGreen}\text{rgb(46, 139, 87)}$</td><td align="center">$\colorbox{SeaGreen}{\color{SeaGreen}\texttt{#2E8B57}}$</td></tr><tr><td align="center">$\color{#020202}{SeaShell}$</td><td align="center">$\color{SeaShell}\text{#FFF5EE}$</td><td align="center">$\color{SeaShell}\text{rgb(255, 245, 238)}$</td><td align="center">$\colorbox{SeaShell}{\color{SeaShell}\texttt{#FFF5EE}}$</td></tr><tr><td align="center">$\color{#020202}{Sienna}$</td><td align="center">$\color{Sienna}\text{#A0522D}$</td><td align="center">$\color{Sienna}\text{rgb(160, 82, 45)}$</td><td align="center">$\colorbox{Sienna}{\color{Sienna}\texttt{#A0522D}}$</td></tr><tr><td align="center">$\color{#020202}{Silver}$</td><td align="center">$\color{Silver}\text{#C0C0C0}$</td><td align="center">$\color{Silver}\text{rgb(192, 192, 192)}$</td><td align="center">$\colorbox{Silver}{\color{Silver}\texttt{#C0C0C0}}$</td></tr><tr><td align="center">$\color{#020202}{SkyBlue}$</td><td align="center">$\color{SkyBlue}\text{#87CEEB}$</td><td align="center">$\color{SkyBlue}\text{rgb(135, 206, 235)}$</td><td align="center">$\colorbox{SkyBlue}{\color{SkyBlue}\texttt{#87CEEB}}$</td></tr><tr><td align="center">$\color{#020202}{SlateBlue}$</td><td align="center">$\color{SlateBlue}\text{#6A5ACD}$</td><td align="center">$\color{SlateBlue}\text{rgb(106, 90, 205)}$</td><td align="center">$\colorbox{SlateBlue}{\color{SlateBlue}\texttt{#6A5ACD}}$</td></tr><tr><td align="center">$\color{#020202}{SlateGray}$</td><td align="center">$\color{SlateGray}\text{#708090}$</td><td align="center">$\color{SlateGray}\text{rgb(112, 128, 144)}$</td><td align="center">$\colorbox{SlateGray}{\color{SlateGray}\texttt{#708090}}$</td></tr><tr><td align="center">$\color{#020202}{Snow}$</td><td align="center">$\color{Snow}\text{#FFFAFA}$</td><td align="center">$\color{Snow}\text{rgb(255, 250, 250)}$</td><td align="center">$\colorbox{Snow}{\color{Snow}\texttt{#FFFAFA}}$</td></tr><tr><td align="center">$\color{#020202}{SpringGreen}$</td><td align="center">$\color{SpringGreen}\text{#00FF7F}$</td><td align="center">$\color{SpringGreen}\text{rgb(0, 255, 127)}$</td><td align="center">$\colorbox{SpringGreen}{\color{SpringGreen}\texttt{#00FF7F}}$</td></tr><tr><td align="center">$\color{#020202}{SteelBlue}$</td><td align="center">$\color{SteelBlue}\text{#4682B4}$</td><td align="center">$\color{SteelBlue}\text{rgb(70, 130, 180)}$</td><td align="center">$\colorbox{SteelBlue}{\color{SteelBlue}\texttt{#4682B4}}$</td></tr><tr><td align="center">$\color{#020202}{Tan}$</td><td align="center">$\color{Tan}\text{#D2B48C}$</td><td align="center">$\color{Tan}\text{rgb(210, 180, 140)}$</td><td align="center">$\colorbox{Tan}{\color{Tan}\texttt{#D2B48C}}$</td></tr><tr><td align="center">$\color{#020202}{Teal}$</td><td align="center">$\color{Teal}\text{#008080}$</td><td align="center">$\color{Teal}\text{rgb(0, 128, 128)}$</td><td align="center">$\colorbox{Teal}{\color{Teal}\texttt{#008080}}$</td></tr><tr><td align="center">$\color{#020202}{Thistle}$</td><td align="center">$\color{Thistle}\text{#D8BFD8}$</td><td align="center">$\color{Thistle}\text{rgb(216, 191, 216)}$</td><td align="center">$\colorbox{Thistle}{\color{Thistle}\texttt{#D8BFD8}}$</td></tr><tr><td align="center">$\color{#020202}{Tomato}$</td><td align="center">$\color{Tomato}\text{#FF6347}$</td><td align="center">$\color{Tomato}\text{rgb(255, 99, 71)}$</td><td align="center">$\colorbox{Tomato}{\color{Tomato}\texttt{#FF6347}}$</td></tr><tr><td align="center">$\color{#020202}{Turquoise}$</td><td align="center">$\color{Turquoise}\text{#40E0D0}$</td><td align="center">$\color{Turquoise}\text{rgb(64, 224, 208)}$</td><td align="center">$\colorbox{Turquoise}{\color{Turquoise}\texttt{#40E0D0}}$</td></tr><tr><td align="center">$\color{#020202}{Violet}$</td><td align="center">$\color{Violet}\text{#EE82EE}$</td><td align="center">$\color{Violet}\text{rgb(238, 130, 238)}$</td><td align="center">$\colorbox{Violet}{\color{Violet}\texttt{#EE82EE}}$</td></tr><tr><td align="center">$\color{#020202}{VioletRed}$</td><td align="center">$\color{VioletRed}\text{#D02090}$</td><td align="center">$\color{VioletRed}\text{rgb(208, 32, 144)}$</td><td align="center">$\colorbox{VioletRed}{\color{VioletRed}\texttt{#D02090}}$</td></tr><tr><td align="center">$\color{#020202}{Wheat}$</td><td align="center">$\color{Wheat}\text{#F5DEB3}$</td><td align="center">$\color{Wheat}\text{rgb(245, 222, 179)}$</td><td align="center">$\colorbox{Wheat}{\color{Wheat}\texttt{#F5DEB3}}$</td></tr><tr><td align="center">$\color{#020202}{White}$</td><td align="center">$\color{White}\text{#FFFFFF}$</td><td align="center">$\color{White}\text{rgb(255, 255, 255)}$</td><td align="center">$\colorbox{White}{\color{White}\texttt{#FFFFFF}}$</td></tr><tr><td align="center">$\color{#020202}{WhiteSmoke}$</td><td align="center">$\color{WhiteSmoke}\text{#F5F5F5}$</td><td align="center">$\color{WhiteSmoke}\text{rgb(245, 245, 245)}$</td><td align="center">$\colorbox{WhiteSmoke}{\color{WhiteSmoke}\texttt{#F5F5F5}}$</td></tr><tr><td align="center">$\color{#020202}{Yellow}$</td><td align="center">$\color{Yellow}\text{#FFFF00}$</td><td align="center">$\color{Yellow}\text{rgb(255, 255, 0)}$</td><td align="center">$\colorbox{Yellow}{\color{Yellow}\texttt{#FFFF00}}$</td></tr><tr><td align="center">$\color{#020202}{YellowGreen}$</td><td align="center">$\color{YellowGreen}\text{#9ACD32}$</td><td align="center">$\color{YellowGreen}\text{rgb(154, 205, 50)}$</td><td align="center">$\colorbox{YellowGreen}{\color{YellowGreen}\texttt{#9ACD32}}$</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> tools </tag>
            
            <tag> clolor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Groovy 基础语法</title>
      <link href="/2020/06/25/Language/Groovy/Syntax/"/>
      <url>/2020/06/25/Language/Groovy/Syntax/</url>
      
        <content type="html"><![CDATA[<h1 id="Groovy-基础语法"><a href="#Groovy-基础语法" class="headerlink" title="Groovy 基础语法"></a>Groovy 基础语法</h1><p>翻译自官方文档:<a href="http://www.groovy-lang.org/syntax.html" target="_blank" rel="noopener">Syntax</a><br>部分内容为了方便表述做了修改。</p><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h2><h3 id="1-1-单行注释"><a href="#1-1-单行注释" class="headerlink" title="1.1.单行注释"></a>1.1.单行注释</h3><p>单行注释以<code>//</code>开头，可以放在行中的任意位置。从<code>//</code>开始知道行尾的内容都算作是注释的部分。</p><pre><code class="Groovy">// 独立的单行注释println &quot;hello&quot; //直到行尾的注释</code></pre><h3 id="1-2-多行注释"><a href="#1-2-多行注释" class="headerlink" title="1.2.多行注释"></a>1.2.多行注释</h3><p>多行注释以<code>/*</code>开头，可以放在该行的任何位置。 <code>/*</code>后面的字符将被视为注释的一部分，包括换行符，直到第一个<code>*/</code>为止结束注释。 因此，多行注释可以放在语句的末尾，甚至可以放在语句的内部。</p><pre><code class="Groovy">/* 一个独立的多行注释    可以跨越两行*/println &quot;hello&quot; /* 一个多行注释                    从语句的结尾开始*/println 1 /* one */ + 2 /* two */</code></pre><h3 id="1-3-GroovyDoc注释"><a href="#1-3-GroovyDoc注释" class="headerlink" title="1.3.GroovyDoc注释"></a>1.3.GroovyDoc注释</h3><p>与多行注释类似，GroovyDoc注释也是多行注释，但以<code>/**</code>开头，以<code>*/</code>结尾。第一行之后的注释行可以选择以<code>*</code>开头，，这些注释与以下内容相关:<br>    - 类型定义（类，接口，枚举，注解）<br>    - 变量和属性定义<br>    - 方法定义</p><pre><code class="Groovy">/*** 类描述*/class Person{    /** 名称*/    String name    /**     * 创建一个greet方法     * @param otherPerson the person to greet     * @return a greeting message     */    String greet(String otherPerson){        &quot;Hello ${otherPerson}&quot;    }}</code></pre><p>Groovydoc遵循与Java的Javadoc相同的规约。因此，可以使用与Javadoc相同的标签。</p><p>另外，Groovy自3.0.0起就支持运行时Groovydoc，即GroovyDoc可以在运行时保留。默认情况下，GroovyDoc是禁用的，需要打开可以使用JVM选项设置<code>-Dgroovy.attach.runtime.groovydoc=true</code>来启用。</p><p>运行时GroovyDoc以<code>/**@</code>开头，以*/结尾，例如:</p><pre><code class="Groovy">/**@ * Foo类描述 */class Foo{    /**@     * bar方法描述     */    void bar(){        println &quot;Hello&quot;    }}println Foo.class.groovydoc.content.contains(&#39;Some class groovydoc for Foo&#39;) //获取类的运行时GroovyDocprintln Foo.class.getMethod(&#39;bar&#39;, new Class[0]).groovydoc.content.contains(&#39;Some method groovydoc for bar&#39;) // 获取方法的运行时GroovyDoc</code></pre><h3 id="1-4-Shebang-line"><a href="#1-4-Shebang-line" class="headerlink" title="1.4.Shebang line"></a>1.4.Shebang line</h3><p>除了单行注释，还有一个特殊行注释，通常在Unix系统下被称为<em>shebang</em>，它允许直接运行脚本只要已经安装了Groovy发行版并且在当前路径下可以使用Groovy命令。</p><pre><code class="Groovy">#!/usr/bin/env groovyprintln &quot;Hello from the shebang line&quot;</code></pre><p><code>#</code>字符必须是文件的第一个字符，并且任何缩进都可能导致编译的失败</p><h2 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2.关键字"></a>2.关键字</h2><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>as</td><td>assert</td><td>break</td><td>case</td></tr><tr><td>catch</td><td>class</td><td>const</td><td>continue</td></tr><tr><td>def</td><td>default</td><td>do</td><td>else</td></tr><tr><td>enum</td><td>extends</td><td>false</td><td>Finally</td></tr><tr><td>for</td><td>goto</td><td>if</td><td>implements</td></tr><tr><td>import</td><td>in</td><td>instanceof</td><td>interface</td></tr><tr><td>new</td><td>pull</td><td>package</td><td>return</td></tr><tr><td>super</td><td>switch</td><td>this</td><td>throw</td></tr><tr><td>throws</td><td>trait</td><td>true</td><td>try</td></tr><tr><td>while</td><td></td><td></td><td></td></tr></tbody></table><h2 id="3-标识符"><a href="#3-标识符" class="headerlink" title="3. 标识符"></a>3. 标识符</h2><h3 id="3-1-普通标识符"><a href="#3-1-普通标识符" class="headerlink" title="3.1.普通标识符"></a>3.1.普通标识符</h3><p>标识符以字母，<strong>$</strong>或者下划线开头，不能以数字开头。<br>字母的可用范围是:</p><ul><li><p>‘a’-‘z’(小写ASCII字母)</p></li><li><p>‘A’-‘Z’(大写ASCII字母)</p></li><li><p>‘\u00D8’ 到”\u00F6”</p></li><li><p>‘\u00F8’ 到”\u00FF”</p></li><li><p>‘\u0100’ 到”\uFFFE”</p></li></ul><p>后续的字符可以包含字母和数字</p><p>下面是几个有效标识符的示例（此处是变量名称）:</p><pre><code class="Groovy">def namedef item3def with_underscoredef $dollarStart</code></pre><p>以下是无效的标识符:</p><pre><code class="Groovy">def 3tierdef a+bdef a#b</code></pre><p>所有的关键字也可以是有效的标识符，只要在<code>.</code>之后:</p><pre><code class="Groovy">foo.asfoo.assertfoo.breakfoo.casefoo.catch</code></pre><h3 id="3-2-引用标识符"><a href="#3-2-引用标识符" class="headerlink" title="3.2.引用标识符"></a>3.2.引用标识符</h3><p>引用标识符在在<code>.</code>符号之后，例如<code>person.name</code>表达式的<strong>name</strong>部分可以用<code>person.&quot;name&quot;</code>或者<code>person.&#39;name&#39;</code>来引用。这就使得可能会出现某些标识符包含了Java规范中禁止的非法字符，但在Groovy中确实允许使用的。例如破折号，空格，感叹号等字符。</p><pre><code class="Groovy">def map = [:]map.&quot;an identifier with a space and double quotes&quot; = &quot;ALLOWED&quot;map.&#39;with-dash-signs-and-single-quotes&#39; = &quot;ALLOWED&quot;assert map.&quot;an identifier with a space and double quotes&quot; == &quot;ALLOWED&quot;assert map.&#39;with-dash-signs-and-single-quotes&#39; == &quot;ALLOWED&quot;println map.&quot;an identifier with a space and double quotes&quot;println map.&#39;with-dash-signs-and-single-quotes&#39;</code></pre><p>正如在后续的<a href="#Strings">字符串章节</a>看到的，Groovy提供了不同的字符串文本，所有类型的字符串都允许在<code>.</code>之后调用:</p><pre><code class="Groovy">map.&#39;single quote&#39;map.&quot;double quote&quot;map.&#39;&#39;&#39;triple single quote&#39;&#39;&#39;map.&quot;&quot;&quot;triple double quote&quot;&quot;&quot;map./slashy string/map.$/dollar slashy string/$</code></pre><p>纯字符字符串和Groovy的GStrings（内插字符串）是有区别的，因为在后者的情况下，内插值被插入得到最后的完整标识符。</p><pre><code class="Groovy">def firstname = &quot;Homer&quot;map.&quot;Simpson-${firstname}&quot; = &quot;Homer Simpson&quot;assert map.&#39;Simpson-Homer&#39; == &quot;Homer Simpson&quot;</code></pre><h2 id="4-Strings"><a href="#4-Strings" class="headerlink" title="4.Strings"></a>4.Strings<span id="Strings"></span></h2><p>字符串以字符链的形式表示。Groovy允许示例化<code>java.lang.String</code>对象，和GStrings(groovy.lang.GString),GStrings在其他变成语言中也被称为插值字符串。</p><h3 id="4-1-单引号字符串"><a href="#4-1-单引号字符串" class="headerlink" title="4.1.单引号字符串"></a>4.1.单引号字符串</h3><p>单引号字符串是一系列字符由单引号包裹:</p><pre><code class="Groovy">def s = &#39;a single-quoted string&#39;</code></pre><p>单引号字符串是普通的<code>java.lang.String</code>，不支持插值</p><h3 id="4-2-字符串连接"><a href="#4-2-字符串连接" class="headerlink" title="4.2.字符串连接"></a>4.2.字符串连接</h3><p>所有的Groovy字符串都可以用<code>+</code>操作符连接</p><pre><code class="Groovy">assert &#39;ab&#39; == &#39;a&#39; + &#39;b&#39;</code></pre><h3 id="4-3-三单引号字符串"><a href="#4-3-三单引号字符串" class="headerlink" title="4.3.三单引号字符串"></a>4.3.三单引号字符串</h3><p>三单引号字符串是一系列字符由三重单引号包裹:</p><pre><code class="Groovy">&#39;&#39;&#39;a triple-single-quoted string&#39;&#39;&#39;</code></pre><p>三单引号字符串是普通的<code>java.lang.String</code>，也不支持插值。</p><p>三单引号字符串可以跨越多行，字符串内容可以跨越行界而不需要把字符串分割成几段也不需要使用连接符或换行符</p><pre><code class="Groovy">def aMultilineString = &#39;&#39;&#39;line oneline twoline three&#39;&#39;&#39;</code></pre><p>如果你的代码是缩进的，例如在一个类的方法的主体中，你的字符串将包含缩进的空格。Groovy开发包中提供了<code>String#stripIndent()</code>方法和<code>String#stripMargin()</code>方法来剥离缩进的方法，该方法需要一个标识符来确定要从字符串的开头删除的文本。</p><p>当如下创建一个字符串时:</p><pre><code class="Groovy">def startingAndEndingWithANewline = &#39;&#39;&#39;line oneline twoline three&#39;&#39;&#39;println startingAndEndingWithANewline</code></pre><p>运行这段代码输出如下:</p><blockquote><p>(这里有一个空行)<br>line one<br>line two<br>line three</p></blockquote><p>可以发现生成的字符串包含一个换行符作为第一个字符，打印字符串的ASCII码如下:</p><blockquote><p>[10, 108, 105, 110, 101, 32, 111, 110, 101, 10, 108, 105, 110, 101, 32, 116, 119, 111, 10, 108, 105, 110, 101, 32, 116, 104, 114, 101, 101, 10]</p></blockquote><p>可以看到第一个字符是<strong>10</strong>，也就是换行符<br>使用反斜杠<code>\</code>转义可以去除该字符</p><pre><code class="Groovy">def strippedFirstNewline = &#39;&#39;&#39;\line oneline twoline three&#39;&#39;&#39;println strippedFirstNewlineassert !strippedFirstNewline.startsWith(&#39;\n&#39;)</code></pre><p>输出为:</p><blockquote><p>line one<br>line two<br>line three</p></blockquote><p>打印字符串ascii码为:</p><blockquote><p>[108, 105, 110, 101, 32, 111, 110, 101, 10, 108, 105, 110, 101, 32, 116, 119, 111, 10, 108, 105, 110, 101, 32, 116, 104, 114, 101, 101, 10]</p></blockquote><p>assert的结果通过</p><h4 id="4-3-1转义特殊字符"><a href="#4-3-1转义特殊字符" class="headerlink" title="4.3.1转义特殊字符"></a>4.3.1转义特殊字符</h4><p>你可以使用反斜杠<code>\</code>转义单个引号，以避免终止字符串文本:<br><code>&#39;an escaped single quote: \&#39; needs a backslash&#39;</code></p><p>使用双反斜杠<code>\\</code>来转义转义字符本身<br><code>&#39;an escaped escape character: \\ needs a double backslash&#39;</code></p><p>一些特殊字符还使用反斜杠作为转义字符:</p><table><thead><tr><th align="left">转义序列</th><th align="left">字符</th></tr></thead><tbody><tr><td align="left"><code>\b</code></td><td align="left">退格</td></tr><tr><td align="left"><code>\f</code></td><td align="left">进纸符</td></tr><tr><td align="left"><code>\n</code></td><td align="left">换行</td></tr><tr><td align="left"><code>\r</code></td><td align="left">回车</td></tr><tr><td align="left"><code>\s</code></td><td align="left">空格</td></tr><tr><td align="left"><code>\t</code></td><td align="left">制表</td></tr><tr><td align="left"><code>\\</code></td><td align="left">反斜杠</td></tr><tr><td align="left"><code>\&#39;</code></td><td align="left">单引号字符串中的单引号（三单引号和双引号字符串可选）</td></tr><tr><td align="left"><code>\&quot;</code></td><td align="left">双引号字符串中的双引号（三双引号和单引号字符串可选）</td></tr></tbody></table><p>这里在自己测试时在IDEA(2020.1.3), Groovy(3.0.4)环境下会出现编辑器报错的情况:<br><img src="/2020/06/25/Language/Groovy/Syntax/escape_s.png" alt="s"><br>但是能正常运行输出结果。</p><h4 id="4-3-2Unicode转义序列"><a href="#4-3-2Unicode转义序列" class="headerlink" title="4.3.2Unicode转义序列"></a>4.3.2Unicode转义序列</h4><p>对于不存在与键盘的字符，可以使用Unicode转义:反斜杠<code>\</code>，后面跟上<code>u</code>，然后是4个16进制数字。<br>例如，欧元货币符号可以使用以下方式表示:<br><code>&#39;The Euro currency symbol: \u20AC&#39;</code></p><h3 id="4-4双引号字符串"><a href="#4-4双引号字符串" class="headerlink" title="4.4双引号字符串"></a>4.4双引号字符串</h3><p>双引号字符串是一系列字符由双引号包裹:<br><code>&quot;a double-quoted string&quot;</code></p><p>如果没有插值表达式，双引号字符串即为普通<code>java.lang.String</code>，如果存在插值则为<code>groovy.lang.GString</code>实例<br>如果要转义双引号，可以使用反斜杠字符:<code>&quot;A double quote:\&quot;&quot;</code></p><h4 id="4-4-1字符串插值"><a href="#4-4-1字符串插值" class="headerlink" title="4.4.1字符串插值"></a>4.4.1字符串插值</h4><p>除了单引号和三引号字符串外，任何Groovy表达式都可以在所有字符串字面值之中进行插值。插值是指在字符串求值时用真实值替换字符串中占位符的行为。<br>占位符表达式由<code>${}</code>包裹。对于点式调用，可以省略大括号只是用<code>$</code>符。如果一个<strong>GString</strong>被传递给一个接收字符串的方法，那么占位符中的表达式将被计算为字符串表达式（通过调用该表达式的<code>toString()</code>方法），并将最终字符串传递给该方法。</p><p>def name = ‘’</p><pre><code class="Groovy">def name = &#39;Guillaume&#39; // 一个显示的字符串def greeting = &quot;Hello ${name}&quot;assert greeting.toString() == &#39;Hello Guillaume&#39;//使用算术表达式def sum = &quot;The sum of 2 and 3 equals ${2 + 3}&quot;assert sum.toString() == &#39;The sum of 2 and 3 equals 5&#39;//在点式调用前使用$def person = [name: &#39;Guillaume&#39;, age: 36]assert &quot;$person.name is $person.age years old&quot; == &#39;Guillaume is 36 years old&#39;</code></pre><p><code>${}</code>之间允许使用表达式也允许使用语句。但是一个语句的值是<code>null</code>的，因此，如果在占位符中插入了几个语句的话，最后一个语句应该要以某种方式返回要插入的有意义的值。例如:<br><code>&quot;The sum of 1 and 2 is equal to ${def a = 1; def b = 2; a + b}&quot;</code><br>也是允许的，并且可以按照预期返回值。<br>不过更好的做法是在占位符中插入一个更简单的表达式。</p><p>要注意的是只有<code>a.b</code>，<code>a.b.c</code>等形式的点式表达式才有效，包含括号之类的表达式是无效的，例如方法调用，用于闭包的大括号，不属于属性表达式或算数表达式的点式调用。</p><pre><code class="Groovy">def number = 3.14println &quot;$number.toString()&quot;</code></pre><p>上面的例子将会引发一个<code>groovy.lang.MissingPropertyException</code>异常，因为Groovy认为你正在尝试访问该数字的一个不存在的<code>toString</code>属性。<br>你可以把插值中的<code>$number.toString()</code>看作是<code>${number.toString}()</code>。<br>相似的，如果一个表达式的含义是模糊的，就需要用大括号包裹:</p><pre><code class="Groovy">String thing = &#39;treasure&#39;assert &#39;The x-coordinate of the treasure is represented by treasure.x&#39; ==        &quot;The x-coordinate of the $thing is represented by $thing.x&quot;   // &lt;= Not allowed: ambiguous!!assert &#39;The x-coordinate of the treasure is represented by treasure.x&#39; ==        &quot;The x-coordinate of the $thing is represented by ${thing}.x&quot;  // &lt;= Curly braces required</code></pre><p>如果需要转义一个GString对象中的<code>$</code>或<code>${}</code>符号，只需要使用反斜杠<code>\</code>完成转义。</p><pre><code class="Groovy">assert &#39;$5&#39; == &quot;\$5&quot;assert &#39;${name}&#39; == &quot;\${name}&quot;</code></pre><h4 id="4-4-2插值闭合表达式的特殊情况"><a href="#4-4-2插值闭合表达式的特殊情况" class="headerlink" title="4.4.2插值闭合表达式的特殊情况"></a>4.4.2插值闭合表达式的特殊情况</h4><p>目前为止，可以看到占位符中可以插入任意表达式，但是闭包表达式有一个特殊情况和表示法。当占位符中包含一个箭头，<code>${-&gt;}</code>，这个表达式实际上是一个闭包表达式，你可以将其视为一个闭包，并在其前面加上一个<code>$</code>。</p><pre><code class="Groovy">def sParameterLessClosure = &quot;1 + 2 == ${-&gt; 3}&quot; //无参闭包assert sParameterLessClosure == &#39;1 + 2 == 3&#39;def sOneParamClosure = &quot;1 + 2 == ${ w -&gt; w &lt;&lt; 3}&quot; //传递了一个 java.io.StringWriter类型参数，并用&lt;&lt;方式添加内容assert sOneParamClosure == &#39;1 + 2 == 3&#39;//以上两种方式都是嵌入式闭包</code></pre><p>正如上面所看到的，这好像是更啰嗦的方式去定义一个表达式，但闭包比单纯的表达式有一个优势:惰性求值<br>让我们考虑以下的示例:</p><pre><code class="Groovy">def number = 1 //我们定义一个包含1的数字变量，然后在两个GString中插值，作为eagerGString中的表达式和lazyGString中的闭包。def eagerGString = &quot;value == ${number}&quot;def lazyGString = &quot;value == ${ -&gt; number }&quot;assert eagerGString == &quot;value == 1&quot;assert lazyGString ==  &quot;value == 1&quot;//eagerGString和lazyGString中都得到了期望的值number = 2 //然后修改number的值assert eagerGString == &quot;value == 1&quot; //使用普通的内插表达式，该值实际上是在创建GString时绑定的。assert lazyGString ==  &quot;value == 2&quot; //但是使用闭包表达式时，每次将GString强制转换为String时都会调用闭包，从而生成包含新数字值的新字符串。</code></pre><p>另外要注意的是有多个参数的闭包会在运行时抛出异常。插值只允许零个或一个参数的闭包。</p><h4 id="4-4-3与JAVA的互操作性"><a href="#4-4-3与JAVA的互操作性" class="headerlink" title="4.4.3与JAVA的互操作性"></a>4.4.3与JAVA的互操作性</h4><p>当一个方法（无论是否实现了JAVA或者Groovy）需要一个<code>java.lang.String</code>对象是，但是传递了一个<code>groovy.lang.GString</code>对象，那么GString的<code>toString()</code>方法会被自动隐式地调用。</p><pre><code class="Groovy">String takeString(String message) { //方法签名明确表示其唯一参数是字符串    assert message instanceof String //并验证字符串类型为java.lang.String    return message}def message = &quot;The message is ${&#39;hello&#39;}&quot; //创建一个字符串，类型为groovy.lang.GStringassert message instanceof GString         //验证字符串类型为groovy.lang.GStringdef result = takeString(message)          //将GString传递给takeString方法assert result instanceof Stringassert result == &#39;The message is hello&#39;</code></pre><p>代码运行通过，可见groovy确实会自动地把GString转换为String。</p><h4 id="4-4-4-GString和String的哈希值"><a href="#4-4-4-GString和String的哈希值" class="headerlink" title="4.4.4.GString和String的哈希值"></a>4.4.4.GString和String的哈希值</h4><p>尽管插值字符串可以替代普通的Java字符串，但是他们与字符串在哈希代码上是不同的。Java字符串是不可改变的，而GString的结果会因为内插值的不同而变化。其实是相同的字符串，GString和String的哈希值也可能不同。</p><pre><code class="Groovy">assert &quot;one: ${1}&quot;.hashCode() != &quot;one: 1&quot;.hashCode()</code></pre><p>GString和String具有不同的哈希值，因此应该避免使用GString作为Map的key值，特别是尝试用Stirng而不是GString来检索关键值时。</p><pre><code class="Groovy">def key = &quot;a&quot;def m = [&quot;${key}&quot;: &quot;letter ${key}&quot;] //这里的Map用GString作为keyassert m[&quot;a&quot;] == null  //当以普通的String作为key获取对应的value值时，由于GString和String有不用的哈希值，导致找不到对应的value</code></pre><h3 id="4-5-三双引号字符串"><a href="#4-5-三双引号字符串" class="headerlink" title="4.5.三双引号字符串"></a>4.5.三双引号字符串</h3><p>三双引号字符串和双引号字符串相似，只是他们是多行的。</p><pre><code class="Groovy">def name = &#39;Groovy&#39;def template = &quot;&quot;&quot;    Dear Mr ${name},    You&#39;re the winner of the lottery!    Yours sincerly,    Dave&quot;&quot;&quot;</code></pre><p>无论是双引号还是单引号都不需要在三双引号字符串中转义。</p><h3 id="4-6-斜杠字符串"><a href="#4-6-斜杠字符串" class="headerlink" title="4.6.斜杠字符串"></a>4.6.斜杠字符串</h3><p>除了普通的引号字符串外，Groovy还提供了斜杠字符串。斜杠字符串使用<code>/</code>作为字符串的开头和结束标记。斜杠字符串对于定义正则表达式和Patterns是有利工具，而且也不需要转义反斜杠<code>\</code>。<br>斜杠字符串的示例如下:</p><pre><code class="Groovy">def fooPattern = /.*foo.*/assert fooPattern == &#39;.*foo.*&#39;</code></pre><p>只有斜杠<code>/</code>本身需要被反斜杠<code>\</code>转义，因为斜杠字符串是以斜杠为开始和结束的标记的。</p><pre><code class="Groovy">def escapeSlash = /The character \/ is a forward slash/assert escapeSlash == &#39;The character / is a forward slash&#39;</code></pre><p>斜杠字符串也可以是多行的:</p><pre><code class="Groovy">def multilineSlashy = /one    two    three/assert multilineSlashy.contains(&#39;\n&#39;)</code></pre><p>另外斜杠字符串可以看作是GString的另一种形式，所以也是可以被插值的，只是他们的转移规则不同。</p><pre><code class="Groovy">def color = &#39;blue&#39;def interpolatedSlashy = /a ${color} car/assert interpolatedSlashy == &#39;a blue car&#39;</code></pre><h4 id="4-6-1特殊情况"><a href="#4-6-1特殊情况" class="headerlink" title="4.6.1特殊情况"></a>4.6.1特殊情况</h4><p>一个空的斜杠字符串不允许以两个斜杠(<code>//</code>)的形式出现，因为这会被Groovy解析为行注释。所以下面这个断言语句不会被编译，因为它看起来是一个未结束的语句。</p><pre><code class="Groovy">assert &#39;&#39; == //</code></pre><p>由于斜杠字符串主要是为了简化正则表达式使用而设计，所以在GString中不允许的错误写法例如<code>$()</code>或<code>$5</code>可以在斜杠字符串中使用。</p><p>要记住，在斜杠字符串中使不需要转义反斜杠的。换个思路是实际上不支持转义。一个斜杠字符串<code>/\t/</code>实际上不会包含一个制表符，而是<code>\t</code>字面值。转义只对斜杠<code>/</code>本身有效。例如:<code>/\/folder/</code>会被处理成<code>/folder</code>。斜杠字符串的转义结果不能使斜杠字符串以反斜杠结尾。否则，将转义斜杠字符串的结束符。可以使用一个替代方案:<code>/ends with slash ${&#39;\&#39;}/</code>，但是最好的还是避免在这种情况下使用斜杠字符串。</p><blockquote><p>这一段有点绕，反正意思就是使用斜杠字符串时，最后一个字符不要是反斜杠。</p></blockquote><h3 id="4-7-Dollar斜杠字符串"><a href="#4-7-Dollar斜杠字符串" class="headerlink" title="4.7.Dollar斜杠字符串"></a>4.7.Dollar斜杠字符串</h3><p>Dollar斜杠字符串是一个多行的GString，以<code>$/</code>开头，以<code>/$</code>结尾。转义字符是<code>$</code>，它可以转义另一个<code>$</code>符号，或者斜杠<code>/</code>。但是Dollar斜杠字符串并不需要转义<code>$</code>或者<code>/</code>。除非是GString占位符子序列开头中的<code>$</code>或者是Dollar斜杠字符串的结束符<code>/$</code>。</p><pre><code class="Groovy">def name = &quot;Guillaume&quot;def date = &quot;April, 1st&quot;def dollarSlashy = $/    Hello $name,    today we&#39;re ${date}.    $ dollar sign    $$ escaped dollar sign    \ backslash    / forward slash    $/ escaped forward slash    $$$/ escaped opening dollar slashy    $/$$ escaped closing dollar slashy/$assert [        &#39;Guillaume&#39;,        &#39;April, 1st&#39;,        &#39;$ dollar sign&#39;,        &#39;$ escaped dollar sign&#39;,        &#39;\\ backslash&#39;,        &#39;/ forward slash&#39;,        &#39;/ escaped forward slash&#39;,        &#39;$/ escaped opening dollar slashy&#39;,        &#39;/$ escaped closing dollar slashy&#39;].every { dollarSlashy.contains(it) }println dollarSlashy</code></pre><p>Dollar斜杠字符串是为了克服斜杆字符串的转移规则而产生的，当你的字符串内容适合Dollar斜杠字符串转义规则时才使用Dollar斜杠字符串。例如:有一些不想要转义的斜杠时。</p><h3 id="4-8-字符串小结表"><a href="#4-8-字符串小结表" class="headerlink" title="4.8.字符串小结表"></a>4.8.字符串小结表</h3><table><thead><tr><th align="center">String name</th><th align="center">String syntax</th><th align="center">Interpolated</th><th align="center">Multiline</th><th align="center">Escape character</th></tr></thead><tbody><tr><td align="center">Single-quoted</td><td align="center"><code>&#39;…&#39;</code></td><td align="center"></td><td align="center"></td><td align="center"><code>\</code></td></tr><tr><td align="center">Triple-single-quoted</td><td align="center"><code>&#39;&#39;&#39;…&#39;&#39;&#39;</code></td><td align="center"></td><td align="center">✔</td><td align="center"><code>\</code></td></tr><tr><td align="center">Double-quoted</td><td align="center"><code>&quot;…&quot;</code></td><td align="center">✔</td><td align="center"></td><td align="center"><code>\</code></td></tr><tr><td align="center">Triple-double-quoted</td><td align="center"><code>&quot;&quot;&quot;…&quot;&quot;&quot;</code></td><td align="center">✔</td><td align="center">✔</td><td align="center"><code>\</code></td></tr><tr><td align="center">Slashy</td><td align="center"><code>/…/</code></td><td align="center">✔</td><td align="center">✔</td><td align="center"><code>\</code></td></tr><tr><td align="center">Dollar slashy</td><td align="center"><code>$/…/$</code></td><td align="center">✔</td><td align="center">✔</td><td align="center"><code>$</code></td></tr></tbody></table><h3 id="4-9-字符"><a href="#4-9-字符" class="headerlink" title="4.9.字符"></a>4.9.字符</h3><p>与Java不同，Groovy没有明确的字符文字，但是有三种方式明确地把Groovy字符变成变成一个实际的字符。</p><pre><code class="Groovy">char c1 = &#39;A&#39; //通过显式声明char类型assert c1 instanceof Characterdef c2 = &#39;B&#39; as char //通过as运算符类型转换assert c2 instanceof Characterdef c3 = (char)&#39;C&#39; //通过强制类型转换assert c3 instanceof Character</code></pre><h2 id="5-Numbers"><a href="#5-Numbers" class="headerlink" title="5.Numbers"></a>5.Numbers</h2><p>Groovy支持多种类型的整型数字和十进制文本，支持Java的常用数字类型。</p><h3 id="5-1-整型"><a href="#5-1-整型" class="headerlink" title="5.1.整型"></a>5.1.整型</h3><p>整型和Java中相同</p><ul><li><p><code>byte</code></p></li><li><p><code>char</code></p></li><li><p><code>short</code></p></li><li><p><code>int</code></p></li><li><p><code>long</code></p></li><li><p><code>java.lang.BigInteger</code></p></li></ul><p>可以用以下的方式创建上述的整型:</p><pre><code class="Groovy">// 基本数据类型byte  b = 1char  c = 2short s = 3int   i = 4long  l = 5// infinite precisionBigInteger bi =  6</code></pre><p>如果使用<code>def</code>关键字声明变量，那么这些数字会自动选择可以容纳的类型</p><p>对于正数:</p><pre><code class="Groovy">def a = 1assert a instanceof Integer// Integer.MAX_VALUEdef b = 2147483647assert b instanceof Integer// Integer.MAX_VALUE + 1def c = 2147483648assert c instanceof Long// Long.MAX_VALUEdef d = 9223372036854775807assert d instanceof Long// Long.MAX_VALUE + 1def e = 9223372036854775808assert e instanceof BigInteger</code></pre><p>负数也一样:</p><pre><code class="Groovy">def na = -1assert na instanceof Integer// Integer.MIN_VALUEdef nb = -2147483648assert nb instanceof Integer// Integer.MIN_VALUE - 1def nc = -2147483649assert nc instanceof Long// Long.MIN_VALUEdef nd = -9223372036854775808assert nd instanceof Long// Long.MIN_VALUE - 1def ne = -9223372036854775809assert ne instanceof BigInteger</code></pre><h4 id="5-1-1-非10进制表示"><a href="#5-1-1-非10进制表示" class="headerlink" title="5.1.1.非10进制表示"></a>5.1.1.非10进制表示</h4><p>数字也可以用二进制，八进制，十六进制和十进制表示。</p><p>$\color{orange}{二进制文本}$</p><p>二进制数字以<code>0b</code>前缀开头:</p><pre><code class="Groovy">int xInt = 0b10101111assert xInt == 175short xShort = 0b11001001assert xShort == 201 as shortbyte xByte = 0b11assert xByte == 3 as bytelong xLong = 0b101101101101assert xLong == 2925lBigInteger xBigInteger = 0b111100100001assert xBigInteger == 3873gint xNegativeInt = -0b10101111assert xNegativeInt == -175</code></pre><p>$\color{orange}{八进制文本}$</p><p>八进制数字以<code>0</code>开头:</p><pre><code class="Groovy">int xInt = 077assert xInt == 63short xShort = 011assert xShort == 9 as shortbyte xByte = 032assert xByte == 26 as bytelong xLong = 0246assert xLong == 166lBigInteger xBigInteger = 01111assert xBigInteger == 585gint xNegativeInt = -077assert xNegativeInt == -63</code></pre><p>$\color{orange}{十六进制文本}$</p><p>十六进制文本以<code>0x</code>开头:</p><pre><code class="Groovy">int xInt = 0x77assert xInt == 119short xShort = 0xaaassert xShort == 170 as shortbyte xByte = 0x3aassert xByte == 58 as bytelong xLong = 0xffffassert xLong == 65535lBigInteger xBigInteger = 0xaaaaassert xBigInteger == 43690gDouble xDouble = new Double(&#39;0x1.0p0&#39;)assert xDouble == 1.0dint xNegativeInt = -0x77assert xNegativeInt == -119</code></pre><h3 id="5-2-十进制文本"><a href="#5-2-十进制文本" class="headerlink" title="5.2.十进制文本"></a>5.2.十进制文本</h3><p>十进制文本类型和Java中的类型相同:</p><ul><li><p><code>float</code></p></li><li><p><code>double</code></p></li><li><p><code>java.lang.BigDecimal</code></p></li></ul><p>可以使用以下声明创建这些类型的十进制数:</p><pre><code class="Groovy">// primitive typesfloat  f = 1.234double d = 2.345// infinite precisionBigDecimal bd =  3.456</code></pre><p>十进制可以使用指数<code>e</code>与指数字母<code>E</code>，后跟一个可选符号(<code>+</code>,<code>-</code>)，以及一个表示指数的值:</p><pre><code class="Groovy">assert 1e3  ==  1000.0assert 2E4  ==  20000.0assert 3e+1 ==  30.0assert 4E-2 ==  0.04assert 5e-1 ==  0.5</code></pre><p>对于十进制的浮点数，Groovy选择<code>java.lang.BigDecimal</code>作为十进制浮点数默认类型。此外，支持<code>float</code>和<code>double</code>，但需要显式的类型声明，类型强转或后缀。尽管<code>java.lang.BigDecimal</code>是默认的十进制数字的类型，但是同样支持方法或闭包接收一个<code>float</code>或<code>double</code>类型的值作为参数。</p><p>例如:</p><pre><code class="Groovy">def plusOne(BigDecimal decimal){    println decimal+1}plusOne(1.0F)</code></pre><h3 id="5-3-下划线数字"><a href="#5-3-下划线数字" class="headerlink" title="5.3.下划线数字"></a>5.3.下划线数字</h3><p>当有些数字字面长度较长时，可以在文本中使用下划线对数字分组，可以方便方便识别数字:</p><pre><code class="Groovy">long creditCardNumber = 1234_5678_9012_3456Llong socialSecurityNumbers = 999_99_9999Ldouble monetaryAmount = 12_345_132.12long hexBytes = 0xFF_EC_DE_5Elong hexWords = 0xFFEC_DE5Elong maxLong = 0x7fff_ffff_ffff_ffffLlong alsoMaxLong = 9_223_372_036_854_775_807Llong bytes = 0b11010010_01101001_10010100_10010010</code></pre><h3 id="5-4-数字类型后缀"><a href="#5-4-数字类型后缀" class="headerlink" title="5.4.数字类型后缀"></a>5.4.数字类型后缀</h3><table><thead><tr><th align="left">类型</th><th align="left">后缀</th></tr></thead><tbody><tr><td align="left">BigInteger</td><td align="left"><code>G</code> or <code>g</code></td></tr><tr><td align="left">Long</td><td align="left"><code>L</code> or <code>l</code></td></tr><tr><td align="left">Integer</td><td align="left"><code>I</code> or <code>i</code></td></tr><tr><td align="left">BigDecimal</td><td align="left"><code>G</code> or <code>g</code></td></tr><tr><td align="left">Double</td><td align="left"><code>D</code> or <code>d</code></td></tr><tr><td align="left">Float</td><td align="left"><code>F</code> or <code>f</code></td></tr></tbody></table><p>例如:</p><pre><code class="Groovy">assert 42I == new Integer(&#39;42&#39;)assert 42i == new Integer(&#39;42&#39;) // lowercase i more readableassert 123L == new Long(&quot;123&quot;) // uppercase L more readableassert 2147483648 == new Long(&#39;2147483648&#39;) // Long type used, value too large for an Integerassert 456G == new BigInteger(&#39;456&#39;)assert 456g == new BigInteger(&#39;456&#39;)assert 123.45 == new BigDecimal(&#39;123.45&#39;) // default BigDecimal type usedassert 1.200065D == new Double(&#39;1.200065&#39;)assert 1.234F == new Float(&#39;1.234&#39;)assert 1.23E23D == new Double(&#39;1.23E23&#39;)assert 0b1111L.class == Long // binaryassert 0xFFi.class == Integer // hexadecimalassert 034G.class == BigInteger // octal</code></pre><h3 id="5-5-数学运算"><a href="#5-5-数学运算" class="headerlink" title="5.5.数学运算"></a>5.5.数学运算</h3><p>尽管操作符后续才讲到，但先讨论数学运算的结果也很重要。<br>除法和幂二元运算除外。</p><ul><li><p><code>byte</code>,<code>char</code>,<code>short</code>和,<code>int</code>之间的二元计算结果为<code>int</code></p></li><li><p><code>long</code>和 <code>byte</code>,<code>char</code>,<code>short</code>,<code>int</code>之间的二元计算结果为<code>long</code></p></li><li><p><code>BigInteger</code>和任何其他整数类型的二元计算结果都为<code>BigInteger</code></p></li><li><p><code>BigDecimal</code>和<code>byte</code>,<code>char</code>,<code>short</code>,<code>int</code>,<code>BigInteger</code>的二元运算结果都为<code>BigDecimal</code></p></li><li><p><code>float</code>,<code>double</code>,<code>BigDecimal</code>之间的二元运算结果都是<code>double</code></p></li><li><p><code>BigDecimal</code>和<code>BigDecimal</code>之间的运算结果事<code>BigDecimal</code></p></li></ul><p>下面这个表格总结了规律:</p><table><thead><tr><th align="left"></th><th align="left">byte</th><th align="left">char</th><th align="left">short</th><th align="left">int</th><th align="left">long</th><th align="left">BigInteger</th><th align="left">float</th><th align="left">double</th><th align="left">BigDecimal</th></tr></thead><tbody><tr><td align="left"><strong>byte</strong></td><td align="left">int</td><td align="left">int</td><td align="left">int</td><td align="left">int</td><td align="left">long</td><td align="left">BigInteger</td><td align="left">double</td><td align="left">double</td><td align="left">BigDecimal</td></tr><tr><td align="left"><strong>char</strong></td><td align="left"></td><td align="left">int</td><td align="left">int</td><td align="left">int</td><td align="left">long</td><td align="left">BigInteger</td><td align="left">double</td><td align="left">double</td><td align="left">BigDecimal</td></tr><tr><td align="left"><strong>short</strong></td><td align="left"></td><td align="left"></td><td align="left">int</td><td align="left">int</td><td align="left">long</td><td align="left">BigInteger</td><td align="left">double</td><td align="left">double</td><td align="left">BigDecimal</td></tr><tr><td align="left"><strong>int</strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">int</td><td align="left">long</td><td align="left">BigInteger</td><td align="left">double</td><td align="left">double</td><td align="left">BigDecimal</td></tr><tr><td align="left"><strong>long</strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">long</td><td align="left">BigInteger</td><td align="left">double</td><td align="left">double</td><td align="left">BigDecimal</td></tr><tr><td align="left"><strong>BigInteger</strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">BigInteger</td><td align="left">double</td><td align="left">double</td><td align="left">BigDecimal</td></tr><tr><td align="left"><strong>float</strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">double</td><td align="left">double</td><td align="left">double</td></tr><tr><td align="left"><strong>double</strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">double</td><td align="left">double</td></tr><tr><td align="left"><strong>BigDecimal</strong></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">BigDecimal</td></tr></tbody></table><p>得益于Groovy的操作符重载，普通的算术运算符也可以和<code>BigInteger</code>,<code>BigDecimal</code>一起使用给，不同于在Java中必须使用特定的方法进行运算。</p><h4 id="5-5-1-除法运算符"><a href="#5-5-1-除法运算符" class="headerlink" title="5.5.1.除法运算符"></a>5.5.1.除法运算符</h4><p>如果两个运算数中任意一个为浮点数或双精度数，则除法运算符<code>/</code>或<code>/=</code>的结果将是一个double结果，否则将得到<code>BigDecimal</code>(两个运算数都是整型的<code>short</code>, <code>char</code>, <code>byte</code>, <code>int</code>, <code>long</code>, <code>BigInteger</code> 或 <code>BigDecimal</code>)。</p><p>如果是带精度的除法(即产生的可以相同高精度和小数位数范围内表示的结果)，则使用<code>divide()</code>方法执行<code>BigDecimal</code>的除法，或者使用精度为两个操作数的最大精度加上额外精度10的<code>MathContext</code>。<br>对于整数除法和Java相同，应该使用intdiv()方法，因为Groovy没有提供一个整数操作符。<br>(这一段不是很明白)</p><h4 id="5-5-2-幂运算符"><a href="#5-5-2-幂运算符" class="headerlink" title="5.5.2.幂运算符"></a>5.5.2.幂运算符</h4><p>幂运算操作符使用**操作符，有两个参数:基数和指数。幂运算的结果取决于它的操作数以及操作的结果（特别是结果可以被表示为一个整数值）。</p><p>以下这些原则被用于决定Groovy幂运算操作结果的类型:</p><ul><li><p>如果指数是十进制</p><ul><li><p>如果结果可以表示为一个<code>Integer</code>，则返回<code>Integer</code></p></li><li><p>如果结果可以表示为一个<code>Long</code>，则返回<code>Long</code></p></li><li><p>否则返回一个<code>Double</code></p></li></ul></li><li><p>如果指数是一个整数值</p><ul><li><p>如果指数是一个负数，则返回一个<code>Integer</code>，<code>Long</code>, <code>Double</code>如果结果得值匹配这些类型的话</p></li><li><p>如果指数是一个整数或0</p><ul><li><p>如果底数是<code>BigDecimal</code>，则返回一个<code>BigDecimal</code>结果</p></li><li><p>如果底数是<code>BigInteger</code>，则返回一个<code>BigInteger</code>结果</p></li><li><p>如果底数是<code>Integer</code>，则返回一个<code>Integer</code>如果结果匹配该类型，否则返回一个<code>BigInteger</code></p></li><li><p>如果底数是<code>Long</code>，则返回一个<code>Long</code>如果结果匹配该类型，否则返回一个<code>BigInteger</code></p></li></ul></li></ul></li></ul><p>我们可以通过一些示例来说明这些规则:</p><pre><code class="Groovy">// 底数和指数都是整型，结果可以被Integer容纳assert    2    **   3    instanceof Integer    //  8assert   10    **   9    instanceof Integer    //  1_000_000_000// 底数是一个Long, 结果也也是一个Long// 虽然这个结果integer就可以容纳assert    5L   **   2    instanceof Long       //  25// 结果不能被Integer或Long容纳，因此返回了BigIntegerassert  100    **  10    instanceof BigInteger //  10e20assert 1234    ** 123    instanceof BigInteger //  170515806212727042875...// 底数是BigDecimal并且指数是负整型，结果可以容纳在Integer中assert    0.5  **  -2    instanceof Integer    //  4// 底数是int并且指数是负的浮点数，结果可以容纳在Integer中assert    1    **  -0.3f instanceof Integer    //  1// 底数是int，指数是负的int// 但是结果将被计算为Double// (底数和指数都将被转换为double)assert   10    **  -1    instanceof Double     //  0.1// 底数是BigDecimal，指数是int，所以结果是BigDecimalassert    1.2  **  10    instanceof BigDecimal //  6.1917364224// 底数是float或double指数是int// 结果可以容纳在Double中assert    3.4f **   5    instanceof Double     //  454.35430372146965assert    5.6d **   2    instanceof Double     //  31.359999999999996// 指数是一个浮点数// 结果可以被容纳在Double中assert    7.8  **   1.9  instanceof Double     //  49.542708423868476assert    2    **   0.1f instanceof Double     //  1.0717734636432956</code></pre><h2 id="6-Booleans"><a href="#6-Booleans" class="headerlink" title="6.Booleans"></a>6.Booleans</h2><p>Boolean是一种用于表示真值（<code>true</code>和<code>false</code>）的特殊的数据类型。使用这个数据类型用于标记真假条件。</p><p>Boolean可以保存在变量中，并分配给字段，就像其他任意数据类型。</p><pre><code class="Groovy">def myBooleanVariable = trueboolean untypedBooleanVar = falsebooleanField = true</code></pre><p><code>true</code>和<code>false</code>是仅有的两个原始boolean值。但是使用逻辑运算符可以表示更复杂的Boolean表达式。</p><p>另外，Groovy具有特殊的规则，通常被称为<em>Groovy Truth</em>，用于将非Boolean值强制转为Boolean值。</p><h2 id="7-列表"><a href="#7-列表" class="headerlink" title="7.列表"></a>7.列表</h2><p>Groovy使用一个用方括号包裹的以逗号为分隔的值作为列表。Groovy列表是JDK的<code>java.util.List</code>，因为Groovy没有定义一个自己的集合类。在定义列表是默认的实现是<code>java.util.ArrayList</code>，除非另行指定，正如后面将会看到。</p><pre><code class="Groovy">def numbers = [1, 2, 3] // 定义一个数字列表，以逗号分隔包裹在方括号中，赋值给变量assert numbers instanceof List // 这个列表是Java的`java.util.list`的接口assert numbers.size() == 3 // 列表的大小可以调用`size()`方法得到</code></pre><p>上面的例子中，我们定义了一个同类元素的列表，但是同样也可以创建一个非同类元素的列表:</p><pre><code class="Groovy">def heterogeneous = [1, &quot;a&quot;, true] // 列表包含了一个数字，一个字符串以及一个Boolean值</code></pre><p>上面提到过在默认情况下列表实际上是<code>java.util.ArrayList</code>的实例，但是如果使用<code>as</code>关键字类型强转或使用显式的类型声明，列表也可以是其他的备选类型。</p><pre><code class="Groovy">def arrayList = [1, 2, 3]assert arrayList instanceof java.util.ArrayListdef linkedList = [2, 3, 4] as LinkedList // 使用as显式地转化为java.util.LinkedList实现assert linkedList instanceof java.util.LinkedListLinkedList otherLinked = [3, 4, 5] // 也可以显式地声明列表的类型是java.util.LinkedListassert otherLinked instanceof java.util.LinkedList</code></pre><p>你可以访问列表的元素使用<code>[]</code>下标运算符（可用于取值和赋值），和正数索引或负数索引（从列表的末尾开始访问）。使用range也是一样。并且可以使用<code>&lt;&lt;</code>运算符追加元素到列表:</p><pre><code class="Groovy">def letters = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]assert letters[0] == &#39;a&#39; // 访问列表的第一个元素，起始索引为0assert letters[1] == &#39;b&#39;assert letters[-1] == &#39;d&#39; // 用-1索引访问列表的最后一个元素，-1表示从列表的末尾开始第一个元素assert letters[-2] == &#39;c&#39;letters[2] = &#39;C&#39; // 给列表的第三个元素赋新值assert letters[2] == &#39;C&#39;letters &lt;&lt; &#39;e&#39; // 使用&lt;&lt;符号追加一个元素到列表的末尾assert letters[ 4] == &#39;e&#39;assert letters[-1] == &#39;e&#39;assert letters[1, 3] == [&#39;b&#39;, &#39;d&#39;] // 一次性访问两个元素，返回一个新的列表包含这两个元素assert letters[2..4] == [&#39;C&#39;, &#39;d&#39;, &#39;e&#39;] // 使用一个range访问范围内的值，从范围的开始到结束</code></pre><p>由于列表本质上是异构的，所以列表同样可以包含其他列表以创建一个多维列表</p><pre><code class="Groovy">def multi = [[0, 1], [2, 3]] // 定义一个二维数字列表assert multi[1][0] == 2 // 访问外部列表的第二项中的第一项的值</code></pre><h2 id="8-数组"><a href="#8-数组" class="headerlink" title="8.数组"></a>8.数组</h2><p>Groovy复用了列表的表示法用来表示数组，但是需要显式地声明数组类型或强转为数组类型。</p><pre><code class="Groovy">String[] arrStr = [&#39;Ananas&#39;, &#39;Banana&#39;, &#39;Kiwi&#39;] // 显式地定义一个字符串数组assert arrStr instanceof String[] //断言确实创建了一个字符串数组assert !(arrStr instanceof List)def numArr = [1, 2, 3] as int[] // 用as操作符创建了一个int数组assert numArr instanceof int[]assert numArr.size() == 3</code></pre><p>同样可以创建多维数组:</p><pre><code class="Groovy">def matrix3 = new Integer[3][3] // 可以定义数组的大小assert matrix3.size() == 3Integer[][] matrix2 //或者定义一个不指定大小的数组matrix2 = [[1, 2], [3, 4]]assert matrix2 instanceof Integer[][]</code></pre><p>访问数组的元素使用和列表相同的符号:</p><pre><code class="Groovy">String[] names = [&#39;Cédric&#39;, &#39;Guillaume&#39;, &#39;Jochen&#39;, &#39;Paul&#39;]assert names[0] == &#39;Cédric&#39; // 访问数组的第一个元素names[2] = &#39;Blackdrag&#39;assert names[2] == &#39;Blackdrag&#39; // 为数组的第三个元素重新赋值</code></pre><p>Groovy不支持Java的数组初始化符号，因为可能和Groovy的闭包大括号混淆。</p><h3 id="8-1Java风格的数组初始化"><a href="#8-1Java风格的数组初始化" class="headerlink" title="8.1Java风格的数组初始化"></a>8.1Java风格的数组初始化</h3><p>Groovy始终支持使用方括号定义数组或里列表，并避免使用Java风格的大括号定义数组，以避免和闭包的混淆。但是如果大括号紧跟在数组的类型定义之后，这样不会导致和闭包的混淆，这种情况下是支持Java风格的数组定义方式的。</p><pre><code class="Groovy">def primes = new int[] {2, 3, 5, 7, 11}assert primes.size() == 5 &amp;&amp; primes.sum() == 28assert primes.class.name == &#39;[I&#39;def pets = new String[] {&#39;cat&#39;, &#39;dog&#39;} // 大括号跟在类型定义之后assert pets.size() == 2 &amp;&amp; pets.sum() == &#39;catdog&#39;assert pets.class.name == &#39;[Ljava.lang.String;&#39;// traditional Groovy alternative still supportedString[] groovyBooks = [ &#39;Groovy in Action&#39;, &#39;Making Java Groovy&#39; ]assert groovyBooks.every{ it.contains(&#39;Groovy&#39;) }</code></pre><p>9.Maps</p><p>Groovy Map在其他语言中可能被称为字典或关联数组。Map将键和值关联起来，用冒号分隔键和值，每个键值对用逗号分隔，所有的键值对用方括号包裹。</p><pre><code class="Groovy">def colors = [red: &#39;#FF0000&#39;, green: &#39;#00FF00&#39;, blue: &#39;#0000FF&#39;] // 定义一个Map，键为颜色字符串，值为对应的16进制html颜色assert colors[&#39;red&#39;] == &#39;#FF0000&#39; // 使用下标符号访问red键对应的内容assert colors.green  == &#39;#00FF00&#39; // 使用属性符号来访问green键对应的值colors[&#39;pink&#39;] = &#39;#FF00FF&#39; // 相似的使用下标符号添加新的键值对colors.yellow  = &#39;#FFFF00&#39; // 使用属性符号来添加键值对assert colors.pink == &#39;#FF00FF&#39;assert colors[&#39;yellow&#39;] == &#39;#FFFF00&#39;assert colors instanceof java.util.LinkedHashMap</code></pre><p>Groovy的map实际上是<code>java.util.LinkedHashMap</code>的实例。</p><p>如果访问一个Map中不存在的key时，会得到一个null</p><pre><code class="Groovy">assert colors.unknown == null</code></pre><p>上面的例子中使用了字符串作为key，但也可以使用其他类型的值作为key</p><pre><code class="Groovy">def numbers = [1: &#39;one&#39;, 2: &#39;two&#39;]assert numbers[1] == &#39;one&#39;</code></pre><p>这里使用了数字作为key，由于数字可以明确地被识别为数字，所以Groovy不需要像上面地其他例子一样创建一个字符串key。但是如果要传递一个变量中的值作为key:</p><pre><code class="Groovy">def key = &#39;name&#39;def person = [key: &#39;Guillaume&#39;] // 与Guillaume关联的键实际上是key字符串，而不是key变量中的值assert !person.containsKey(&#39;name&#39;) // map中不包含name键assert person.containsKey(&#39;key&#39;) // map中包含key键</code></pre><p>当使用名称作为key时，实际上在map中定义了字符串key。<br>如果需要传递变量的值作为key值，必须用括号包裹值或表达式:</p><pre><code class="Groovy">def key = &#39;name&#39;person = [(key): &#39;Guillaume&#39;] // 用引号包裹key变量，指示解析器我们传递的是变量的值，而不是变量的名称assert person.containsKey(&#39;name&#39;) // map中包含name键assert !person.containsKey(&#39;key&#39;) // map中不包含key键</code></pre><p>你可以传递带引号的字符串作为key:<code>[&quot;name&quot;:&quot;Guillaume&quot;]</code>。如果key字符串不是一个有效标识，则必须添加引号。例如想要使用一个包含其他字符的字符串作为key时: <code>[&quot;street-name&quot;: &quot;Main street&quot;]</code>。如果这个key值不带引号则不支持。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> Groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea社区版搭建JavaWeb开发环境</title>
      <link href="/2020/06/16/Tools/Idea/Tomcat/"/>
      <url>/2020/06/16/Tools/Idea/Tomcat/</url>
      
        <content type="html"><![CDATA[<h1 id="Idea社区版搭建JavaWeb开发环境"><a href="#Idea社区版搭建JavaWeb开发环境" class="headerlink" title="Idea社区版搭建JavaWeb开发环境"></a>Idea社区版搭建JavaWeb开发环境</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>jdk</li><li>Tomcat</li><li>IDEA 社区版</li><li>IDEA插件：Smart Tomcat<br><img src="/2020/06/16/Tools/Idea/Tomcat/SmartTomcat.png" alt="Smart Tomcat"></li></ul><ol><li><p>创建项目<br>选择创建一个新Java项目，项目构建选择Gradle，kotlin<br><img src="/2020/06/16/Tools/Idea/Tomcat/newProject.png" alt="new project"></p></li><li><p>修改build.gradle<br>在项目的build.gradle中添加<code>war</code>插件依赖并添加<code>javax</code>依赖<br>修改完的gradle文件如下</p><pre><code class="kotlin">plugins {    kotlin(&quot;jvm&quot;) version &quot;1.3.72&quot;    war // 1.war插件}group = &quot;com.suifeng&quot;version = &quot;1.0-SNAPSHOT&quot;repositories {    mavenCentral()}dependencies {    implementation(kotlin(&quot;stdlib-jdk8&quot;))    implementation(&quot;javax:javaee-api:8.0&quot;) // 2.javax}tasks {    compileKotlin {        kotlinOptions.jvmTarget = &quot;1.8&quot;    }    compileTestKotlin {        kotlinOptions.jvmTarget = &quot;1.8&quot;    }}</code></pre></li><li><p>创建webapp<br>在main路径下创建一个<strong>webapp</strong>目录。</p></li><li><p>创建Servlet<br>在kotlin目录下创建一个Class，实现一个简单地Servlet</p><pre><code class="kotlin">package com.suifeng.webimport javax.servlet.annotation.WebServletimport javax.servlet.http.HttpServletimport javax.servlet.http.HttpServletRequestimport javax.servlet.http.HttpServletResponse/** *@author suifengczc *@date 2020/6/21 */@WebServlet(value = [&quot;/hello&quot;])class FirstServlet : HttpServlet() {    override fun doGet(req: HttpServletRequest?, resp: HttpServletResponse?) {        resp?.writer?.write(&quot;Hello, World!&quot;)    }}</code></pre></li><li><p>配置RunConfigurations</p></li></ol><p>这里需要用到Smart Tomcat插件。</p><p>创建一项新的配置，使用Smart Tomcat模板。<br><img src="/2020/06/16/Tools/Idea/Tomcat/config_st.png"></p><p>填入对应的配置<br><img src="/2020/06/16/Tools/Idea/Tomcat/runconfig.png" alt="run config"><br>Tomcat Server：填入本地的Tomcat目录<br>Deployment Directory：部署路径，第二步创建的<strong>webapp</strong>目录的路径。<br>Context Path: 上下文路径，可以是<code>/</code>或者自行修改<br>其他的保持默认</p><p>这样一个简单的基于IDEA社区版的web开发环境就配置好了。点击run按钮可以看到Tomcat服务正常启动了。<br><img src="/2020/06/16/Tools/Idea/Tomcat/runLog.png"></p><p>在浏览器中可以正常访问到接口了<br><img src="/2020/06/16/Tools/Idea/Tomcat/runWeb.png"></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> IDEA </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class文件结构</title>
      <link href="/2020/06/13/Language/Java/class/"/>
      <url>/2020/06/13/Language/Java/class/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Class文件介绍"><a href="#Class文件介绍" class="headerlink" title="Class文件介绍"></a>Class文件介绍</h1><p>Class文件是Java源代码文件经Java编译器编译后得到的Java字节码文件。对比Linux、Windows上的可执行文件而言， Class文件可以看作是Java虚拟机的可执行文件。</p><h2 id="Class文件格式"><a href="#Class文件格式" class="headerlink" title="Class文件格式"></a>Class文件格式</h2><p>在Java虚拟机的规范中，Class文件有严格格式，具体的格式如下：</p><pre><code class="C++">    ClassFile{        u4                  magic;        u2                  minor_version;        u2                  major_version;        u2                  constant_pool_count;        cp_info             constant_pool[constant_pool_count - 1];        u2                  access_flags;        u2                  this_class;        u2                  super_class;        u2                  interfaces_count;        u2                  interfaces[interfaces_count];        u2                  fields_count;        field_info          fields[fields_count];        u2                  methods_count;        method_info         methods[methods_count];        u2                  attributes_count;        attribute_info      attributes[attributes_count];    }</code></pre><p><img src="/2020/06/13/Language/Java/class/ClassStructure.png" alt="ClassStructor"></p><p>各个字段的释义如下：</p><ol><li><p>magic: Class文件的前4个字节是magic值，取值固定是OxCAFEBABE</p></li><li><p>minor_version: 占用两个字节，表示该Class文件的小版本号</p></li><li><p>major_version: 占用两个字节，表示该Class文件的主版本号。从JDK1.k(k≥2)开始对应的Class文件格式版本号范围是45.0 ~ (44.0+k.0)</p></li><li><p>constant_pool_count:常量池的数量</p></li><li><p>constant_pool: 常量池数组，每个元素都是一个cp_info(constant pool info)的结构，其中包括了常量的类型和常量的内容。需要注意的是常量池数组的索引从1开始，如果引用到索引为0的常量池元素则表示不引用任何常量池内容</p></li><li><p>access_flags: 表明该类的访问权限，比如public, private等</p></li><li><p>this_class: 存储了指向常量池数组元素的索引。通过常量池元素对应的内容可以得到本类的全限定类名</p></li><li><p>super_class: 存储了指向常量池数组元素的索引。通过常量池元素对应的内容可以得到父类的全限定类名</p></li><li><p>interfaces_count: 存储了该类实现了多少个接口</p></li><li><p>interfaces: 保存了实现的接口的接口名在常量池中的索引</p></li><li><p>fields_count: 保存了该类包含的成员变量的数量</p></li><li><p>fields: field_info数组，每个field_info包含了成员变量的信息</p></li><li><p>methods_count: 保存类该类中的成员方法数量</p></li><li><p>methods: method_info数组，每个method_info保存了对应的方法的信息</p></li><li><p>attributes_count: 存储了该类包含的属性信息</p></li><li><p>attributes: attributes_info数组，每个attributes_info保存了对应的属性信息。比如资源文件名等。</p></li></ol><h2 id="常量池介绍"><a href="#常量池介绍" class="headerlink" title="常量池介绍"></a>常量池介绍</h2><h3 id="常量项的类型"><a href="#常量项的类型" class="headerlink" title="常量项的类型"></a>常量项的类型</h3><p>常量池中每个常量都是一个cp_info的结构；cp_info的结构如下：</p><pre><code class="C++">cp_info{    u1 tag;    u1 info[];}</code></pre><p>其中，第一个字节tag表示常量项的类型，后续的info数组中是具体的常量项内容。<br>常量项中可能的类型有以下几种：</p><p><img src="/2020/06/13/Language/Java/class/ConstantPoolInfo.png" alt="常量项的类型和tag取值"></p><p>先从常量池的第一项来分析内容：</p><p><img src="/2020/06/13/Language/Java/class/cpinfo_1.png" alt="cp_info_1"><br>这里的tag值为10，参照常量项和tag值对照表能知道第一个cp_info是一个<code>CONSTANT_Methodref</code>类型。接下来的的<code>class_index</code>的值7指向了常量池的第7项。<br><img src="/2020/06/13/Language/Java/class/cpinfo_7.png" alt="cp_info_7"><br>再看第七项的内容，再第七项中tag值为7，表示这是一个CONSTANT_Class类型的结构。后续的<code>name_index</code>又指向了常量池的第33项。<br><img src="/2020/06/13/Language/Java/class/cpinfo_33.png" alt="cp_info_33"><br>可以看到这里的tag值是1，表示这里是一个<code>CONSTANT_Utf8</code>类型结构。<code>CONSTATN_Utf8</code>结构中存储的是字符串常量值。下一项是length，表示这个字符串常量的长度。这里的值是27。再接着就是字符串的具体值数组，可以看到这里的字符串值是当前类的父类的全限定名。</p><p>然后再回到常量池的第一项中的<code>name_and_type_index</code>部分，这里又指向了常量池的第25项。<br><img src="/2020/06/13/Language/Java/class/cpinfo_25.png" alt="cp_info_25"><br>在第25项中可以看到它的tag值是12，类型是<code>CONSTANT_NameAndType</code>。接下来的<code>name_index</code>指向了常量池的第11项。<br><img src="/2020/06/13/Language/Java/class/cpinfo_11.png" alt="cp_info_11"><br>这里又指向了一个<code>CONSTANT_Utf8</code>类型结构，其中存储的字符串值是<code>&lt;init&gt;</code>。<br>在看25项中的<code>descriptor_index</code>又指向了常量池的第12项，可以看到第12项中存储的字符串是<code>()V</code><br><img src="/2020/06/13/Language/Java/class/cpinfo_12.png" alt="cp_info_12"></p><p>所以把字符串常量池的第一项内容全部拼接起来就是一串<code>com/suifeng/lint/HelloSuper &quot;&lt;init&gt;&quot; ()V</code>。可以从这一串字符串中看出该方法所在类是<code>com/suifeng/lint/HelloSuper</code>。方法名是<code>&lt;init&gt;</code>也就是<code>HelloSuper</code>类的构造函数，该函数的返回值是<code>Void</code>。</p><p>至于为什么采用间接引用索引的方式是为了减小Class文件的空间占用。</p><h3 id="常量项的结构"><a href="#常量项的结构" class="headerlink" title="常量项的结构"></a>常量项的结构</h3><h4 id="cp-info"><a href="#cp-info" class="headerlink" title="cp_info"></a>cp_info</h4><pre><code class="C++">cp_info{    u1 tag;    u1 info[];}</code></pre><p>这是一个大体结构，所有的常量项，不论是<code>CONSTANT_Class</code>还是<code>CONSTANT_Fieldref</code>还是其他的任意类型，都遵守这个结构。</p><p>结构的第一个字节表示了当前结构的类型，后续为该结构的具体内容。</p><h4 id="Class-info"><a href="#Class-info" class="headerlink" title="Class_info"></a>Class_info</h4><pre><code class="C++">CONSTANT_Class_info {    u1 tag; //7，表示CONSTANT_Class_info类型    u2 name_index; // 保存了索引，指向了保存当前类的全限定名字符串的常量项}</code></pre><h4 id="field-info"><a href="#field-info" class="headerlink" title="field_info"></a>field_info</h4><pre><code class="C++">CONSTANT_Fieldref_info {    u1 tag; // 9，表示CONSTANT_Fieldref_info类型    u2 class_index; // 保存了索引，指向了保存当前类的全限定名字符串的常量项    u2 name_and_type_index; // 保存了索引，指向了field的名称和类型}</code></pre><h4 id="method-info"><a href="#method-info" class="headerlink" title="method_info"></a>method_info</h4><pre><code class="C++">CONSTANT_Methodref_info {    u1 tag; // 10，表示CONSTANT_Methodref_info类型    u2 class_index; // 保存了索引，指向了保存当前类的全限定名字符串的常量项    u2 name_and_type_index;// 保存了索引，指向了method的名称、传参和返回值等信息}</code></pre><h3 id="常量信息描述规则"><a href="#常量信息描述规则" class="headerlink" title="常量信息描述规则"></a>常量信息描述规则</h3><ol><li><p>基础数据类型</p><p> 基础数据类型按照如下的对应关系：</p><table><thead><tr><th>基础数据类型</th><th>描述符</th></tr></thead><tbody><tr><td>byte</td><td>B</td></tr><tr><td>char</td><td>C</td></tr><tr><td>double</td><td>D</td></tr><tr><td>float</td><td>F</td></tr><tr><td>int</td><td>I</td></tr><tr><td>long</td><td>L</td></tr><tr><td>short</td><td>S</td></tr><tr><td>boolean</td><td>Z</td></tr></tbody></table><p> 这里要注意的是，所有的描述符都是大写的。</p></li><li><p>引用数据类型</p><p> 引用数据类型的格式为<code>LClassName;</code>，这里的ClassName必须是类的全限定名称，比如<code>Ljava/lang/Object;</code>，全限定名称中的<code>.</code>要换成<code>/</code>,并且最后要加上分号。</p></li><li><p>数组类型</p><p> 数组也是一种引用类型，数组用以<code>[</code>开头加上引用数据类型的方式来表示。例如表示一个Object数组，可以用<code>[Ljava/lang/Object;</code>的方式来表示。如果是二位数组，可以以<code>[[</code>开头，后面加上对应的应用数据类型或者基础数据类型。比如一个二维int数组可以用<code>[[I</code>来表示。对于多维数组，有几维就放几个<code>[</code>来表示维数。</p></li></ol><h2 id="field-info和method-info"><a href="#field-info和method-info" class="headerlink" title="field_info和method_info"></a>field_info和method_info</h2><p>field_info的结构如下：</p><pre><code class="C++">field_info {    u2              access_flags;    u2              name_index;    u2              descriptor_index;    u2              attributes_count;    attribute_info  attributes[attributes_count]}</code></pre><p>method_info的结构如下：</p><pre><code class="C++">method_info {    u2              access_flags;    u2              name_index;    u2              descriptor_index;    u2              attributes_count;    attribute_info  attributes[attributes_count]}</code></pre><p>可以看到两者的结构非常相似，这里做同意解释：</p><ol><li><p>access_flags: 访问标识，但要注意field的访问标识和method的访问标识有所不同，后面会讲到</p></li><li><p>name_index: 存储了指向成员变量名或成员函数名的<code>CONSTANT_Utf8_info</code>常量项</p></li><li><p>descriptot_index: 存储了指向成员变量描述符(变量类型)或成员函数描述符(函数的传参和返回值)</p></li><li><p>attributes_count: 当前变量或函数携带的属性个数</p></li><li><p>attributes: 当前变量或函数携带的属性值，以<code>attribute_info</code>数组的形式存在</p></li></ol><h2 id="access-info介绍"><a href="#access-info介绍" class="headerlink" title="access_info介绍"></a>access_info介绍</h2><p>在Java中，类，类的成员都有访问控制，比如public或者private等在Class文件中都转换成access_flags。每种访问信息都由一个十六进制的标志值表示，如果同时具有多种访问信息，则得到的标志值为这几种访问信息的标志值的逻辑或。</p><p>class的access_flags取值如下:<br><img src="/2020/06/13/Language/Java/class/access_flags_class.jpg" alt="Class的access_flags取值"></p><p>field的access_flags取值如下:<br><img src="/2020/06/13/Language/Java/class/access_flags_field_1.jpg" alt="field的access_flags取值"><br><img src="/2020/06/13/Language/Java/class/access_flags_field_2.jpg"></p><p>method的access_flags取值如下:<br><img src="/2020/06/13/Language/Java/class/access_flags_method.jpg" alt="method的access_flags取值"></p><h2 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h2><p>属性是Class文件的重要组成部分。和常量池类似，属性也分很多类型。在Java虚拟机规范中，属性可用attribute_info数据结构伪代码表示</p><pre><code class="C++">attribute_info {    u2 attribute_name_index;   // 属性名称，指向常量池中Utf8常量项的索引    u4 attribute_length;       // 该属性具体内容的长度，即下面info数组的长度    u1 info[attribute_length]; // 属性具体内容}</code></pre><p>和常量池类型不一样的是，属性是由其名称来区别的，即attribute_info中的attribute_name_index所指向的Utf8字符串。下面列出了一些重要属性的名称和它们的作用。</p><p><img src="/2020/06/13/Language/Java/class/attribute_and_apply.jpg" alt="属性名称和作用"></p><p>从上述介绍中可知</p><ul><li><p>属性的类型由其名字来描述。比如”Code””SourceFile”等</p></li><li><p>不同类型的属性可能出现在ClassFile中不同的成员里，或者某个属性只能出现在固定的成员中。</p></li><li><p>属性也可以包含子属性，比如”Code”属性能包含”LocalVariableTable”属性。</p></li></ul><h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p>Code属性中包含了一个函数的内容，是很重要的一个属性。<br>Code属性的结构如下：</p><pre><code class="C++">Code_attribute{    u2     attribute_name_index;    u4     attribute_length;    u2     max_stack;    u2     max_locals;    u4     code_length;    u1     code[code_length];    u2     exception_table_length;    {        u2     start_pc;        u2     end_pc;        u2     handler_pc;        u2     catch_type;    }exception_table[exception_table_length];    u2     attributes_count;    attribute_info attributes[attributes_count];}</code></pre><p>Code_attribute中各个属性的说明如下：</p><ul><li><p>attribute_name_index指向内容为”Code”的Utf8_info常量项。attribute_length表示接下来内容的长度。</p></li><li><p>max_stack：JVM执行一个指令的时候，该指令的操作数存储在一个名叫“操作数栈（operand stack）”的地方，每一个操作数占用一个或两个（long、double类型的操作数）栈项。stack就是一块只能进行先入后出的内存。max_stack用于说明这个函数在执行过程中，需要最深多少栈空间（也就是多少栈项）。</p></li><li><p>max_locals: 表示该函数包括最多几个局部变量。注意，max_stack和max_locals都和JVM如何执行一个函数有关。根据JVM官方规范，每一个函数执行的时候都会分配一个操作数栈和局部变量数组。所以Code_attribute需要包含这些内容，这样JVM在执行函数前就可以分配相应的空间。</p></li><li><p>code_length和code：函数对应的指令内容也就是这个函数的源码经过编译器转换后得到的Java指令码存储在code数组中，其长度由code_length表明。</p></li><li><p>exception_table_length和exception_table：一个函数可以包含多个try/catch语句，一个try/catch语句对应exception_table数组中的一项</p></li><li><p>start_pc描述try/cath语句从哪条指令开始。注意，这个table中的各个pc变量的取值必须位于代表整个函数内容的Java字节码code[code_length]数组中。</p></li><li><p>end_pc表示这个try语句到哪条指令结束。注意，只包括try语句，不包括catch。</p></li><li><p>handler_pc表示catch语句的内容从哪条指令开始</p></li><li><p>catch_type表示catch中截获的Exception或Error的名字，指向Utf8_info常量项。如果catch_type取值为0，则表示它是final{}语句块。<br>另外，图2-7中表明Code_atrribute还能包含其他属性，Code_attribute里常见的属性有：</p></li><li><p>LineNumberTable用于调试，比如指明哪条指令。对应于源码哪一行。</p></li><li><p>LocalVariableTable用于调试，调试时可以用于计算本地变量的值。</p></li><li><p>LocalVariableTypeTable，功能和LocalVariableTable类似。</p></li><li><p>StackMapTable为Java 1.6以上才支持的属性。JVM加载Class文件的时候，将利用该属性的内容对函数进行类型校验（Type Checking）。</p></li></ul><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><p><a href="https://read.douban.com/reader/ebook/110275324/" target="_blank" rel="noopener">https://read.douban.com/reader/ebook/110275324/</a></p></li><li><p><a href="https://blog.csdn.net/tjiyu/article/details/53870153" target="_blank" rel="noopener">https://blog.csdn.net/tjiyu/article/details/53870153</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> java </tag>
            
            <tag> Class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀表达式、中缀表达式、后缀表达式</title>
      <link href="/2020/05/17/Data_Structure/expression/"/>
      <url>/2020/05/17/Data_Structure/expression/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>前缀表达式、中缀表达式、后缀表达式指的是在一个表达式中对于操作符与操作数之间的不同的位置关系的表述方式。前缀表达式又称为波兰式，后缀表达式又称为逆波兰式。但要注意的是逆波兰式并不是波兰式的简单反转。</p><p>对于人类来说更容易理解和运用的表达式是中缀表达式，所以通用的算数或逻辑运算的表示方法都是用的中缀表达式。<br>例如常见的算术表达式：<code>1 + 2</code>, <code> A &bigoplus; B</code>等<br>人们可以从轻松地从表达式中读取到<code>1</code>和<code>2</code>做了相加的运算，<code>A</code>和<code>B</code>做了异或运算。</p><p>但是对于计算机来说中缀表达式不容易理解，特别是复杂的需要考虑运算优先级的表达式。借助前缀表达式和后缀表达式基于堆栈可以快速求值。</p><p>前缀表达式（波兰式）和后缀表达式（）最早由波兰数学家<strong>扬·卢卡西维茨</strong>提出<a href="%5B%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%5D(https://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95)">^1</a>。</p><h1 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>前缀表达式的特点是操作符在操作数之间。</p><h2 id="中缀表达式转化为前缀表达式"><a href="#中缀表达式转化为前缀表达式" class="headerlink" title="中缀表达式转化为前缀表达式"></a>中缀表达式转化为前缀表达式</h2><p>将中缀表达式转化为前缀表达式有两种转换方式：分别是二叉树转换和堆栈转换。</p><h2 id="前缀表达式的运算"><a href="#前缀表达式的运算" class="headerlink" title="前缀表达式的运算"></a>前缀表达式的运算</h2>]]></content>
      
      
      <categories>
          
          <category> data structure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data structure </tag>
            
            <tag> Expression </tag>
            
            <tag> 前缀表达式 </tag>
            
            <tag> 中缀表达式 </tag>
            
            <tag> 后缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向经验</title>
      <link href="/2020/05/16/Skill/Reverse/Reverse/"/>
      <url>/2020/05/16/Skill/Reverse/Reverse/</url>
      
        <content type="html"><![CDATA[<h1 id="逆向经验"><a href="#逆向经验" class="headerlink" title="逆向经验"></a>逆向经验</h1><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><ul><li><a href="https://github.com/iBotPeaches/Apktool" target="_blank" rel="noopener">Apktools</a>  </li><li><a href="https://github.com/skylot/jadx" target="_blank" rel="noopener">jadx</a></li><li>jeb</li><li><a href="https://github.com/pxb1988/dex2jar" target="_blank" rel="noopener">dex2jar</a></li><li><a href="https://github.com/JesusFreke/smali" target="_blank" rel="noopener">bakSmali</a></li></ul><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><h4 id="Xposed"><a href="#Xposed" class="headerlink" title="Xposed"></a>Xposed</h4><p>原理：</p><p>Android系统中所有的app进程都是有zygote进程孵化而来的，Xposed会替换/system/bin/app_process文件，替换后的app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持</p><p>运行条件：</p><ol><li>root环境</li><li>每次修改需要重启才能生效</li></ol><p>优点：</p><ol><li>API简单易用(TODO  xc_methodxxxx,xc_replacementxxx)</li><li>使用Java语言，方便使用</li></ol><p>缺点：</p><ol><li>每次修改需要重启</li><li>只能hook Java层</li></ol><h4 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a><a href="https://github.com/frida/frida" target="_blank" rel="noopener">Frida</a></h4><p>Python库，使用JavaScript编写 hook 代码。</p><p>原理：</p><p>使用了动态插桩技术，在程序运行时实时插入额外代码。</p><p>运行条件:</p><ol><li>root环境</li><li>Frida库</li></ol><p>优点：</p><ol><li>实时生效，无需重启</li><li>可以hook java层和native层</li><li>支持多平台:<a href="https://github.com/frida/frida/releases" target="_blank" rel="noopener">release</a></li></ol><p>缺点：</p><ol><li>文档不完善</li><li>js和Java交互不方便</li></ol><h4 id="Substrate"><a href="#Substrate" class="headerlink" title="Substrate"></a>Substrate</h4><h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><ul><li><a href="https://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler</a></li><li><a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">Charles</a></li><li><a href="https://www.wireshark.org/" target="_blank" rel="noopener">WireShark</a></li><li><a href="https://github.com/mitmproxy/mitmproxy" target="_blank" rel="noopener">MitmProxy</a></li></ul><h3 id="Android界面分析工具"><a href="#Android界面分析工具" class="headerlink" title="Android界面分析工具"></a>Android界面分析工具</h3><ul><li>uiautomatorviewer</li><li>macaca uiautomator</li><li>adb shell dumpsys activity top</li><li><a href="https://github.com/leavesC/Activity" target="_blank" rel="noopener">TopActivity</a></li></ul><h2 id="Hook对抗"><a href="#Hook对抗" class="headerlink" title="Hook对抗"></a>Hook对抗</h2><h3 id="Xposed对抗"><a href="#Xposed对抗" class="headerlink" title="Xposed对抗"></a>Xposed对抗</h3><h4 id="通过PackageManager查看安装列表"><a href="#通过PackageManager查看安装列表" class="headerlink" title="通过PackageManager查看安装列表"></a>通过PackageManager查看安装列表</h4><h4 id="堆栈判断"><a href="#堆栈判断" class="headerlink" title="堆栈判断"></a>堆栈判断</h4><pre><code class="java">Thread.currentThread.getStackTrace()</code></pre><h4 id="读取-proc-self-maps"><a href="#读取-proc-self-maps" class="headerlink" title="读取/proc/self/maps"></a>读取/proc/self/maps</h4><p>无论在Java层做何种检测，Xposed都可以通过Hook相关的API并返回指定的结果来绕过检测，只要有方法就可以被Hook。如果仅在Java层检测就显得很徒劳，为了有效提搞检测准确率，就须做到Java和Native层同时检测。</p><p>在Native层读取/proc/self/maps文件，判断App自身加载的库中是否存在XposedBridge.jar、相关的Dex、Jar和So库等文件</p><h3 id="Frida对抗"><a href="#Frida对抗" class="headerlink" title="Frida对抗"></a>Frida对抗</h3><h4 id="遍历进程"><a href="#遍历进程" class="headerlink" title="遍历进程"></a>遍历进程</h4><p>遍历进程，判断frida-server是否运行</p><pre><code class="java">public boolean checkRunningProcesses() {  boolean returnValue = false;  // Get currently running application processes  List&lt;RunningServiceInfo&gt; list = manager.getRunningServices(300);  if(list != null){    String tempName;    for(int i=0;i&lt;list.size();++i){      tempName = list.get(i).process;      if(tempName.contains(&quot;fridaserver&quot;)) {        returnValue = true;      }    }  }  return returnValue;}</code></pre><h4 id="检查27047端口"><a href="#检查27047端口" class="headerlink" title="检查27047端口"></a>检查27047端口</h4><p>fridaserver 默认的 TCP 端口是 27047，可以检查这个端口是否开放</p><pre><code class="c">boolean is_frida_server_listening() {    struct sockaddr_in sa;    memset(&amp;sa, 0, sizeof(sa));    sa.sin_family = AF_INET;    sa.sin_port = htons(27047);    inet_aton(&quot;127.0.0.1&quot;, &amp;(sa.sin_addr));    int sock = socket(AF_INET , SOCK_STREAM , 0);    if (connect(sock , (struct sockaddr*)&amp;sa , sizeof sa) != -1) {      /* Frida server detected. Do something… */    }}</code></pre><h4 id="发送-D-Bus消息"><a href="#发送-D-Bus消息" class="headerlink" title="发送 D-Bus消息"></a>发送 D-Bus消息</h4><p>每个开放的端口发送 D-Bus 的认证消息，哪个端口回复了哪个就是 fridaserver</p><pre><code class="c">for(i = 0 ; i &lt;= 65535 ; i++) {    sock = socket(AF_INET , SOCK_STREAM , 0);    sa.sin_port = htons(i);    if (connect(sock , (struct sockaddr*)&amp;sa , sizeof sa) != -1) {        __android_log_print(ANDROID_LOG_VERBOSE, APPNAME,  &quot;FRIDA DETECTION [1]: Open Port: %d&quot;, i);        memset(res, 0 , 7);        // send a D-Bus AUTH message. Expected answer is “REJECT&quot;        send(sock, &quot;\x00&quot;, 1, NULL);        send(sock, &quot;AUTH\r\n&quot;, 6, NULL);        usleep(100);        if (ret = recv(sock, res, 6, MSG_DONTWAIT) != -1) {            if (strcmp(res, &quot;REJECT&quot;) == 0) {               /* Frida server detected. Do something… */            }        }    }    close(sock);}</code></pre><h4 id="内存特征码检测"><a href="#内存特征码检测" class="headerlink" title="内存特征码检测"></a>内存特征码检测</h4><p>在内存中扫描 frida 的库特征 “gadgets”。例如字符串 “LIBFRIDA”在所有frida-gadget 和 frida-agent 的版本中都有出现。</p><pre><code class="c">static char keyword[] = &quot;LIBFRIDA&quot;;num_found = 0;int scan_executable_segments(char * map) {    char buf[512];    unsigned long start, end;    sscanf(map, &quot;%lx-%lx %s&quot;, &amp;start, &amp;end, buf);    if (buf[2] == &#39;x&#39;) {        return (find_mem_string(start, end, (char*)keyword, 8) == 1);    } else {        return 0;    }}void scan() {    if ((fd = my_openat(AT_FDCWD, &quot;/proc/self/maps&quot;, O_RDONLY, 0)) &gt;= 0) {    while ((read_one_line(fd, map, MAX_LINE)) &gt; 0) {        if (scan_executable_segments(map) == 1) {            num_found++;        }    }    if (num_found &gt; 1) {        /* Frida Detected */    }}</code></pre><h2 id="查找分析突破口"><a href="#查找分析突破口" class="headerlink" title="查找分析突破口"></a>查找分析突破口</h2><h3 id="界面变化"><a href="#界面变化" class="headerlink" title="界面变化"></a>界面变化</h3><ol><li><p>弹窗(AlertDialog)</p></li><li><p>页面元素变化(TextView)</p></li><li><p>页面跳转(startActivity)</p></li><li><p>触摸事件(onClick)</p></li></ol><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><ol><li>构建Url</li></ol><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><ol><li>StringBuilder.append()</li><li>StringBuffer.append()</li><li>String.concat()</li></ol><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://bbs.pediy.com/" target="_blank" rel="noopener">看雪论坛</a>/看雪学院(微信公众号)</li><li><a href="http://www.520monkey.com/" target="_blank" rel="noopener">http://www.520monkey.com/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Skill </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Skill </tag>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WindowsTernimal 配置</title>
      <link href="/2020/05/08/Tools/WindowsTerminal/TerminalConfig/"/>
      <url>/2020/05/08/Tools/WindowsTerminal/TerminalConfig/</url>
      
        <content type="html"><![CDATA[<h1 id="WindowsTernimal-介绍"><a href="#WindowsTernimal-介绍" class="headerlink" title="WindowsTernimal 介绍"></a>WindowsTernimal 介绍</h1><p>WindowsTernimal是微软在2019年推出的一款新的开源终端应用程序，目前已经上架<a href="https://www.microsoft.com/zh-cn/p/windows-terminal/9n0dx20hk701?cid=storebadge&ocid=badge&rtc=1#activetab=pivot:overviewtab" target="_blank" rel="noopener">Microsoft Store</a>。<br>源码地址：<a href="https://github.com/microsoft/Terminal" target="_blank" rel="noopener">Ternimal</a></p><p>WindowsTernimal最低系统要求为Windows 10 Build 18362版本</p><p>2020-05-06微软终于发布了Ternimal的<a href="https://github.com/microsoft/terminal/releases/tag/v0.11.1251.0" target="_blank" rel="noopener">1.0rc1</a>版本</p><p>这个版本对原来的配置项做了修改，所以本文介绍一下1.0版本的配置。和原来的配置大同小异</p><h1 id="WindowsTernimal-配置"><a href="#WindowsTernimal-配置" class="headerlink" title="WindowsTernimal 配置"></a>WindowsTernimal 配置</h1><p>按照官方的<a href="https://github.com/microsoft/terminal/blob/master/doc/user-docs/UsingJsonSettings.md" target="_blank" rel="noopener">配置说明</a>，配置主要包括：全局配置(Global)、快捷键(Key Binding)、终端配置(Profiles)、配色方案(Schemes)等四项。</p><p>当前Ternimal只支持使用通过编辑<strong>setting.json</strong>配置文件的方式修改设置。<br>打开配置文件的方式可以点击下拉菜单的设置选项，或者使用快捷键<code>ctrl + ,</code>，都会在默认的json文件编辑器中打开配置文件。<br>也可以直接打开配置文件所在路径，在资源管理器中输入<code>%LocalAppData%\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json</code>，也会调用默认编辑器打开配置文件。</p><p>Ternimal的设置分为两个部分，一个是硬编码的<strong>defaults.json</strong>，另一个是<strong>settings.json</strong>。<br>注：虽然官方文档是这样说的，但实际上找不到defaults.json配置文件在哪里。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> WindowsTernimal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macaca环境安装</title>
      <link href="/2020/03/29/Tools/macaca/install/"/>
      <url>/2020/03/29/Tools/macaca/install/</url>
      
        <content type="html"><![CDATA[<h2 id="macaca介绍"><a href="#macaca介绍" class="headerlink" title="macaca介绍"></a>macaca介绍</h2><p>Macaca 是一套面向用户端软件的测试解决方案，提供了自动化驱动，环境配套，周边工具，集成方案，旨在解决终端上的测试、自动化、性能等方面的问题。<br>因为Android sdk下的uiautomatorviewer经常有问题，所以用Macaca提供的UiAutomator代替。</p><h2 id="macaca安装"><a href="#macaca安装" class="headerlink" title="macaca安装"></a>macaca安装</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li>Node.js</li><li>Android sdk</li><li>Gradle 构建环境</li><li>JDK 1.8</li></ol><h3 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h3><p>因为npm的源在国外，可能下载缓慢或下载失败，可以使用淘宝的镜像cnpm。<br>执行<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>安装cnpm，安装成功后可以使用cnpm命令代替npm命令安装库。<br><img src="/2020/03/29/Tools/macaca/install/npmtocnpm.png" alt="npm to cnpm"></p><h3 id="安装macaca-android"><a href="#安装macaca-android" class="headerlink" title="安装macaca-android"></a>安装macaca-android</h3><p>执行<code>cnpm i macaca-android -g</code>安装macaca-android驱动<br><img src="/2020/03/29/Tools/macaca/install/macaca_android.png" alt="macaca-android"></p><h3 id="安装macaca-cli"><a href="#安装macaca-cli" class="headerlink" title="安装macaca-cli"></a>安装macaca-cli</h3><p>执行<code>cnpm o macaca-cli -g</code>安装macaca命令行工具，出现一个巨大的猴子头就安装成功了。<br><img src="/2020/03/29/Tools/macaca/install/macaca_cli.png" alt="macaca-cli"></p><h3 id="安装app-inspector"><a href="#安装app-inspector" class="headerlink" title="安装app-inspector"></a>安装app-inspector</h3><p>执行<code>cnpm i app-inspector -g</code>安装ui查看器。<br><img src="/2020/03/29/Tools/macaca/install/app_inspector.png" alt="app-inspector"></p><p>都安装完成后可以执行<code>macaca doctor</code>验证，出现如下信息表示安装成功：<br><img src="/2020/03/29/Tools/macaca/install/macaca_doctor.png" alt="macaca doctor"><br>这里的提示没有设置Gradle环境不影响使用。</p><p>到这里macaca环境安装成功</p><h2 id="macaca-uiautomator使用"><a href="#macaca-uiautomator使用" class="headerlink" title="macaca uiautomator使用"></a>macaca uiautomator使用</h2><p>查看Android应用ui信息的命令是<br><code>app-inspector -u device_id --verbose</code><br>这里的device_id可以执行<code>adb devices</code>获取。<br>成功后会自动调用浏览器打开结果。<br><img src="/2020/03/29/Tools/macaca/install/success.png" alt="success"></p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>执行<code>app-inspector -u device_id --verbose</code>可能会遇到的问题。</p><h3 id="找不到app-debug-apk"><a href="#找不到app-debug-apk" class="headerlink" title="找不到app-debug.apk"></a>找不到app-debug.apk</h3><p>初次运行会找不到<strong>uiautomatorwd</strong>下的apk，导致报错。<br><img src="/2020/03/29/Tools/macaca/install/app_not_found.png" alt="app_not_found"><br>可以在报错信息中看到项目所在路径。<br>cd到项目路径下执行<code>.\gradlew build</code>构建项目。<br><img src="/2020/03/29/Tools/macaca/install/gradlew_build.png" alt="gradlew build"><br>build完成后会在对应路径下生成<strong>app-debug.apk</strong></p><h3 id="找不到app-debug-androidTest-apk"><a href="#找不到app-debug-androidTest-apk" class="headerlink" title="找不到app-debug-androidTest.apk"></a>找不到app-debug-androidTest.apk</h3><p>运行时可能找不到<strong>app-debug-androidTest.apk</strong>。<br><img src="/2020/03/29/Tools/macaca/install/testapk_not_found.png" alt="testapp_not_found"><br>cd到项目路径下执行<code>gradlew assembleAndroidTest</code><br><img src="/2020/03/29/Tools/macaca/install/assembleAndroidTest.png" alt="gradlew assembleAndroidTest"><br>build完成后会在对应路径下生成<strong>app-debug-androidTest.apk</strong></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> macaca </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode markdownlint插件自定义生效规则</title>
      <link href="/2020/03/15/Tools/markdown/lint/"/>
      <url>/2020/03/15/Tools/markdown/lint/</url>
      
        <content type="html"><![CDATA[<h1 id="VSCode-markdownlint插件自定义生效规则"><a href="#VSCode-markdownlint插件自定义生效规则" class="headerlink" title="VSCode markdownlint插件自定义生效规则"></a>VSCode markdownlint插件自定义生效规则</h1><p>markdownlint是一款VSCode下的markdown文件lint插件。可以格式化markdown文件。但是markdown默认的规则较多，查看markdownlint的商店介绍页面，有MD001-MD048共48条规则。其中有些规则可能是对个人不必要的，可以自定义启用的规则。</p><h2 id="自定义规则的两种方式"><a href="#自定义规则的两种方式" class="headerlink" title="自定义规则的两种方式"></a>自定义规则的两种方式</h2><p>markdownlint支持两种自定义启用规则的方式，分别是使用.markdownlint.json和使用VSCode的setting.json文件。</p><h3 id="1-使用-markdownlint-json配置"><a href="#1-使用-markdownlint-json配置" class="headerlink" title="1.使用.markdownlint.json配置"></a>1.使用.markdownlint.json配置</h3><blockquote><p>Rules can be enabled, disabled, and customized by creating a JSON file named .markdownlint.json (or .markdownlintrc) or a YAML file named .markdownlint.yaml (or .markdownlint.yml) in any directory of a project. The rules defined by .markdownlint{.json,.yaml,.yml,rc} apply to Markdown files in the same directory and any sub-directories without their own .markdownlint{.json,.yaml,.yml,rc}.</p></blockquote><p>markdownlint的规则可以被使用，被警用或者自定义。只需要在项目的任意目录下新建一个名为<code>.markdownlint.json</code>的文件。<code>.markdownlint.json</code>中的配置被应用到同级和子目录下(如果子目录下不包含<code>.markdownlint.json</code>文件)的md文件。该配置文件支持<code>.json</code>,<code>.yaml</code>,<code>.yml</code>,<code>rc</code>等格式，作用是相同的。</p><p>在<code>.markdownlint.json</code>中可以定义如下配置：</p><pre><code class="json">{    &quot;default&quot;: true,    &quot;MD003&quot;: { &quot;style&quot;: &quot;atx_closed&quot; },    &quot;MD007&quot;: { &quot;indent&quot;: 4 },    &quot;no-hard-tabs&quot;: false}</code></pre><p>第一行是使用默认规则<br>第二行第三行是修改MD003的默认条件<br>第四行是修改markdownlint的设置<br>如果要忽略某个规则，例如忽略MD025，可以加上一条<code>&quot;MD025: false&quot;</code>,就可以禁用MD025这条规则了</p><h3 id="2-使用VSCode的setting-json文件"><a href="#2-使用VSCode的setting-json文件" class="headerlink" title="2.使用VSCode的setting.json文件"></a>2.使用VSCode的setting.json文件</h3><p>markdownlint同时也支持在VSCode的user或workspace下的settings.json中添加markdownlint自定义配置<br>例如在user的setting.json下添加如下配置：</p><pre><code class="json">    &quot;markdownlint.config&quot;: {        &quot;default&quot;: true,        &quot;MD025&quot;: false,        &quot;MD045&quot;: false,        &quot;no-hard-tabs&quot;: false    }</code></pre><p>该配置就会全局生效<br>如果配置在workspace下的setting.json中，就对当前项目生效。<br>通过user和workspace下的setting.json配合可以实现一套通用的规则组合和某个项目下适用的特殊规则组合</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> markdown </tag>
            
            <tag> lint </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装配置zsh</title>
      <link href="/2020/03/15/Platform/Linux/zsh/"/>
      <url>/2020/03/15/Platform/Linux/zsh/</url>
      
        <content type="html"><![CDATA[<h1 id="linux下安装zsh"><a href="#linux下安装zsh" class="headerlink" title="linux下安装zsh"></a>linux下安装zsh</h1><p>本文针对Ubuntu，wsl-Ubuntu</p><h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><p>进入bash，输入<code>sudo apt-get install zsh</code>安装zsh</p><h2 id="查看系统已安装的shells"><a href="#查看系统已安装的shells" class="headerlink" title="查看系统已安装的shells"></a>查看系统已安装的shells</h2><p>安装完成后，输入<code>cat /etc/shells</code>，查看当前系统安装的shell。<br>可以看到zsh在列。<br><img src="/2020/03/15/Platform/Linux/zsh/catShells.png" alt="cat shells"></p><h2 id="设置zsh为默认shell"><a href="#设置zsh为默认shell" class="headerlink" title="设置zsh为默认shell"></a>设置zsh为默认shell</h2><p>输入<code>chsh -s /bin/zsh</code>设置zsh为默认shell</p><p>在输入<code>echo $SHELL</code>查看当前shell，发现还是/bin/bash。<br>这时需要重启一下。<br>再次进入系统，输入<code>echo $SHELL</code>，zsh已经是默认shell了。<br><img src="/2020/03/15/Platform/Linux/zsh/echoshell.png" alt="echo SHELL"></p><h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h2><p>oh-my-zsh是zsh的一套配置，可以方便使用zsh。</p><p>on-my-zsh提供了方便的安装方式，执行下面命令就能自动安装了。因为需要从GitHub下载，可能比较耗时，要等一等。<br><code>wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code><br>执行完后如下图：<br><img src="/2020/03/15/Platform/Linux/zsh/ohmyzsh.png" alt="ohmyzsh"></p><p>再执行<code>source ~/.zshrc</code>使配置生效。<br>这里可能出现autoload: command not found报错，如下：<br><img src="/2020/03/15/Platform/Linux/zsh/source_error.png" alt="autoload: command not found"><br>多番查找在ohmyzsh项目的这个<a href="https://github.com/ohmyzsh/ohmyzsh/issues/8177" target="_blank" rel="noopener">issue</a>中找到了答案，作者mcornella解释是因为在bash中执行的原因。<br><img src="/2020/03/15/Platform/Linux/zsh/source_answer.png" alt="source error answer"></p><p>所以先退出当前的wsl，然后用<code>wsl</code>命令而不是<code>bash</code>命令进入wsl。重新进入后zsh应该已经生效了，如果没有生效可以再执行一次<code>source ~/.zshrc</code>命令。</p><h1 id="配置zsh插件"><a href="#配置zsh插件" class="headerlink" title="配置zsh插件"></a>配置zsh插件</h1><p>oh-my-zsh支持许多效率插件，可以增强终端功能。默认下oh-my-zsh只添加了git插件支持。使用<code>vim ~/.zshrc</code>查看配置可以看到plugins列表中只包含了git插件。<br><img src="/2020/03/15/Platform/Linux/zsh/only_git.png" alt="git plugin"></p><p>zsh插件分为内置插件和非内置插件。</p><ul><li><p>内置插件路径在<code>~/.oh-my-zsh/plugins</code>。可以cd进去看，里面包含了许多插件。使用内置插件直接在oh-my-zsh的插件列表中添加就行了。<br>  例如要添加内置的adb插件，可以直接在.zshrc添加上<code>plugins=(adb git)</code>，然后保存退出，执行<code>source ~/.zshrc</code>生效。</p></li><li><p>第三方插件需要自己去下载到指定目录下，然后再添加到oh-my-zsh插件列表中。最后执行<code>source ~/.zshrc</code>生效</p></li></ul><p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins" target="_blank" rel="noopener">官方的插件Wiki</a></p><h2 id="添加zsh-autosuggestions插件"><a href="#添加zsh-autosuggestions插件" class="headerlink" title="添加zsh-autosuggestions插件"></a>添加zsh-autosuggestions插件</h2><p>zsh-autosuggestions是一款自动提示命令的插件。当你输入指令时，会根据历史命令推测可能要输入的命令。按下方向键右键→就可以补全命令。</p><p>输入<code>git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code>把zsh-autosuggestions克隆到zsh的plugins目录下。</p><p>然后<code>vim ~/.zshrc</code>进入zsh的配置文件再在plugins列表中添加插件。中间用空格隔开。<br><img src="/2020/03/15/Platform/Linux/zsh/two_plugin.png" alt="add plugin"></p><p>最后执行<code>source ~/.zshrc</code>就能使配置生效。</p><p>生效后，输入命令时就能看到提示了：<br><img src="/2020/03/15/Platform/Linux/zsh/autosuggestion.png" alt="auto suggest"></p><h2 id="添加zsh-syntax-highlighting插件"><a href="#添加zsh-syntax-highlighting插件" class="headerlink" title="添加zsh-syntax-highlighting插件"></a>添加zsh-syntax-highlighting插件</h2><p>zsh-syntax-highlighting是一款语法高亮插件，当输入错误命令时，命令是红色的，正常则是其他颜色。</p><p>输入<code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</code>把zsh-syntax-highlighting克隆到plugins目录下。</p><p>接下来的步骤和上面一样。<br>执行<code>source ~/.zshrc</code>生效后就能看到效果了。<br><img src="/2020/03/15/Platform/Linux/zsh/zsh_highlight.png" alt="zsh syntax highlight"></p><h1 id="配置zsh主题"><a href="#配置zsh主题" class="headerlink" title="配置zsh主题"></a>配置zsh主题</h1><p>oh-my-zsh内置了一些主题，路径为<code>~/.oh-my-zsh/themes</code>，可以cd进去查看主题，但是这里只列出了主题名称，不方便挑选。可以访问<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes" target="_blank" rel="noopener">官方主题Wiki</a>选择喜欢的主题。</p><p>例如如果要更换为ys主题，可以<code>vim ~/.zshrc</code>进入配置文件，找到<code>ZSH_THEME=robbyrussell</code>这一行(默认主题是robbyrussell)，修改为<code>ZSH_THEME=ys</code>保存退出。再执行<code>source ~/.zshrc</code>生效。<br><img src="/2020/03/15/Platform/Linux/zsh/ys_theme.png" alt="ys theme"><br><img src="/2020/03/15/Platform/Linux/zsh/use_ys.png" alt="ys"></p><p>这里ZSH_THEME的注释信息里提到如果把主题设置为<code>random</code>则每次oh-my-zsh启动时都会随机挑选一个主题加载。要知道当前使用的主题，可以执行<code>echo $RANDOM_THEME</code>查看。</p>]]></content>
      
      
      <categories>
          
          <category> Platform </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Platform </tag>
            
            <tag> linux </tag>
            
            <tag> zsh </tag>
            
            <tag> oh my zsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除双系统启动项</title>
      <link href="/2020/03/12/Tips/multi_system/remove_startup_item/"/>
      <url>/2020/03/12/Tips/multi_system/remove_startup_item/</url>
      
        <content type="html"><![CDATA[<h1 id="windows下删除双系统启动项"><a href="#windows下删除双系统启动项" class="headerlink" title="windows下删除双系统启动项"></a>windows下删除双系统启动项</h1><ol><li><p><code>win+X</code>打开管理员PowerShell</p></li><li><p>输入<code>diskpart</code>进入diskpart</p></li></ol><p><img src="/2020/03/12/Tips/multi_system/remove_startup_item/diskpart.png" alt="diskpart"><br>3. 输入<code>list disk</code>列出当前系统磁盘(只列出磁盘而非分区)<br>4. 输入<code>select disk 0</code>选择启动盘<br>5. 输入<code>list partition</code>列出当前磁盘下所有分区<br>6. 输入<code>select partition 1</code>选择第一个分区，这里要确定实际启动项所在分区</p><p><img src="/2020/03/12/Tips/multi_system/remove_startup_item/select_partition.png" alt="select partition"><br>7. 输入<code>assign letter=s</code>挂载分区，这时候可以在资源管理器中看到S盘了。这里的<code>letter=</code>后边的字母是指定该分区使用的盘符，可以指定任意未被使用的盘符</p><p><img src="/2020/03/12/Tips/multi_system/remove_startup_item/assign_letter.png" alt="assign letter"><br>8. 保留原PowerShell，再次<code>win+X</code>打开管理员PowerShell<br>9. 在新窗口中输入<code>cd -d s:</code>进入S盘<br>10. 输入<code>ls</code>查看当前有哪些目录，这里已经删除了manjaro启动项了</p><p><img src="/2020/03/12/Tips/multi_system/remove_startup_item/cdls.png" alt="cd_ls"><br>11. 输入<code>rm -r xxxx</code>删除指定的启动项即可<br>12. 完成后回到第一个PowerShell窗口，输入<code>remove letter=s</code>移除分区挂载</p><p><img src="/2020/03/12/Tips/multi_system/remove_startup_item/remove_letter.png" alt="remove letter"><br>13. 完成</p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
            <tag> 双系统 </tag>
            
            <tag> 启动项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/2020/01/05/Tools/git/common_commands/"/>
      <url>/2020/01/05/Tools/git/common_commands/</url>
      
        <content type="html"><![CDATA[<h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><p>参考文档：<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">git-book</a></p><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>初始化仓库<br><code>git init</code></p><h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><p>克隆远端仓库的内容到本地<br><code>git clone https://github.com/xxx/xxx.git</code></p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>作用：把文件加入git跟踪或把文件修改添加入暂存区或者在解决完冲突后标记为已解决。</p><blockquote><p>将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。<br>所有被add的文件在都会出现在下一次commit的内容中。</p></blockquote><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add ."></a>git add .</h3><p>将当前目录及所有子目录下的文件添加入暂存区:<br><code>git add .</code></p><h3 id="git-add-lt-pathspec-gt"><a href="#git-add-lt-pathspec-gt" class="headerlink" title="git add &lt;pathspec&gt;"></a>git add &lt;pathspec&gt;</h3><p>添加目录或文件到暂存区或添加跟踪<br><code>git add xxx</code></p><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>作用：查看或修改git的配置<br>最常见的是配置项目的user.name,user.email,remote url等。</p><p>git的config有三个等级，分别为 –local, –global, –system。<br>local的生效范围最小，只在当前项目内生效，但是优先级最高。保存在每个项目的<code>.git/config</code>下。<br>global的生效范围中等，在当前用户内生效，优先级中等。保存在<code>C:\Users\LENOVO\.gitconfig</code>下。<br>system的生效范围最广，在当前计算机内生效，优先级最低。保存在安装目录下的<code>etc\gitconfig</code>下。</p><p>所有的config操作都可以加上–local,–global,–system指定对哪个配置操作</p><p>另外，因为默认只有一个worktree，所以worktree和local的配置是一样的。如果创建了新的worktree，也可以使用–worktree。</p><h3 id="git-list"><a href="#git-list" class="headerlink" title="git list"></a>git list</h3><p>列出指定位置的配置：<br><code>git list [location]</code><br>如果不加location则会列出当前位置能获取到的所有配置</p><h3 id="常用配置项"><a href="#常用配置项" class="headerlink" title="常用配置项"></a>常用配置项</h3><p><code>git config [--local|--global|--system] user.name &quot;xxxxx&quot;</code><br><code>git config [--local|--global|--system] user.eamil &quot;xxxxx@xx.com&quot;</code><br><code>git core.autocrlf true</code></p><h3 id="非常用配置项"><a href="#非常用配置项" class="headerlink" title="非常用配置项"></a>非常用配置项</h3><p><code>git config [--local|--global|--system] core.editor vim</code><br><code>git config [--local|--global|--system] merge.tool vimdiff</code></p><h3 id="添加删除自定义配置项"><a href="#添加删除自定义配置项" class="headerlink" title="添加删除自定义配置项"></a>添加删除自定义配置项</h3><p>添加自定义配置项:<br><code>git config [--local|--global|--system] --add group.key value</code></p><p>删除自定义配置项<br><code>git config [--local|--global|--system] --unset group.key</code></p><h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><p>作用：分支的创建切换合并删除等操作</p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>创建新分支:<br><code>git branch &lt;branchName&gt;</code></p><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><p>查看所有远程分支和本地分支:<br><code>git branch --all</code></p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>删除指定分支:<br><code>git branch &lt;-d|--delete&gt; &lt;branchName&gt;</code></p><h2 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h2><p>切换到指定分支:<br><code>git checkout &lt;branchName&gt;</code></p><p>基于当前分支创建新分支并切换到新分支<br><code>git checkout -b &lt;branchName&gt;</code></p><p>等同于<code>git branch &lt;branchName&gt;</code>和<code>git checkout &lt;branchName&gt;</code>的组合</p><p>基于指定分支创建新分支并切换到新分支:<br><code>git checkout -b &lt;baseBranch&gt; &lt;newBranch&gt;</code></p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>merge命令需要注意方向，是把指定分支代码合入本分支</p><p>合并指定分支到本分支:<br><code>git merge &lt;branchName&gt;</code></p><p>合并在合并完成后执行commit:<br><code>git merge &lt;branchName&gt; --commit</code></p><p>终止合并:<br><code>git merge --abort</code></p><p>合并冲突解决完毕：<br><code>git merge --continue</code><br>或者<br><code>git add .</code>和<code>git commit -m &quot;message&quot;</code></p><p>合并指定的两个分支：<br><code>git merge &lt;branchName1&gt; &lt;branchName2&gt;</code><br>指定合并<code>branchName1</code></p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>rebase命令注意方向，是把本分支变基到指定分支。<br>P.S.当本分支相对于指定分支有多个提交的话需要执行多次代码合并或解决冲突。而merge命令只需要执行一次。</p><p><code>git rebase &lt;branchName&gt;</code>可以把本分支变基到指定分支</p><p>终止变基:<br><code>git rebase --abort</code></p><p>变基冲突解决完毕:<br><code>git rebase --continue</code><br>不推荐用<code>git add .</code>和<code>git commit -m &quot;message&quot;</code>组合命令<br>如果这样做了可以用<code>git rebase --skip</code>结束rebase进程。</p><h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><p>作用：贮藏当前暂存区和工作区的内容。贮藏的内容是可以跨分支使用的。</p><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>贮藏当前修改<br><code>git stash</code></p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>列出当前贮藏的所有内容<br><code>git stash list</code></p><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>应用指定的stash到当前分支，如果不指定stash默认是最近的一个。<br><code>git stash apply [&lt;stash&gt;]</code></p><h3 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h3><p>移除指定的stash，如果不指定stash默认是最近的一个。<br><code>git stash drop [&lt;stash&gt;]</code></p><h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>应用指定的stash并移除，如果不指定stash默认是最近的一个。<br><code>git stash pop [&lt;stash&gt;]</code></p><h3 id="stash-branch"><a href="#stash-branch" class="headerlink" title="stash branch"></a>stash branch</h3><p>从贮藏创建一个新分支<br><code>git stash branch &lt;newBranchName&gt;</code></p><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>把暂存区的内容提交<br><code>git commit -m &quot;message&quot;</code></p><p>修正上次的commit，可以修改文件，提交信息等:<br><code>git commit --amend</code></p><h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h2><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><h2 id="pick"><a href="#pick" class="headerlink" title="pick"></a>pick</h2><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><h2 id="丢弃未暂存内容"><a href="#丢弃未暂存内容" class="headerlink" title="丢弃未暂存内容"></a>丢弃未暂存内容</h2><h2 id="推荐网站"><a href="#推荐网站" class="headerlink" title="推荐网站"></a>推荐网站</h2><p>廖雪峰<br>可视化</p><h2 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h2><p>idea sourcetree fork</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> git </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从点击桌面图标到启动app流程</title>
      <link href="/2019/12/29/Platform/Android/app_start/"/>
      <url>/2019/12/29/Platform/Android/app_start/</url>
      
        <content type="html"><![CDATA[<p>在智能手机的日常使用中，最常见的操作应该就是点击桌面图标然后打开对应app了，本文主要分析了在这个过程中系统做了什么事。</p><h1 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h1><ol><li>Android源码，Android可以下载源码到本地用source insight导入阅读，或者使用在线源码阅读工具，比如：<a href="http://androidxref.com/" target="_blank" rel="noopener">AndroidXRef</a>,<a href="https://cs.android.com/" target="_blank" rel="noopener">官方源码在线阅读工具</a>等。本文基于安卓源码<strong>android-6.0.1_r72</strong>版本分析。</li><li>Android设备，本文使用设备是Nexus 5，Android版本号是6.0.1。</li></ol><h2 id="桌面Activity"><a href="#桌面Activity" class="headerlink" title="桌面Activity"></a>桌面Activity</h2><p>系统桌面的源码在源码目录的<code>android-6.0.1_r72\packages\apps\Launcher3</code>下，查看该<code>Launcher3</code>目录下的<strong>AndroidManifest.xml</strong>发现其中只有<code>com.android.launcher3.Launcher</code>这个类包含了<code>&lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt;</code>标签。可以确定桌面Activity是<code>com.android.launcher3.Launcher</code></p><p>在实际设备中让设备处在桌面，然后执行</p><pre><code class="shell">adb shelldumpsys activity top |grep ACTIVITY</code></pre><p>可以得到当前的顶层Activity。<br>如图所示：<br><img src="/2019/12/29/Platform/Android/app_start/top_activity.png" alt="桌面Activity"></p><p>可以看到实际设备的桌面包名是<code>com.google.android.googlequicksearchbox</code>，实际桌面Activity是<code>com.google.android.launcher.GEL</code>。<br>接着使用<code>adb shell pm path com.google.android.googlequicksearchbox</code>命令可以看到桌面应用的apk所在位置。<br><img src="/2019/12/29/Platform/Android/app_start/pm_path.png" alt="launcher path"><br>反编译<code>Velvet.apk</code>这个包后发现<code>com.google.android.launcher.GEL</code>这个类实际也是继承自<code>com.android.launcher3.Launcher</code>，所以后续分析过程中还是以<code>com.android.launcher3.Launcher</code>为分析目标。</p><h2 id="Launcher-java"><a href="#Launcher-java" class="headerlink" title="Launcher.java"></a>Launcher.java</h2><p>首先，打开app的行为是在点击桌面图标后发生的，而且<strong>Launcher</strong>继承自<strong>Activity</strong>，所以先去看<strong>Launcher</strong>的<code>onClick(View v)</code>方法<br><code>Launcher.onClick(View v)</code>方法的代码如下：</p><pre><code class="java">        Object tag = v.getTag();        if (tag instanceof ShortcutInfo) {            //原生桌面点击app生成的快捷图标后调用            onClickAppShortcut(v);        } else if (tag instanceof FolderInfo) {            if (v instanceof FolderIcon) {                onClickFolderIcon(v);            }        } else if (v == mAllAppsButton) {            onClickAllAppsButton(v);        } else if (tag instanceof AppInfo) {            //原生桌面点击抽屉中的app图标后调用            startAppShortcutOrInfoActivity(v);        } else if (tag instanceof LauncherAppWidgetInfo) {            if (v instanceof PendingAppWidgetHostView) {                onClickPendingWidget((PendingAppWidgetHostView) v);            }        }</code></pre><p>可以看到，在<code>onClick</code>中判断了view 的tag，当点击的是桌面的应用快捷方式时，tag的类型是<code>ShortcutInfo</code>。当点击的是桌面的文件夹时，tag的类型是<code>FolderInfo</code>。当点击的是app图标时，tag的类型是<code>AppInfo</code>。</p><p>所以接下来跳到<code>Launcher</code>的<code>startAppShortcutOrInfoActivity(View v)</code>方法。可以看到，当tag是<code>ShortcutInfo</code>类型时，给intent设置了<code>SourceBounds</code>。当tag是<code>AppInfo</code>时，则不做操作，直接把intent传给<code>Launcher</code>的<code>startActivitySafely(View v,Intent intent,Object tag)</code>方法。</p><pre><code class="java">    @Thunk void startAppShortcutOrInfoActivity(View v) {        Object tag = v.getTag();        final ShortcutInfo shortcut;        final Intent intent;        if (tag instanceof ShortcutInfo) {            shortcut = (ShortcutInfo) tag;            intent = shortcut.intent;            int[] pos = new int[2];            v.getLocationOnScreen(pos);            intent.setSourceBounds(new Rect(pos[0], pos[1],                    pos[0] + v.getWidth(), pos[1] + v.getHeight()));        } else if (tag instanceof AppInfo) {            shortcut = null;            intent = ((AppInfo) tag).intent;        } else {            throw new IllegalArgumentException(&quot;Input must be a Shortcut or AppInfo&quot;);        }        boolean success = startActivitySafely(v, intent, tag);        mStats.recordLaunch(v, intent, shortcut);        if (success &amp;&amp; v instanceof BubbleTextView) {            mWaitingForResume = (BubbleTextView) v;            mWaitingForResume.setStayPressed(true);        }    }</code></pre><p>在<code>startActivitySafely(View v,Intent intent,Object tag)</code>方法中先判断了当前是否在安全模式，如果在安全模式下则不允许启动非系统应用。<br>通过判断后接着就调用了<code>Launcher</code>的<code>startActivity(View v,Intent intent,Object tag)</code>。<br><code>startActivitySafely(View v,Intent intent,Object tag)</code>的代码如下：</p><pre><code class="java">    public boolean startActivitySafely(View v, Intent intent, Object tag) {        boolean success = false;        //如果在安全模式下不允许启动非系统应用        if (mIsSafeModeEnabled &amp;&amp; !Utilities.isSystemApp(this, intent)) {            Toast.makeText(this, R.string.safemode_shortcut_error, Toast.LENGTH_SHORT).show();            return false;        }        try {            success = startActivity(v, intent, tag);        } catch (ActivityNotFoundException e) {            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();            Log.e(TAG, &quot;Unable to launch. tag=&quot; + tag + &quot; intent=&quot; + intent, e);        }        return success;    }</code></pre><pre><code class="java">private boolean startActivity(View v, Intent intent, Object tag) {        //第一步：为intent添加Intent.FLAG_ACTIVITY_NEW_TASK，当不存在和被启动activity相同的taskAffinity时，会新建一个任务栈来保存activity        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);        try {            // Only launch using the new animation if the shortcut has not opted out (this is a private contract between launcher and may be ignored in the future).            boolean useLaunchAnimation = (v != null) &amp;&amp;                    !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);            LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);            UserManagerCompat userManager = UserManagerCompat.getInstance(this);            //第二步：获取user            UserHandleCompat user = null;            if (intent.hasExtra(AppInfo.EXTRA_PROFILE)) {                long serialNumber = intent.getLongExtra(AppInfo.EXTRA_PROFILE, -1);                user = userManager.getUserForSerialNumber(serialNumber);            }            //第三步：构建动画            Bundle optsBundle = null;            if (useLaunchAnimation) {                ActivityOptions opts = null;                if (Utilities.ATLEAST_MARSHMALLOW) {                    int left = 0, top = 0;                    int width = v.getMeasuredWidth(), height = v.getMeasuredHeight();                    if (v instanceof TextView) {                        // Launch from center of icon, not entire view                        Drawable icon = Workspace.getTextViewIcon((TextView) v);                        if (icon != null) {                            Rect bounds = icon.getBounds();                            left = (width - bounds.width()) / 2;                            top = v.getPaddingTop();                            width = bounds.width();                            height = bounds.height();                        }                    }                    opts = ActivityOptions.makeClipRevealAnimation(v, left, top, width, height);                } else if (!Utilities.ATLEAST_LOLLIPOP) {                    // Below L, we use a scale up animation                    opts = ActivityOptions.makeScaleUpAnimation(v, 0, 0,                                    v.getMeasuredWidth(), v.getMeasuredHeight());                } else if (Utilities.ATLEAST_LOLLIPOP_MR1) {                    // On L devices, we use the device default slide-up transition.                    // On L MR1 devices, we a custom version of the slide-up transition which                    // doesn&#39;t have the delay present in the device default.                    opts = ActivityOptions.makeCustomAnimation(this,                            R.anim.task_open_enter, R.anim.no_anim);                }                optsBundle = opts != null ? opts.toBundle() : null;            }            //第四步：执行启动            if (user == null || user.equals(UserHandleCompat.myUserHandle())) {                // Could be launching some bookkeeping activity                startActivity(intent, optsBundle);            } else {                // TODO Component can be null when shortcuts are supported for secondary user                launcherApps.startActivityForProfile(intent.getComponent(), user,                        intent.getSourceBounds(), optsBundle);            }            return true;        } catch (SecurityException e) {            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();            Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +                    &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +                    &quot;or use the exported attribute for this activity. &quot;                    + &quot;tag=&quot;+ tag + &quot; intent=&quot; + intent, e);        }        return false;    }</code></pre><p>在<code>Launcher</code>的<code>startActivity(View v,Intent intent,Object tag)</code>中一共做了四件事。<br>第一件事是为<code>intent</code>添加一个<code>Intent.FLAG_ACTIVITY_NEW_TASK</code>。如果当前不存在和被启动activity相同taskAffinity的任务栈，那就会新建一个任务栈来存放新启动的activity。</p><p>第二件事是从<code>UserManagerCompat</code>的单例对象中获取对应的<code>UserHandleCompat</code>。<br>// todo 解释UserHandleCompat 和 UserManagerCompat</p><p>第三件事判断intent中是否包含<code>INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION</code>，如果包含就忽略动画。<br>如果不包含则默认需要播放动画，接着根据不同Android版本构建<code>ActivityOptions</code></p><p>第四件事，如果<code>user</code>和<code>new UserHandleCompat(android.os.Process.myUserHandle()</code>相同则调用<code>Activity</code>的<code>startActivity(Intent intent, @Nullable Bundle options)</code>。</p><h2 id="android-app-Activity-java"><a href="#android-app-Activity-java" class="headerlink" title="android.app.Activity.java"></a>android.app.Activity.java</h2><p>在Activity的<code>startActivity(Intent intent, Bundle options)</code>中，因为options非空，会调用<code>Activity</code>的<code>startActivityForResult(Intent intent, int requestCode, Bundle options)</code>。中间的requestCode默认传了-1，表示不关心返回结果</p><p>在<code>Activity</code>的<code>startActivityForResult(Intent intent, int requestCode, Bundle options)</code>中首先判断了<code>mParent</code>是否为空，当<code>mParent</code>为空时，由<code>Instrumentation</code>来执行启动操作，如果<code>mParent</code>不为空，则由<code>mParent</code>来执行启动操作。<code>startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options)</code>的代码如下：</p><pre><code class="java">public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) {        if (mParent == null) {            //当mParent为空时由mInstrumentation继续处理启动流程            Instrumentation.ActivityResult ar =                mInstrumentation.execStartActivity(                    this, mMainThread.getApplicationThread(), mToken, this,                    intent, requestCode, options);            if (ar != null) {                mMainThread.sendActivityResult(                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),                    ar.getResultData());            }            if (requestCode &gt;= 0) {                mStartedActivity = true;            }            cancelInputsAndStartExitTransition(options);        } else {            if (options != null) {                mParent.startActivityFromChild(this, intent, requestCode, options);            } else {                mParent.startActivityFromChild(this, intent, requestCode);            }        }    }</code></pre><p>这里的<code>mParent</code>为空，所以调用了<code>Instrumentation</code>的<code>ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target,Intent intent, int requestCode, Bundle options)</code>方法，方法很长，一共传了7个参数。分别是：</p><ul><li><code>Context who</code>：</li></ul><blockquote><p>The Context from which the activity is being started.</p></blockquote><p>启动activity操作的来源Context，可以直接认为是<code>startActivity()</code>的调用者。<br>这里传入的就是<code>com.google.android.launcher.GEL</code>自身</p><ul><li><code>IBinder contextThread</code>：</li></ul><blockquote><p>The main thread of the Context from which the activity is being started.</p></blockquote><p>启动activity的Context的主线程。<br>这里用<code>mMainThread.getApplicationThread()</code>获取了<code>ActivityThread</code>中保存的<code>ApplicationThread</code></p><ul><li><code>IBinder token</code>：</li></ul><blockquote><p>Internal token identifying to the system who is starting the activity; may be null.</p></blockquote><p>为系统标识当前正在启动activity的是谁。可能为空。<br>这里传递了当前<code>com.google.android.launcher.GEL</code>的<code>mToken</code>，用来标识当前是<code>com.google.android.launcher.GEL</code>正在启动activity。</p><ul><li><code>Activity target</code>：</li></ul><blockquote><p>Which activity is performing the start (and thus receiving any result); may be null if this call is not being made from an activity.</p></blockquote><p>正在执行Activity启动操作的Activity。如果不是从一个Activity发起的启动操作，该项可能为空。<br>这里传入的也是<code>com.google.android.launcher.GEL</code>自身</p><ul><li><code>Intent intent</code>：</li></ul><blockquote><p>The actual Intent to start.</p></blockquote><p>启动的实际Intent。</p><ul><li><code>int requestCode</code>：</li></ul><blockquote><p>Identifier for this request’s result; less than zero if the caller is not expecting a result.</p></blockquote><p>请求结果的标识，如果调用者不关注结果则传入负值。<br>这里传入的是-1</p><ul><li><code>Bundle options</code></li></ul><blockquote><p>Addition options</p></blockquote><p>附加选项<br>这里传入的是调用<code>startActivity</code>时传入的options</p><p><code>Instrumentation</code>的<code>execStartActivity</code>方法代码如下：</p><pre><code class="java">public ActivityResult execStartActivity(            Context who, IBinder contextThread, IBinder token, Activity target,            Intent intent, int requestCode, Bundle options) {        IApplicationThread whoThread = (IApplicationThread) contextThread;        Uri referrer = target != null ? target.onProvideReferrer() : null;        if (referrer != null) {            intent.putExtra(Intent.EXTRA_REFERRER, referrer);        }        if (mActivityMonitors != null) {            synchronized (mSync) {                final int N = mActivityMonitors.size();                for (int i=0; i&lt;N; i++) {                    final ActivityMonitor am = mActivityMonitors.get(i);                    if (am.match(who, null, intent)) {                        am.mHits++;                        if (am.isBlocking()) {                            return requestCode &gt;= 0 ? am.getResult() : null;                        }                        break;                    }                }            }        }        try {            intent.migrateExtraStreamToClipData();            intent.prepareToLeaveProcess();            int result = ActivityManagerNative.getDefault()                .startActivity(whoThread, who.getBasePackageName(), intent,                        intent.resolveTypeIfNeeded(who.getContentResolver()),                        token, target != null ? target.mEmbeddedID : null,                        requestCode, 0, null, options);            checkStartActivityResult(result, intent);        } catch (RemoteException e) {            throw new RuntimeException(&quot;Failure from system&quot;, e);        }        return null;    }</code></pre><p>这里可以看到第一步是先从<strong>target</strong>中获取<strong>referrer</strong>，在<code>Activity</code>的<code>onProvideReferrer()</code>方法中默认是直接返回null的。如果这里的<strong>target</strong>是继承了<code>Activity</code>的子类并重写了<code>onProvideReferrer()</code>方法，那么就能从中获取到<code>Uri</code>了。</p><p>接下来的<code>mActivityMonitors</code>相关的内容是与<code>InstrumentationTestCases</code>测试相关的。在这里不多加讨论。<br>启动相关的内容在后续的<code>try-catch</code>块中。<br>首先调用<code>Intent</code>的<code>migrateExtraStreamToClipData</code>方法将<strong>intent</strong>中的<strong>extra</strong>数据序列化传递给目标进程。<br>然后调用<code>Intent</code>的<code>prepareToLeaveProcess</code>方法做好离开当前线程的准备。<br>接下来就是调用<code>ActivityManagerNative.getDefault()</code>得到了一个<strong>android.app.ActivityManagerProxy</strong>对象。</p><p>先来看看<code>getDefault()</code>方法是怎么获取到这个<code>ActivityManagerProxy</code>对象的。<br>在<code>ActivityManagerNative.getDefault()</code>中只有一行代码。</p><pre><code class="java">    static public IActivityManager getDefault() {        return gDefault.get();    }</code></pre><p>这里的<strong>gDefault</strong>实际上是定义在<strong>ActivityManagerNative</strong>中的静态变量，具体类型如下：</p><pre><code class="java">    private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() {        protected IActivityManager create() {            IBinder b = ServiceManager.getService(&quot;activity&quot;);            if (false) {                Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b);            }            IActivityManager am = asInterface(b);            if (false) {                Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am);            }            return am;        }    };</code></pre><p>可以看到<strong>gDefault</strong>就是一个实现了IActivityManager接口的<code>ActivityManagerProxy</code>对象。<br>所以实际上这里是调用了<code>ActivityManagerProxy</code>的<code>startActivity</code>方法。</p><pre><code class="Java"> public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,            String resolvedType, IBinder resultTo, String resultWho, int requestCode,            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {        Parcel data = Parcel.obtain();        Parcel reply = Parcel.obtain();        data.writeInterfaceToken(IActivityManager.descriptor);        data.writeStrongBinder(caller != null ? caller.asBinder() : null);        data.writeString(callingPackage);        intent.writeToParcel(data, 0);        data.writeString(resolvedType);        data.writeStrongBinder(resultTo);        data.writeString(resultWho);        data.writeInt(requestCode);        data.writeInt(startFlags);        if (profilerInfo != null) {            data.writeInt(1);            profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);        } else {            data.writeInt(0);        }        if (options != null) {            data.writeInt(1);            options.writeToParcel(data, 0);        } else {            data.writeInt(0);        }        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);        reply.readException();        int result = reply.readInt();        reply.recycle();        data.recycle();        return result;    }</code></pre><p>在这里通过AIDL将startActivity任务交给了远端服务器执行。所以会跳转到<code>ActivityManagreNative</code>的<code>onTransact</code>方法。</p><pre><code class="Java">    @Override    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)            throws RemoteException {        switch (code) {            case START_ACTIVITY_TRANSACTION:            {                data.enforceInterface(IActivityManager.descriptor);                IBinder b = data.readStrongBinder();                IApplicationThread app = ApplicationThreadNative.asInterface(b);                String callingPackage = data.readString();                Intent intent = Intent.CREATOR.createFromParcel(data);                String resolvedType = data.readString();                IBinder resultTo = data.readStrongBinder();                String resultWho = data.readString();                int requestCode = data.readInt();                int startFlags = data.readInt();                ProfilerInfo profilerInfo = data.readInt() != 0                        ? ProfilerInfo.CREATOR.createFromParcel(data) : null;                Bundle options = data.readInt() != 0                        ? Bundle.CREATOR.createFromParcel(data) : null;                int result = startActivity(app, callingPackage, intent, resolvedType,                        resultTo, resultWho, requestCode, startFlags, profilerInfo, options);                reply.writeNoException();                reply.writeInt(result);                return true;            }        }    }</code></pre><p>在服务端会调用到<code>ActivityManagerService</code>(以下简称<code>AMS</code>)的<code>startActivity</code>方法，然后又会调用到<code>AMS</code>的<code>startActivityAsUser</code>方法。<br>然后在<code>AMS</code>的<code>startActivityAsUser</code>会调用<code>ActivityStackSupervisor</code>的<code>startActivityMayWait</code>方法。<br>从<code>ActivityStackSupervisor</code>类名可以看出，这个类承担了Activity栈管理者的作用。</p><pre><code class="Java">    public final int startActivity(IApplicationThread caller, String callingPackage,            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,            int startFlags, ProfilerInfo profilerInfo, Bundle options) {        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,            resultWho, requestCode, startFlags, profilerInfo, options,            UserHandle.getCallingUserId());    }</code></pre><pre><code class="Java">    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {        enforceNotIsolatedCaller(&quot;startActivity&quot;);        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,                false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);        // Switch to user app stacks here.        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,                profilerInfo, null, null, options, false, userId, null, null);    }</code></pre><pre><code class="Java">final int startActivityMayWait(IApplicationThread caller, int callingUid,            String callingPackage, Intent intent, String resolvedType,            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,            IBinder resultTo, String resultWho, int requestCode, int startFlags,            ProfilerInfo profilerInfo, WaitResult outResult, Configuration config,            Bundle options, boolean ignoreTargetSecurity, int userId,            IActivityContainer iContainer, TaskRecord inTask) {        // Refuse possible leaked file descriptors        // Intent不能包含文件描述符        if (intent != null &amp;&amp; intent.hasFileDescriptors()) {            throw new IllegalArgumentException(&quot;File descriptors passed in Intent&quot;);        }        boolean componentSpecified = intent.getComponent() != null;        // Don&#39;t modify the client&#39;s object!        // 不对原Intent修改        intent = new Intent(intent);        // Collect information about the target of the Intent.        // 得到目标启动Activity的信息        ActivityInfo aInfo =                resolveActivity(intent, resolvedType, startFlags, profilerInfo, userId);        ActivityContainer container = (ActivityContainer)iContainer;        synchronized (mService) {            if (container != null &amp;&amp; container.mParentActivity != null &amp;&amp;                    container.mParentActivity.state != RESUMED) {                // Cannot start a child activity if the parent is not resumed.                return ActivityManager.START_CANCELED;            }            final int realCallingPid = Binder.getCallingPid();            final int realCallingUid = Binder.getCallingUid();            int callingPid;            if (callingUid &gt;= 0) {                callingPid = -1;            } else if (caller == null) {                callingPid = realCallingPid;                callingUid = realCallingUid;            } else {                callingPid = callingUid = -1;            }            final ActivityStack stack;            if (container == null || container.mStack.isOnHomeDisplay()) {                stack = mFocusedStack;            } else {                stack = container.mStack;            }            stack.mConfigWillChange = config != null &amp;&amp; mService.mConfiguration.diff(config) != 0;            if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,                    &quot;Starting activity when config will change = &quot; + stack.mConfigWillChange);            final long origId = Binder.clearCallingIdentity();            if (aInfo != null &amp;&amp;                    (aInfo.applicationInfo.privateFlags                            &amp;ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) {                // This may be a heavy-weight process!  Check to see if we already                // have another, different heavy-weight process running.                if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) {                    if (mService.mHeavyWeightProcess != null &amp;&amp;                            (mService.mHeavyWeightProcess.info.uid != aInfo.applicationInfo.uid ||                            !mService.mHeavyWeightProcess.processName.equals(aInfo.processName))) {                        int appCallingUid = callingUid;                        if (caller != null) {                            //通过调用者的ApplicationThread从最近使用中获取对应的ProcessRecord                            ProcessRecord callerApp = mService.getRecordForAppLocked(caller);                            if (callerApp != null) {                                appCallingUid = callerApp.info.uid;                            } else {                                Slog.w(TAG, &quot;Unable to find app for caller &quot; + caller                                      + &quot; (pid=&quot; + callingPid + &quot;) when starting: &quot;                                      + intent.toString());                                //找不到调用者无法启动Activity                                ActivityOptions.abort(options);                                return ActivityManager.START_PERMISSION_DENIED;                            }                        }                        //获取对应的PendingIntentRecord                        IIntentSender target = mService.getIntentSenderLocked(                                ActivityManager.INTENT_SENDER_ACTIVITY, &quot;android&quot;,                                appCallingUid, userId, null, null, 0, new Intent[] { intent },                                new String[] { resolvedType }, PendingIntent.FLAG_CANCEL_CURRENT                                | PendingIntent.FLAG_ONE_SHOT, null);                        Intent newIntent = new Intent();                        if (requestCode &gt;= 0) {                            // Caller is requesting a result.                            //需要Activity启动结果的需要添加HeavyWeightSwitcherActivity.KEY_HAS_RESULT                            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_HAS_RESULT, true);                        }                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_INTENT,                                new IntentSender(target));                        //mHeavyWeightProcess中正在运行Activity，添加信息到newIntent中                        if (mService.mHeavyWeightProcess.activities.size() &gt; 0) {                            ActivityRecord hist = mService.mHeavyWeightProcess.activities.get(0);                            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_APP,                                    hist.packageName);                            newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_TASK,                                    hist.task.taskId);                        }                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_NEW_APP,                                aInfo.packageName);                        newIntent.setFlags(intent.getFlags());                        newIntent.setClassName(&quot;android&quot;,                                HeavyWeightSwitcherActivity.class.getName());                        //修改intent为新intent                        intent = newIntent;                        resolvedType = null;                        caller = null;                        callingUid = Binder.getCallingUid();                        callingPid = Binder.getCallingPid();                        componentSpecified = true;                        try {                            ResolveInfo rInfo =                                AppGlobals.getPackageManager().resolveIntent(                                        intent, null,                                        PackageManager.MATCH_DEFAULT_ONLY                                        | ActivityManagerService.STOCK_PM_FLAGS, userId);                            aInfo = rInfo != null ? rInfo.activityInfo : null;                            aInfo = mService.getActivityInfoForUser(aInfo, userId);                        } catch (RemoteException e) {                            aInfo = null;                        }                    }                }            }            int res = startActivityLocked(caller, intent, resolvedType, aInfo,                    voiceSession, voiceInteractor, resultTo, resultWho,                    requestCode, callingPid, callingUid, callingPackage,                    realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity,                    componentSpecified, null, container, inTask);            Binder.restoreCallingIdentity(origId);            if (stack.mConfigWillChange) {                // If the caller also wants to switch to a new configuration,                // do so now.  This allows a clean switch, as we are waiting                // for the current activity to pause (so we will not destroy                // it), and have not yet started the next activity.                mService.enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,                        &quot;updateConfiguration()&quot;);                stack.mConfigWillChange = false;                if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,                        &quot;Updating to new configuration after starting activity.&quot;);                mService.updateConfigurationLocked(config, null, false, false);            }            if (outResult != null) {                outResult.result = res;                if (res == ActivityManager.START_SUCCESS) {                    mWaitingActivityLaunched.add(outResult);                    do {                        try {                            mService.wait();                        } catch (InterruptedException e) {                        }                    } while (!outResult.timeout &amp;&amp; outResult.who == null);                } else if (res == ActivityManager.START_TASK_TO_FRONT) {                    ActivityRecord r = stack.topRunningActivityLocked(null);                    if (r.nowVisible &amp;&amp; r.state == RESUMED) {                        outResult.timeout = false;                        outResult.who = new ComponentName(r.info.packageName, r.info.name);                        outResult.totalTime = 0;                        outResult.thisTime = 0;                    } else {                        outResult.thisTime = SystemClock.uptimeMillis();                        mWaitingActivityVisible.add(outResult);                        do {                            try {                                mService.wait();                            } catch (InterruptedException e) {                            }                        } while (!outResult.timeout &amp;&amp; outResult.who == null);                    }                }            }            return res;        }    }</code></pre><p><code>startActivityMayWait</code>方法内包含了获取启动信息的逻辑。经过一系列处理后调用了<code>ActivityStackSupervisor</code>的<code>startActivityLocked</code>方法</p><pre><code class="Java">//frameworks\base\services\core\java\com\android\server\am\ActivityStackSupervisor.javafinal int startActivityLocked(IApplicationThread caller,            Intent intent, String resolvedType, ActivityInfo aInfo,            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,            IBinder resultTo, String resultWho, int requestCode,            int callingPid, int callingUid, String callingPackage,            int realCallingPid, int realCallingUid, int startFlags, Bundle options,            boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity,            ActivityContainer container, TaskRecord inTask) {        int err = ActivityManager.START_SUCCESS;        ProcessRecord callerApp = null;        if (caller != null) {            //通过调用者的ApplicationThread从最近任务中获取对应的ProcessRecord            callerApp = mService.getRecordForAppLocked(caller);            if (callerApp != null) {                callingPid = callerApp.pid;                callingUid = callerApp.info.uid;            } else {                Slog.w(TAG, &quot;Unable to find app for caller &quot; + caller                      + &quot; (pid=&quot; + callingPid + &quot;) when starting: &quot;                      + intent.toString());                err = ActivityManager.START_PERMISSION_DENIED;            }        }        final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0;        if (err == ActivityManager.START_SUCCESS) {            Slog.i(TAG, &quot;START u&quot; + userId + &quot; {&quot; + intent.toShortString(true, true, true, false)                    + &quot;} from uid &quot; + callingUid                    + &quot; on display &quot; + (container == null ? (mFocusedStack == null ?                            Display.DEFAULT_DISPLAY : mFocusedStack.mDisplayId) :                            (container.mActivityDisplay == null ? Display.DEFAULT_DISPLAY :                                    container.mActivityDisplay.mDisplayId)));        }        ActivityRecord sourceRecord = null;        ActivityRecord resultRecord = null;        if (resultTo != null) {            //通过接收启动结果的token查找对应的ActivityRecord            sourceRecord = isInAnyStackLocked(resultTo);            if (DEBUG_RESULTS) Slog.v(TAG_RESULTS,                    &quot;Will send result to &quot; + resultTo + &quot; &quot; + sourceRecord);            if (sourceRecord != null) {                if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) {                    resultRecord = sourceRecord;                }            }        }        final int launchFlags = intent.getFlags();        //Intent.FLAG_ACTIVITY_FORWARD_RESULT标识从ActivityA启动ActivityB或更多层跳转启动了ActivityZ        //在这种情况下启动的结果应该返回给ActivityA，而不是中间过度Activity。        if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) {            // Transfer the result target from the source activity to the new            // one being started, including any failures.            if (requestCode &gt;= 0) {                //这种情况下不允许中间过渡页设置requestCode &gt;= 0                ActivityOptions.abort(options);                return ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;            }            resultRecord = sourceRecord.resultTo;            if (resultRecord != null &amp;&amp; !resultRecord.isInStackLocked()) {                resultRecord = null;            }            //指定返回结果给上层同样的对象，层层转发            resultWho = sourceRecord.resultWho;            requestCode = sourceRecord.requestCode;            sourceRecord.resultTo = null;            if (resultRecord != null) {                resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);            }            if (sourceRecord.launchedFromUid == callingUid) {                // The new activity is being launched from the same uid as the previous                // activity in the flow, and asking to forward its result back to the                // previous.  In this case the activity is serving as a trampoline between                // the two, so we also want to update its launchedFromPackage to be the                // same as the previous activity.  Note that this is safe, since we know                // these two packages come from the same uid; the caller could just as                // well have supplied that same package name itself.  This specifially                // deals with the case of an intent picker/chooser being launched in the app                // flow to redirect to an activity picked by the user, where we want the final                // activity to consider it to have been launched by the previous app activity.                callingPackage = sourceRecord.launchedFromPackage;            }        }        if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) {            // We couldn&#39;t find a class that can handle the given Intent.            // That&#39;s the end of that!            err = ActivityManager.START_INTENT_NOT_RESOLVED;        }        if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) {            // We couldn&#39;t find the specific class specified in the Intent.            // Also the end of the line.            err = ActivityManager.START_CLASS_NOT_FOUND;        }        if (err == ActivityManager.START_SUCCESS                &amp;&amp; !isCurrentProfileLocked(userId)                &amp;&amp; (aInfo.flags &amp; FLAG_SHOW_FOR_ALL_USERS) == 0) {            // Trying to launch a background activity that doesn&#39;t show for all users.            err = ActivityManager.START_NOT_CURRENT_USER_ACTIVITY;        }        if (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != null                &amp;&amp; sourceRecord.task.voiceSession != null) {            // If this activity is being launched as part of a voice session, we need            // to ensure that it is safe to do so.  If the upcoming activity will also            // be part of the voice session, we can only launch it if it has explicitly            // said it supports the VOICE category, or it is a part of the calling app.            if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == 0                    &amp;&amp; sourceRecord.info.applicationInfo.uid != aInfo.applicationInfo.uid) {                try {                    intent.addCategory(Intent.CATEGORY_VOICE);                    if (!AppGlobals.getPackageManager().activitySupportsIntent(                            intent.getComponent(), intent, resolvedType)) {                        Slog.w(TAG,                                &quot;Activity being started in current voice task does not support voice: &quot;                                + intent);                        err = ActivityManager.START_NOT_VOICE_COMPATIBLE;                    }                } catch (RemoteException e) {                    Slog.w(TAG, &quot;Failure checking voice capabilities&quot;, e);                    err = ActivityManager.START_NOT_VOICE_COMPATIBLE;                }            }        }        if (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != null) {            // If the caller is starting a new voice session, just make sure the target            // is actually allowing it to run this way.            try {                if (!AppGlobals.getPackageManager().activitySupportsIntent(intent.getComponent(),                        intent, resolvedType)) {                    Slog.w(TAG,                            &quot;Activity being started in new voice task does not support: &quot;                            + intent);                    err = ActivityManager.START_NOT_VOICE_COMPATIBLE;                }            } catch (RemoteException e) {                Slog.w(TAG, &quot;Failure checking voice capabilities&quot;, e);                err = ActivityManager.START_NOT_VOICE_COMPATIBLE;            }        }        final ActivityStack resultStack = resultRecord == null ? null : resultRecord.task.stack;        if (err != ActivityManager.START_SUCCESS) {            if (resultRecord != null) {                resultStack.sendActivityResultLocked(-1,                    resultRecord, resultWho, requestCode,                    Activity.RESULT_CANCELED, null);            }            ActivityOptions.abort(options);            return err;        }        boolean abort = false;        //检查是否具有启动权限        final int startAnyPerm = mService.checkPermission(                START_ANY_ACTIVITY, callingPid, callingUid);        if (startAnyPerm != PERMISSION_GRANTED) {            final int componentRestriction = getComponentRestrictionForCallingPackage(                    aInfo, callingPackage, callingPid, callingUid, ignoreTargetSecurity);            final int actionRestriction = getActionRestrictionForCallingPackage(                    intent.getAction(), callingPackage, callingPid, callingUid);            if (componentRestriction == ACTIVITY_RESTRICTION_PERMISSION                    || actionRestriction == ACTIVITY_RESTRICTION_PERMISSION) {                if (resultRecord != null) {                    resultStack.sendActivityResultLocked(-1,                            resultRecord, resultWho, requestCode,                            Activity.RESULT_CANCELED, null);                }                String msg;                if (actionRestriction == ACTIVITY_RESTRICTION_PERMISSION) {                    msg = &quot;Permission Denial: starting &quot; + intent.toString()                            + &quot; from &quot; + callerApp + &quot; (pid=&quot; + callingPid                            + &quot;, uid=&quot; + callingUid + &quot;)&quot; + &quot; with revoked permission &quot;                            + ACTION_TO_RUNTIME_PERMISSION.get(intent.getAction());                } else if (!aInfo.exported) {                    msg = &quot;Permission Denial: starting &quot; + intent.toString()                            + &quot; from &quot; + callerApp + &quot; (pid=&quot; + callingPid                            + &quot;, uid=&quot; + callingUid + &quot;)&quot;                            + &quot; not exported from uid &quot; + aInfo.applicationInfo.uid;                } else {                    msg = &quot;Permission Denial: starting &quot; + intent.toString()                            + &quot; from &quot; + callerApp + &quot; (pid=&quot; + callingPid                            + &quot;, uid=&quot; + callingUid + &quot;)&quot;                            + &quot; requires &quot; + aInfo.permission;                }                Slog.w(TAG, msg);                throw new SecurityException(msg);            }            if (actionRestriction == ACTIVITY_RESTRICTION_APPOP) {                String message = &quot;Appop Denial: starting &quot; + intent.toString()                        + &quot; from &quot; + callerApp + &quot; (pid=&quot; + callingPid                        + &quot;, uid=&quot; + callingUid + &quot;)&quot;                        + &quot; requires &quot; + AppOpsManager.permissionToOp(                                ACTION_TO_RUNTIME_PERMISSION.get(intent.getAction()));                Slog.w(TAG, message);                abort = true;            } else if (componentRestriction == ACTIVITY_RESTRICTION_APPOP) {                String message = &quot;Appop Denial: starting &quot; + intent.toString()                        + &quot; from &quot; + callerApp + &quot; (pid=&quot; + callingPid                        + &quot;, uid=&quot; + callingUid + &quot;)&quot;                        + &quot; requires appop &quot; + AppOpsManager.permissionToOp(aInfo.permission);                Slog.w(TAG, message);                abort = true;            }        }        abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,                callingPid, resolvedType, aInfo.applicationInfo);        if (mService.mController != null) {            try {                // The Intent we give to the watcher has the extra data                // stripped off, since it can contain private information.                Intent watchIntent = intent.cloneFilter();                abort |= !mService.mController.activityStarting(watchIntent,                        aInfo.applicationInfo.packageName);            } catch (RemoteException e) {                mService.mController = null;            }        }        if (abort) {            if (resultRecord != null) {                resultStack.sendActivityResultLocked(-1, resultRecord, resultWho, requestCode,                        Activity.RESULT_CANCELED, null);            }            // We pretend to the caller that it was really started, but            // they will just get a cancel result.            ActivityOptions.abort(options);            return ActivityManager.START_SUCCESS;        }        ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,                intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,                requestCode, componentSpecified, voiceSession != null, this, container, options);        if (outActivity != null) {            outActivity[0] = r;        }        if (r.appTimeTracker == null &amp;&amp; sourceRecord != null) {            // If the caller didn&#39;t specify an explicit time tracker, we want to continue            // tracking under any it has.            r.appTimeTracker = sourceRecord.appTimeTracker;        }        final ActivityStack stack = mFocusedStack;        if (voiceSession == null &amp;&amp; (stack.mResumedActivity == null                || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) {                //当前stack中没有resume状态的Activity或者和发起者的uid不同            if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,                    realCallingPid, realCallingUid, &quot;Activity start&quot;)) {                PendingActivityLaunch pal =                        new PendingActivityLaunch(r, sourceRecord, startFlags, stack);                mPendingActivityLaunches.add(pal);                ActivityOptions.abort(options);                return ActivityManager.START_SWITCHES_CANCELED;            }        }        //是否已经完成了应用选择        if (mService.mDidAppSwitch) {            // This is the second allowed switch since we stopped switches,            // so now just generally allow switches.  Use case: user presses            // home (switches disabled, switch to home, mDidAppSwitch now true);            // user taps a home icon (coming from home so allowed, we hit here            // and now allow anyone to switch again).            //已经完成应用选择，可以随意切换应用了            mService.mAppSwitchesAllowedTime = 0;        } else {            mService.mDidAppSwitch = true;        }        //启动挂起的应用        doPendingActivityLaunchesLocked(false);        //启动目标应用        err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,                startFlags, true, options, inTask);        if (err &lt; 0) {            // If someone asked to have the keyguard dismissed on the next            // activity start, but we are not actually doing an activity            // switch...  just dismiss the keyguard now, because we            // probably want to see whatever is behind it.            notifyActivityDrawnForKeyguard();        }        return err;    }</code></pre><p>在<code>startActivityLocked</code>方法中最后调用了<code>startActivityUncheckedLocked</code>方法。<br><code>startActivityUncheckedLocked</code>方法内容太长，不方便完整贴出来，只贴部分代码</p><pre><code class="Java"></code></pre><p>在这个方法中主要做了：</p><ul><li>检查Intent是否设置Intent.FLAG_ACTIVITY_NO_USER_ACTION标志</li><li>检查Intent是否设置Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP标志</li><li>检查Intent是否设置ActivityManager.START_FLAG_ONLY_IF_NEEDED标志</li><li>判断是否需要为目的Activity分配新的task，并判断是否有可复用的task。</li><li>为目的Activity设置task，并根据目的Activity的launchmode调整该Task中的Activity。</li><li>方法接着调用了ActivityStack的startActivityLocked方法。</li></ul><p>接着就进入到<code>ActivityStack</code>的<code>startAcivityLocked</code>方法</p><pre><code class="Java">//frameworks\base\services\core\java\com\android\server\am\ActivityStack.javafinal void startActivityLocked(ActivityRecord r, boolean newTask,            boolean doResume, boolean keepCurTransition, Bundle options) {        //目标task信息        TaskRecord rTask = r.task;        final int taskId = rTask.taskId;        // mLaunchTaskBehind tasks get placed at the back of the task stack.        if (!r.mLaunchTaskBehind &amp;&amp; (taskForIdLocked(taskId) == null || newTask)) {            // Last activity in task had been removed or ActivityManagerService is reusing task.            // Insert or replace.            // Might not even be in.            //如果原来不存在该task，则插入            insertTaskAtTop(rTask, r);            //并且切换到前台            mWindowManager.moveTaskToTop(taskId);        }        TaskRecord task = null;        //newTask为false表示当前栈中已有对应任务，不需要重新创建        if (!newTask) {            // If starting in an existing task, find where that is...            //这是一个已经存在的任务，在历史列表里查找它            boolean startIt = true;            for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) {                task = mTaskHistory.get(taskNdx);                if (task.getTopActivity() == null) {                    // All activities in task are finishing.                    continue;                }                if (task == r.task) {                    // Here it is!  Now, if this is not yet visible to the                    // user, then just add it without starting; it will                    // get started when the user navigates back to it.                    // 找到对应的task, 如果当前对用户不可见则只是添加但不启动直到用户跳转到这里                    if (!startIt) {                        if (DEBUG_ADD_REMOVE) Slog.i(TAG, &quot;Adding activity &quot; + r + &quot; to task &quot;                                + task, new RuntimeException(&quot;here&quot;).fillInStackTrace());                        //task栈中添加r到顶部                        task.addActivityToTop(r);                        r.putInHistory();                        //如果WindowManagerService的mTokenMap中不包含对应的AppWindowToken的话就创建一个                        mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,                                r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,                                (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != 0,                                r.userId, r.info.configChanges, task.voiceSession != null,                                r.mLaunchTaskBehind);                        if (VALIDATE_TOKENS) {                            validateAppTokensLocked();                        }                        ActivityOptions.abort(options);                        return;                    }                    break;                } else if (task.numFullscreen &gt; 0) {                    startIt = false;                }            }        }        //替换栈顶的Activity，用户才可以交互        // Place a new activity at top of stack, so it is next to interact        // with the user.        // If we are not placing the new activity frontmost, we do not want        // to deliver the onUserLeaving callback to the actual frontmost        // activity        //如果没有把Activity放到前台，则不会分发onUserLeaving回调给实际的前台Activity        if (task == r.task &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) {            //当前最上层的task不是启动的Activity所在的task            mStackSupervisor.mUserLeaving = false;            if (DEBUG_USER_LEAVING) Slog.v(TAG_USER_LEAVING,                    &quot;startActivity() behind front, mUserLeaving=false&quot;);        }        task = r.task;        // Slot the activity into the history stack and proceed        if (DEBUG_ADD_REMOVE) Slog.i(TAG, &quot;Adding activity &quot; + r + &quot; to stack to task &quot; + task,                new RuntimeException(&quot;here&quot;).fillInStackTrace());        //把ActivityRecord放到顶层        task.addActivityToTop(r);        //设置ActivityRecord的frontOfTask为true        task.setFrontOfTask();        r.putInHistory();        if (!isHomeStack() || numActivities() &gt; 0) {            //启动Activity的栈不在桌面应用栈中，并且当前已经有启动过的Activity            // We want to show the starting preview window if we are            // switching to a new task, or the next activity&#39;s process is            // not currently running.            //将启动一个预览窗口，如果这要跳转到一个新的task或者下一个Activity所在的进程不处于运行状态            boolean showStartingIcon = newTask;            ProcessRecord proc = r.app;            if (proc == null) {                proc = mService.mProcessNames.get(r.processName, r.info.applicationInfo.uid);            }            if (proc == null || proc.thread == null) {                showStartingIcon = true;            }            if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,                    &quot;Prepare open transition: starting &quot; + r);            if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {                //Intent配置了切换无效果                mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, keepCurTransition);                mNoAnimActivities.add(r);            } else {                mWindowManager.prepareAppTransition(newTask                        ? r.mLaunchTaskBehind                                ? AppTransition.TRANSIT_TASK_OPEN_BEHIND                                : AppTransition.TRANSIT_TASK_OPEN                        : AppTransition.TRANSIT_ACTIVITY_OPEN, keepCurTransition);                mNoAnimActivities.remove(r);            }            mWindowManager.addAppToken(task.mActivities.indexOf(r),                    r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,                    (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId,                    r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind);            boolean doShow = true;            if (newTask) {                // Even though this activity is starting fresh, we still need                // to reset it to make sure we apply affinities to move any                // existing activities from other tasks in to it.                // If the caller has requested that the target task be                // reset, then do so.                // 即使Activity已经启动了，仍然需要reset保证使用了affinity，在一个新的任务栈启动                if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {                    //重置task                    resetTaskIfNeededLocked(r, r);                    //判断重置task后顶层Activity是否就是需要启动的Activity                    doShow = topRunningNonDelayedActivityLocked(null) == r;                }            } else if (options != null &amp;&amp; new ActivityOptions(options).getAnimationType()                    == ActivityOptions.ANIM_SCENE_TRANSITION) {                doShow = false;            }            if (r.mLaunchTaskBehind) {                //表示热启动，不需要启动界面，即使当前仍然处于栈下部还是告诉WindowManager已经可见了                // Don&#39;t do a starting window for mLaunchTaskBehind. More importantly make sure we                // tell WindowManager that r is visible even though it is at the back of the stack.                mWindowManager.setAppVisibility(r.appToken, true);                ensureActivitiesVisibleLocked(null, 0);            } else if (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) {                // Figure out if we are transitioning from another activity that is                // &quot;has the same starting icon&quot; as the next one.  This allows the                // window manager to keep the previous window it had previously                // created, if it still had one.                ActivityRecord prev = mResumedActivity;                if (prev != null) {                    //在两种情况下不会复用之前的启动预览：                    //1. 当前Activity处在不同任务                    //2. 当前Activity已展示                    // We don&#39;t want to reuse the previous starting preview if:                    // (1) The current activity is in a different task.                    if (prev.task != r.task) {                        prev = null;                    }                    // (2) The current activity is already displayed.                    else if (prev.nowVisible) {                        prev = null;                    }                }                //为启动的Activity设置启动窗口                mWindowManager.setAppStartingWindow(                        r.appToken, r.packageName, r.theme,                        mService.compatibilityInfoForPackageLocked(                                r.info.applicationInfo), r.nonLocalizedLabel,                        r.labelRes, r.icon, r.logo, r.windowFlags,                        prev != null ? prev.appToken : null, showStartingIcon);                r.mStartingWindowShown = true;            }        } else {            // If this is the first activity, don&#39;t do any fancy animations,            // because there is nothing for it to animate on top of.            //如果这是第一个Activity，不需要任何动画            mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,                    r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,                    (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId,                    r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind);            ActivityOptions.abort(options);            options = null;        }        if (VALIDATE_TOKENS) {            validateAppTokensLocked();        }        if (doResume) {            //再回到ActivityStackSupervisor中            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> Platform </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Platform </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android AIDL的简单使用</title>
      <link href="/2019/12/01/Platform/Android/aidl/"/>
      <url>/2019/12/01/Platform/Android/aidl/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-AIDL-的简单使用"><a href="#Android-AIDL-的简单使用" class="headerlink" title="Android AIDL 的简单使用"></a>Android AIDL 的简单使用</h1><p>AIDL全称是Android Interface Definition Language，字面翻译成中文就是Android的接口定义语言。显而易见，这说明AIDL是一种语言。</p>]]></content>
      
      
      <categories>
          
          <category> Platform </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Platform </tag>
            
            <tag> Android </tag>
            
            <tag> AIDL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>source insight 4导入源码</title>
      <link href="/2019/11/17/Tools/source_insight/import_project/"/>
      <url>/2019/11/17/Tools/source_insight/import_project/</url>
      
        <content type="html"><![CDATA[<h1 id="source-insight-4介绍"><a href="#source-insight-4介绍" class="headerlink" title="source insight 4介绍"></a>source insight 4介绍</h1><p>source insight 4是一款功能强大，实用的源码阅读工具。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> source insight </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python第三方库</title>
      <link href="/2019/11/15/Language/Python/install_lib/"/>
      <url>/2019/11/15/Language/Python/install_lib/</url>
      
        <content type="html"><![CDATA[<h1 id="Python第三方库"><a href="#Python第三方库" class="headerlink" title="Python第三方库"></a>Python第三方库</h1><h2 id="为什么使用第三方库"><a href="#为什么使用第三方库" class="headerlink" title="为什么使用第三方库"></a>为什么使用第三方库</h2><p>Python在安装完成后就自带了一些库，以满足日常使用。但开发中总会出现标准库不满足需求的情况或有更优秀的第三方库可用。这是就需要安装第三方库了。</p><h2 id="第三方库的安装与升级"><a href="#第三方库的安装与升级" class="headerlink" title="第三方库的安装与升级"></a>第三方库的安装与升级</h2><h3 id="pip是什么"><a href="#pip是什么" class="headerlink" title="pip是什么"></a>pip是什么</h3><p> 从Python 2 版本 &gt;=2.7.9 或 Python 3 版本 &gt;=3.4 开始，在安装完Python后会自动安装pip。 pip是一个以Python写成的软件包管理系统，它可以安装和管理软件包，目前是推荐的Python包管理工具。</p><h3 id="pip的安装"><a href="#pip的安装" class="headerlink" title="pip的安装"></a>pip的安装</h3><p>如果安装过程中没有勾选安装pip，则需要手动安装pip。</p><p>第一步：用curl下载<a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">get-pip.py</a>，在命令行中执行<code>curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</code>，<code>-o</code>后面用来指定下载路径。</p><p>第二步：在命令行中执行<code>python get-pip.py</code>就能安装上pip。</p><p>参考自：<a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="noopener">pip installation</a></p><h3 id="pip使用帮助"><a href="#pip使用帮助" class="headerlink" title="pip使用帮助"></a>pip使用帮助</h3><p>在命令行中执行<code>pip help</code>可以查看pip的相关帮助信息。pip的使用方式是<code>pip &lt;command&gt; [options]</code>。</p><p><img src="/2019/11/15/Language/Python/install_lib/pip_usage.png" alt="pip usage"></p><h3 id="使用pip安装第三方库"><a href="#使用pip安装第三方库" class="headerlink" title="使用pip安装第三方库"></a>使用pip安装第三方库</h3><p>pip安装第三方库命令是<code>pip install XXXX</code>，xxxx是第三方库的名字。例如要安装<code>openpyxl</code>库，就执行<code>pip install openpyxl</code>，稍等一会就安装成功。</p><p><img src="/2019/11/15/Language/Python/install_lib/pip_command.png" alt="install openpyxl"></p><h3 id="pip安装指定版本第三方库"><a href="#pip安装指定版本第三方库" class="headerlink" title="pip安装指定版本第三方库"></a>pip安装指定版本第三方库</h3><p>有时候我们可能需要安装某个指定版本的第三方库，可以在安装时指定版本号。安装命令是<code>pip install XXXX==XXX</code></p><p>例如安装指定的3.0.1版本的<code>openpyxl</code>。</p><p><img src="/2019/11/15/Language/Python/install_lib/pip_install_version.png" alt="install target version"></p><h3 id="使用pip卸载第三方库"><a href="#使用pip卸载第三方库" class="headerlink" title="使用pip卸载第三方库"></a>使用pip卸载第三方库</h3><p>当安装了错误的第三方库或者不在需要某个第三方库时，可以卸载第三方库。卸载命令是<code>pip uninstall xxxx</code>，例如卸载<code>openpyxl</code>库。</p><p><img src="/2019/11/15/Language/Python/install_lib/pip_uninstall.png" alt="uninstall openpyxl"></p><h3 id="列出所有安装的第三方库"><a href="#列出所有安装的第三方库" class="headerlink" title="列出所有安装的第三方库"></a>列出所有安装的第三方库</h3><p>当需要查看安装了哪些第三方库时，可以使用<code>pip list</code>。</p><p><img src="/2019/11/15/Language/Python/install_lib/pip_list.png" alt="pip list"></p><h3 id="列出所有可升级第三方库"><a href="#列出所有可升级第三方库" class="headerlink" title="列出所有可升级第三方库"></a>列出所有可升级第三方库</h3><p>当需要查看哪些第三方库可以升级时，可以使用<code>pip list -o</code></p><p><img src="/2019/11/15/Language/Python/install_lib/pip_list_upgrade.png" alt="pip list upgrade"></p><h3 id="升级第三方库"><a href="#升级第三方库" class="headerlink" title="升级第三方库"></a>升级第三方库</h3><p>当需要升级某个第三方库时，可以使用<code>pip install -U XXXX</code>或者<code>pip install XXXX --upgrade</code></p><h3 id="查看第三方库的详细信息"><a href="#查看第三方库的详细信息" class="headerlink" title="查看第三方库的详细信息"></a>查看第三方库的详细信息</h3><p>当需要查看某个第三方库的详细信息时，可以使用<code>pip show XXXX</code></p><p><img src="/2019/11/15/Language/Python/install_lib/pip_show.png" alt="pip show"></p><h3 id="pip自身的升级"><a href="#pip自身的升级" class="headerlink" title="pip自身的升级"></a>pip自身的升级</h3><p>当pip有升级时可以使用<code>python -m pip install pip --upgrade</code>升级pip到最新版本。</p><h3 id="pip换源"><a href="#pip换源" class="headerlink" title="pip换源"></a>pip换源</h3><p>某些情况下安装某些第三方库时会出现总是下载失败的情况，这是可以试试更换pip源。</p><p>国内可用的其他pip源有：</p><blockquote><p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a><br>中国科技大学：<a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a><br>豆瓣(douban)：<a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a><br>清华大学：<a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a><br>中国科学技术大学：<a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">http://pypi.mirrors.ustc.edu.cn/simple/</a></p></blockquote><p>例如更换pip源为清华源地址的命令是：<code>pip install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple/</code></p><h2 id="第三方库的搜索"><a href="#第三方库的搜索" class="headerlink" title="第三方库的搜索"></a>第三方库的搜索</h2><p>当需要查看第三方库的历史版本，安装命令等信息时可以在<a href="https://pypi.org/" target="_blank" rel="noopener">这个网站</a>搜索。</p><h2 id="特殊第三方库的安装方式"><a href="#特殊第三方库的安装方式" class="headerlink" title="特殊第三方库的安装方式"></a>特殊第三方库的安装方式</h2><h3 id="PIL的安装"><a href="#PIL的安装" class="headerlink" title="PIL的安装"></a>PIL的安装</h3><p>PIL是一个强大流行的第三方图像处理库，但是只支持到Python2.7。后续版本都在<a href="https://github.com/python-pillow/Pillow" target="_blank" rel="noopener">Pillow</a>中维护。</p><p>所以当需要使用PIL库时，实际安装的是Pillow库。</p><p>安装命令是<code>pip install Pillow</code></p><p>安装时使用<code>from PIL import Image</code>引用该库。</p><p>官方文档地址： <a href="https://pillow.readthedocs.io/en/stable/?badge=latest" target="_blank" rel="noopener">https://pillow.readthedocs.io/en/stable/?badge=latest</a></p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> python </tag>
            
            <tag> python lib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime设置文件夹右键菜单</title>
      <link href="/2019/11/12/Tools/sublime/add_rightmenu/"/>
      <url>/2019/11/12/Tools/sublime/add_rightmenu/</url>
      
        <content type="html"><![CDATA[<h1 id="sublime-text3设置文件夹右键菜单"><a href="#sublime-text3设置文件夹右键菜单" class="headerlink" title="sublime text3设置文件夹右键菜单"></a>sublime text3设置文件夹右键菜单</h1><p>安装完sublime后会默认在右键菜单中添加Open With Sublime Text选项。但是没有应用图标，不够美观，我们可以为它添加图标并且添加文件夹的右键打开方式。</p><h2 id="sublime-text3-添加应用图标"><a href="#sublime-text3-添加应用图标" class="headerlink" title="sublime text3 添加应用图标"></a>sublime text3 添加应用图标</h2><p>第一步：<code>Win+R</code>打开运行，输入 <code>regedit</code>，打开注册表`</p><p>第二步：定位到<code>HKEY_CLASSES_ROOT\*\shell\Open with Sublime Text</code></p><p><img src="/2019/11/12/Tools/sublime/add_rightmenu/regedit_1.png" alt="Open with Sublime Text"></p><p>第三步：右击<code>Open With Sublime Text</code>,依次点击<code>新建</code>，<code>字符串值</code>，名称设置为<code>icon</code>。</p><p>第四步：双击<code>icon</code>在弹框中设置数据值为sublime的安装路径。</p><p><img src="/2019/11/12/Tools/sublime/add_rightmenu/regedit_2.png" alt="add icon"></p><h2 id="sublime-text3-文件夹右键菜单"><a href="#sublime-text3-文件夹右键菜单" class="headerlink" title="sublime text3 文件夹右键菜单"></a>sublime text3 文件夹右键菜单</h2><p>第一步：<code>Win+R</code>打开运行，输入 <code>regedit</code>，打开注册表</p><p>第二步：定位到<code>HKEY_CLASSES_ROOT\Directory\shell</code></p><p><img src="/2019/11/12/Tools/sublime/add_rightmenu/regedit_3.png" alt="dir shell"></p><p>第三步：在<code>shell</code>上右击选择<code>新建</code>，<code>项</code>，命名为<code>Open with Sublime Text</code>。</p><p>第四步：在新建的<code>Open with Sublime Text</code>上右击选择<code>新建</code>，<code>项</code>，命名为<code>command</code>。</p><p>第五步：修改<code>command</code>中的默认值的数据为<code>sublime安装目录的路径+空格+&quot;%1&quot;</code>，这一步是添加右键的打开方式。</p><p><img src="/2019/11/12/Tools/sublime/add_rightmenu/regedit_4.png" alt="dir command"></p><p>第六步：在<code>Open with Sublime Text</code>上右击<code>新建</code>，<code>字符串值</code>，名称修改为<code>icon</code>，数据值修改为sublime的安装目录。这一步是为右键菜单增加图标</p><p><img src="/2019/11/12/Tools/sublime/add_rightmenu/regedit_5.png" alt="add icon"></p><p>第七步：全部完成后在任务管理器中重启资源管理器，使右键菜单生效。</p><p><img src="/2019/11/12/Tools/sublime/add_rightmenu/regedit_6.png" alt="complete"></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin的作用域函数[译]</title>
      <link href="/2019/11/10/Language/Kotlin/scope_function/"/>
      <url>/2019/11/10/Language/Kotlin/scope_function/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin的作用域函数-译"><a href="#Kotlin的作用域函数-译" class="headerlink" title="Kotlin的作用域函数[译]"></a>Kotlin的作用域函数[译]</h1><h2 id="Kotlin的作用域函数的介绍"><a href="#Kotlin的作用域函数的介绍" class="headerlink" title="Kotlin的作用域函数的介绍"></a>Kotlin的作用域函数的介绍</h2><p>本文时对kotlin官方文档的翻译，<a href="https://www.kotlincn.net/docs/reference/scope-functions.html#scope-functions" target="_blank" rel="noopener">文档地址</a></p><blockquote><p>The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a <a href="https://www.kotlincn.net/docs/reference/lambdas.html" target="_blank" rel="noopener">lambda expression</a> provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called <em>scope functions</em>. There are five of them: <code>let</code>, <code>run</code>, <code>with</code>, <code>apply</code>, and <code>also</code> .</p><p>Basically, these functions do the same: execute a block of code on an object. What’s different is how this object becomes available inside the block and what is the result of the whole expression.</p></blockquote><p>kotlin的官方标准库包含了几个函数，这些函数的作用是在对象的上下文内部执行代码块。当你在提供了lambda表达式的对象中调用这些方法时，这将形成一个临时的作用域。在这个作用域中，你可以访问当前对象而不使用它的变量名。这些方法被称为作用域函数。这里共有5个作用域函数，分别为：<code>let</code>,<code>run</code>,<code>with</code>,<code>apply</code>,<code>also</code>。</p><p>基本上，这些方法都做了相同的事情：在对象上执行代码块。不同之处在于这个对象在代码块内部如何变得可用以及整个表达式的结果是什么。</p><blockquote><p>Here’s a typical usage of a scope function:</p></blockquote><p>这里是一个典型的作用域函数使用方式：</p><pre><code class="kotlin">data class Person(var name: String, var age: Int, var city: String) {    fun moveTo(newCity: String) { city = newCity }    fun incrementAge() { age++ }}fun main() {    //sampleStart    Person(&quot;Alice&quot;, 20, &quot;Amsterdam&quot;).let {        println(it)        it.moveTo(&quot;London&quot;)        it.incrementAge()        println(it)    }    //sampleEnd}</code></pre><blockquote><p>If you write the same without <code>let</code>, you’ll have to introduce a new variable and repeat its name whenever you use it.</p></blockquote><p>如果你不使用<code>let</code>这个作用域函数，你需要定义一个变量并且在每个使用到的地方重复它的名字。</p><pre><code class="kotlin">data class Person(var name: String, var age: Int, var city: String) {    fun moveTo(newCity: String) { city = newCity }    fun incrementAge() { age++ }}fun main() {    //sampleStart    val alice = Person(&quot;Alice&quot;, 20, &quot;Amsterdam&quot;)    println(alice)    alice.moveTo(&quot;London&quot;)    alice.incrementAge()    println(alice)    //sampleEnd}</code></pre><blockquote><p>The scope functions do not introduce any new technical capabilities, but they can make your code more concise and readable.</p></blockquote><p>作用域函数不需要引入任何其他的技术能力，但可以使代码更简明易懂。</p><blockquote><p>Due to the similar nature of scope functions, choosing the right one for your case can be a bit tricky. The choice mainly depends on your intent and the consistency of use in your project. Below we’ll provide detailed descriptions of the distinctions between scope functions and the conventions on their usage.</p></blockquote><p>由于作用域函数的相似性，选择一个合适的作用域函数是一件不容易的事情。这个选择主要依赖于你的意图和在项目中的合理性。下面，我们将详细提供关于作用域函数之间的不同和使用惯例的不同。</p><h2 id="作用域函数的区别"><a href="#作用域函数的区别" class="headerlink" title="作用域函数的区别"></a>作用域函数的区别</h2><blockquote><p>Because the scope functions are all quite similar in nature, it’s important to understand the differences between them. There are two main differences between each scope function:</p><ul><li>The way to refer to the context object</li><li>The return value</li></ul></blockquote><p>由于作用域函数在性质上非常相似，所以明白他们之间的不同非常重要，他们之间有两个主要的不同。</p><ul><li><p>引用上下文对象的方式</p></li><li><p>返回值</p></li></ul><h3 id="上下文对象是this还是it"><a href="#上下文对象是this还是it" class="headerlink" title="上下文对象是this还是it"></a>上下文对象是this还是it</h3><blockquote><p>Inside the lambda of a scope function, the context object is available by a short reference instead of its actual name. Each scope function uses one of two ways to access the context object: as a <a href="https://www.kotlincn.net/docs/reference/lambdas.html#%E5%B8%A6%E6%9C%89%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84%E5%87%BD%E6%95%B0%E5%AD%97%E9%9D%A2%E5%80%BC" target="_blank" rel="noopener">lambda receiver</a> (<code>this</code>) or as a lambda argument (<code>it</code>). Both provide the same capabilities, so we’ll describe the pros and cons of each for different cases and provide recommendations on their use.</p></blockquote><p>在作用域函数的lambda表达式中，上下文对象可以使用短引用的方式替代变量的真实名称。每个作用域函数使用两种访问上下文对象的方式之一：作为lambda接收者(<code>this</code>)或者作为lambda参数(<code>it</code>)。两者提供了相同的功能，所以我们将描述每一个案例下的优缺点并且提供推荐的用法。</p><pre><code class="kotlin">fun main() {    val str = &quot;Hello&quot;    // this    str.run {        println(&quot;The receiver string length: $length&quot;)        //println(&quot;The receiver string length: ${this.length}&quot;) // does the same    }    // it    str.let {        println(&quot;The receiver string&#39;s length is ${it.length}&quot;)    }}</code></pre><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><blockquote><p><code>run</code>, <code>with</code>, and <code>apply</code> refer to the context object as a lambda receiver - by keyword <code>this</code>. Hence, in their lambdas, the object is available as it would be in ordinary class functions. In most cases, you can omit <code>this</code> when accessing the members of the receiver object, making the code shorter. On the other hand, if <code>this</code> is omitted, it can be hard to distinguish between the receiver members and external objects or functions. So, having the context object as a receiver (<code>this</code>) is recommended for lambdas that mainly operate on the object members: call its functions or assign properties.</p></blockquote><p><code>run</code>，<code>with</code>，<code>apply</code>通过<code>this</code>关键字引用到上下文对象作为一个lambda接收者。因此，在这些lambda中，该上下文对象就像在普通类方法中一样可用的。在多数情况下，当你访问接收对象的成员时可以忽略<code>this</code>关键字，使得代码更短。另一方面，如果<code>this</code>被省略，这会很难区分接收者的成员和外部对象或方法。因此，更推荐持有上下文对象作为主要操作对象成员的lambda表达式的接收者(<code>this</code>)：调用该对象的方法或指定属性。</p><pre><code class="kotlin">data class Person(var name: String, var age: Int = 0, var city: String = &quot;&quot;)fun main() {    //sampleStart    val adam = Person(&quot;Adam&quot;).apply {        age = 20                       // same as this.age = 20 or adam.age = 20        city = &quot;London&quot;    }    //sampleEnd}</code></pre><h4 id="it"><a href="#it" class="headerlink" title="it"></a>it</h4><blockquote><p>In turn, <code>let</code> and <code>also</code> have the context object as a lambda argument. If the argument name is not specified, the object is accessed by the implicit default name <code>it</code>. <code>it</code> is shorter than <code>this</code> and expressions with <code>it</code> are usually easier for reading. However, when calling the object functions or properties you don’t have the object available implicitly like <code>this</code>. Hence, having the context object as <code>it</code> is better when the object is mostly used as an argument in function calls. <code>it</code> is also better if you use multiple variables in the code block.</p></blockquote><p>相反的，<code>let</code>和<code>also</code>持有上下文对象作为lambda表达式的参数。如果参数名称是非指定的，那么这个对象就使用隐式的默认名称<code>it</code>访问。<code>it</code>比<code>this</code>更短，并且使用<code>it</code>的表达式通常更容易阅读。但是，当调用对象的方法或属性时你没有像<code>this</code>方式一样的隐式可用对象。因此，当主要使用对象作为方法调用中的参数时，最好使用<code>it</code>的方式持有上下文对象。同样如果在代码块中多次使用变量使用<code>it</code>也是更好的方式。</p><pre><code class="kotlin">import kotlin.random.Randomfun writeToLog(message: String) {    println(&quot;INFO: $message&quot;)}fun main() {    //sampleStart    fun getRandomInt(): Int {        return Random.nextInt(100).also {            writeToLog(&quot;getRandomInt() generated value $it&quot;)        }    }    val i = getRandomInt()    //sampleEnd}</code></pre><blockquote><p>Additionally, when you pass the context object as an argument, you can provide a custom name for the context object inside the scope.</p></blockquote><p>另外，当你将上下文对象作为参数传递时，你可以为该对象提供一个在当前作用域内使用的自定义名称。</p><pre><code class="kotlin">import kotlin.random.Randomfun writeToLog(message: String) {    println(&quot;INFO: $message&quot;)}fun main() {    //sampleStart    fun getRandomInt(): Int {        return Random.nextInt(100).also { value -&gt;            writeToLog(&quot;getRandomInt() generated value $value&quot;)        }    }    val i = getRandomInt()    //sampleEnd}</code></pre><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><blockquote><p>The scope functions differ by the result they return</p><ul><li><p><code>apply</code> and <code>also</code> return the context object .</p></li><li><p><code>let</code>, <code>run</code>, and <code>with</code> return the lambda result .</p></li></ul><p>These two options let you choose the proper function depending on what you do next in your code.</p></blockquote><p>作用域函数的不同在于返回结果的不同。</p><ul><li><code>apply</code>和<code>also</code>返回上下文对象</li><li><code>let</code>，<code>run</code>，<code>with</code>返回lambda的结果</li></ul><p>根据你在后续代码中的行为从两个选项中合适的方法。</p><h4 id="上下文对象"><a href="#上下文对象" class="headerlink" title="上下文对象"></a>上下文对象</h4><blockquote><p>The return value of <code>apply</code> and <code>also</code> is the context object itself. Hence, they can be included into call chains as <em>side steps</em>: you can continue chaining function calls on the same object after them.</p></blockquote><p><code>apply</code>和<code>alse</code>的返回值是上下文对象自身。因此，他们可以被包括到调用链中作为连续步骤：你可以在同一个对象上继续链接方法调用。</p><pre><code class="kotlin">fun main() {    //sampleStart    val numberList = mutableListOf&lt;Double&gt;()    numberList.also { println(&quot;Populating the list&quot;) }        .apply {            add(2.71)            add(3.14)            add(1.0)        }        .also { println(&quot;Sorting the list&quot;) }        .sort()    //sampleEnd    println(numberList)}</code></pre><blockquote><p>They also can be used in return statements of functions returning the context object.</p></blockquote><p>他们同样可以被应用在返回上下文对象的方法return语句中。</p><pre><code class="kotlin">import kotlin.random.Randomfun writeToLog(message: String) {    println(&quot;INFO: $message&quot;)}fun main() {    //sampleStart    fun getRandomInt(): Int {        return Random.nextInt(100).also {            writeToLog(&quot;getRandomInt() generated value $it&quot;)        }    }    val i = getRandomInt()    //sampleEnd}</code></pre><h4 id="Lambda表达式结果"><a href="#Lambda表达式结果" class="headerlink" title="Lambda表达式结果"></a>Lambda表达式结果</h4><blockquote><p><code>let</code>, <code>run</code>, and <code>with</code> return the lambda result. So, you can use them when assigning the result to a variable, chaining operations on the result, and so on.</p></blockquote><p><code>let</code>，<code>run</code>和<code>with</code>都返回lambda的结果。因此，你可以在需要将结果赋值给变量，对结果继续链接操作等等情况下选择这三种作用域函数。</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)    val countEndsWithE = numbers.run {        add(&quot;four&quot;)        add(&quot;five&quot;)        count { it.endsWith(&quot;e&quot;) }    }    println(&quot;There are $countEndsWithE elements that end with e.&quot;)    //sampleEnd}</code></pre><blockquote><p>Additionally, you can ignore the return value and use a scope function to create a temporary scope for variables.</p></blockquote><p>另外，你可以忽略返回值并且使用作用域函数为变量创建临时作用域。</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)    with(numbers) {        val firstItem = first()        val lastItem = last()        println(&quot;First item: $firstItem, last item: $lastItem&quot;)    }    //sampleEnd}</code></pre><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><blockquote><p>To help you choose the right scope function for your case, we’ll describe them in detail and provide usage recommendations. Technically, functions are interchangeable in many cases, so the examples show the conventions that define the common usage style.</p></blockquote><p>为了帮助你选择正确的作用域函数，我们将详细描述他们并且提供使用建议。从技术上讲，在许多情况下作用域函数是互通的，因此下面的例子展示了约定俗成的默认的常用使用方式。</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><blockquote><p><strong>The context object</strong> is available as an argument (<code>it</code>). <strong>The return value</strong> is the lambda result.</p><p><code>let</code> can be used to invoke one or more functions on results of call chains. For example, the following code prints the results of two operations on a collection:</p></blockquote><p>上下文对象可用作参数(<code>it</code>)，返回值是lambda表达式的结果。</p><p><code>let</code>可以用于在调用链的结果上调用一个或多个方法。例如，下面的代码打印了一个集合在两个操作后的结果。</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;)    val resultList = numbers.map { it.length }.filter { it &gt; 3 }    println(resultList)    //sampleEnd}</code></pre><p>使用<code>let</code>，你可以重写成这个形式：</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;)    numbers.map { it.length }.filter { it &gt; 3 }.let {        println(it)        // and more function calls if needed        // 需要的话可以调用其他方法    }    //sampleEnd}</code></pre><blockquote><p>If the code block contains a single function with <code>it</code> as an argument, you can use the method reference (<code>::</code>) instead of the lambda:</p></blockquote><p>如果代码块中只包含单个方法并且使用了<code>it</code>作为参数，那么你可以使用方法引用<code>(::)</code>替代lambda表达式。</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;)    numbers.map { it.length }.filter { it &gt; 3 }.let(::println)    //等效于.let{ println(it) }    //sampleEnd}</code></pre><blockquote><p><code>let</code> is often used for executing a code block only with non-null values. To perform actions on a non-null object, use the safe call operator <code>?.</code> on it and call <code>let</code> with the actions in its lambda.</p></blockquote><p><code>let</code>通常用于执行仅使用非空值的代码块。为了对非空对象执行操作，应该使用安全操作符<code>?.</code>并且调用<code>let</code>在lambda中执行操作。</p><pre><code class="kotlin">fun processNonNullString(str: String) {}fun main() {    //sampleStart    val str: String? = &quot;Hello&quot;    //processNonNullString(str)       // compilation error: str can be null    val length = str?.let {        // 因为使用了?.操作符，当str为null时不会执行到lambda代码块的内容，        // 保证了processNonNullString()方法不会传入空值        println(&quot;let() called on $it&quot;)        processNonNullString(it)      // OK: &#39;it&#39; is not null inside &#39;?.let { }&#39;        it.length    }    //sampleEnd}</code></pre><blockquote><p>Another case for using <code>let</code> is introducing local variables with a limited scope for improving code readability. To define a new variable for the context object, provide its name as the lambda argument so that it can be used instead of the default <code>it</code>.</p></blockquote><p>另一个使用<code>let</code>的案例是在有限的作用域内引入局部变量以提高代码可读性。为了给上下文对象定义一个新变量，为lambda提供一个名称作为参数这样可以使用新名称而不是默认的<code>it</code>。</p><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><blockquote><p>A non-extension function: <strong>the context object</strong> is passed as an argument, but inside the lambda, it’s available as a receiver (<code>this</code>). <strong>The return value</strong> is the lambda result.</p><p>We recommend <code>with</code> for calling functions on the context object without providing the lambda result. In the code, <code>with</code> can be read as “<em>with this object, do the following.</em>”</p></blockquote><p>一个非拓展方法：上下文对象是作为参数传递的，但是在lambda内部，它作为一个接收者(<code>this</code>)。返回值是lambda的结果。</p><p>我们推荐在不需要提供lambda结果的情况下使用<code>with</code>在上下文对象上调用函数。在代码中<code>with</code>可以解释为“在这个对象上执行如下操作”</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)    with(numbers) {        println(&quot;&#39;with&#39; is called with argument $this&quot;)        println(&quot;It contains $size elements&quot;)    }    //sampleEnd}</code></pre><blockquote><p>Another use case for <code>with</code> is introducing a helper object whose properties or functions will be used for calculating a value.</p></blockquote><p>另一个使用<code>with</code>的案例是引入一个辅助对象其属性和方法可以用于计算值。</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)    val firstAndLast = with(numbers) {        &quot;The first element is ${first()},&quot; +        &quot; the last element is ${last()}&quot;    }    println(firstAndLast)    //sampleEnd}</code></pre><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><blockquote><p><strong>The context object</strong> is available as a receiver (<code>this</code>). <strong>The return value</strong> is the lambda result.</p><p><code>run</code> does the same as <code>with</code> but invokes as <code>let</code> - as an extension function of the context object.</p><p><code>run</code> is useful when your lambda contains both the object initialization and the computation of the return value.</p></blockquote><p>上下文对象可用作接收者(<code>this</code>)，返回值是lambda结果。</p><p><code>run</code>和<code>with</code>有相同功能，按照<code>let</code>的调用方式 -作为上下文对象的拓展方法。</p><p><code>run</code>很有效当你的lambda表达式中都包含了对象初始化和返回值的计算。</p><pre><code class="kotlin">class MultiportService(var url: String, var port: Int) {    fun prepareRequest(): String = &quot;Default request&quot;    fun query(request: String): String = &quot;Result for query &#39;$request&#39;&quot;}fun main() {    //sampleStart    val service = MultiportService(&quot;https://example.kotlinlang.org&quot;, 80)    val result = service.run {        port = 8080        query(prepareRequest() + &quot; to port $port&quot;)    }    // the same code written with let() function:    val letResult = service.let {        it.port = 8080        it.query(it.prepareRequest() + &quot; to port ${it.port}&quot;)    }    //sampleEnd    println(result)    println(letResult)}</code></pre><blockquote><p>Besides calling <code>run</code> on a receiver object, you can use it as a non-extension function. Non-extension <code>run</code> lets you execute a block of several statements where an expression is required.</p></blockquote><p>除了在接收者对象上调用<code>run</code>方法之外，你还可以使用它作为非拓展方法。非拓展的<code>run</code>使你可以在需要表达式时执行一个包含多个语句的代码块。</p><pre><code class="kotlin">fun main() {    //sampleStart    val hexNumberRegex = run {        val digits = &quot;0-9&quot;        val hexDigits = &quot;A-Fa-f&quot;        val sign = &quot;+-&quot;        Regex(&quot;[$sign]?[$digits$hexDigits]+&quot;)    }    for (match in hexNumberRegex.findAll(&quot;+1234 -FFFF not-a-number&quot;)) {        println(match.value)    }    //sampleEnd}</code></pre><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><blockquote><p><strong>The context object</strong> is available as a receiver (<code>this</code>). <strong>The return value</strong> is the object itself.</p><p>Use <code>apply</code> for code blocks that don’t return a value and mainly operate on the members of the receiver object. The common case for <code>apply</code> is the object configuration. Such calls can be read as “<em>apply the following assignments to the object.</em>”</p></blockquote><p>上下文对象作为接收者(<code>this</code>)，返回值是上下文对象本身。</p><p><code>apply</code>用于不返回值并且主要操作于接受对象的成员的代码块，常见的<code>apply</code>使用场景是对象的配置。<code>apply</code>方法可以解释为“应用如下的分配到对象”</p><pre><code class="kotlin">data class Person(var name: String, var age: Int = 0, var city: String = &quot;&quot;)fun main() {    //sampleStart    val adam = Person(&quot;Adam&quot;).apply {        age = 32        city = &quot;London&quot;    }    //sampleEnd}</code></pre><blockquote><p>Having the receiver as the return value, you can easily include <code>apply</code> into call chains for more complex processing.</p></blockquote><p>持有接收者作为返回值，你可以更容易地把<code>apply</code>包括到调用链中以实现更复杂的处理。</p><h3 id="also"><a href="#also" class="headerlink" title="also"></a>also</h3><blockquote><p><strong>The context object</strong> is available as an argument (<code>it</code>). <strong>The return value</strong> is the object itself.</p><p><code>also</code> is good for performing some actions that take the context object as an argument. Use <code>also</code> for additional actions that don’t alter the object, such as logging or printing debug information. Usually, you can remove the calls of <code>also</code> from the call chain without breaking the program logic.</p><p>When you see <code>also</code> in the code, you can read it as “<em>and also do the following</em>”.</p></blockquote><p>上下文对象作为参数(<code>it</code>)，返回值是上下文对象自身。</p><p><code>also</code>对一些将上下文对象作为参数传递的行为很有用。对于其他不改变上下文对象例如log或者打印调试信息的行为也可以使用<code>also</code>。通常，你可以从调用链中移除<code>also</code>调用而不影响原有程序逻辑。</p><p>当你在代码中看到<code>also</code>时，你可以将其解释为“并且执行如下操作”</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)    numbers        .also { println(&quot;The list elements before adding new one: $it&quot;) }        .add(&quot;four&quot;)    //sampleEnd}</code></pre><h2 id="函数选择"><a href="#函数选择" class="headerlink" title="函数选择"></a>函数选择</h2><blockquote><p>To help you choose the right scope function for your purpose, we provide the table of key differences between them.</p></blockquote><p>为了帮助你选择正确的作用域函数，我们提供了他们的主要区别表</p><table><thead><tr><th align="center">方法名</th><th align="center">对象引用</th><th align="center">返回值</th><th align="left">是否拓展函数</th></tr></thead><tbody><tr><td align="center">let</td><td align="center">it</td><td align="center">Lambda结果</td><td align="left">是</td></tr><tr><td align="center">run</td><td align="center">this</td><td align="center">Lambda结果</td><td align="left">是</td></tr><tr><td align="center">run</td><td align="center">-</td><td align="center">Lambda结果</td><td align="left">否：无上下文对象调用</td></tr><tr><td align="center">with</td><td align="center">this</td><td align="center">Lambda结果</td><td align="left">否：上下文对象作为参数传递</td></tr><tr><td align="center">apply</td><td align="center">this</td><td align="center">Context object</td><td align="left">是</td></tr><tr><td align="center">also</td><td align="center">it</td><td align="center">Context object</td><td align="left">是</td></tr></tbody></table><blockquote><p>Here is a short guide for choosing scope functions depending on the intended purpose:</p><ul><li>Executing a lambda on non-null objects: <code>let</code></li><li>Introducing an expression as a variable in local scope: <code>let</code></li><li>Object configuration: <code>apply</code></li><li>Object configuration and computing the result: <code>run</code></li><li>Running statements where an expression is required: non-extension <code>run</code></li><li>Additional effects: <code>also</code></li><li>Grouping function calls on an object: <code>with</code></li></ul><p>The use cases of different functions overlap, so that you can choose the functions based on the specific conventions used in your project or team.</p><p>Although the scope functions are a way of making the code more concise, avoid overusing them: it can decrease your code readability and lead to errors. Avoid nesting scope functions and be careful when chaining them: it’s easy to get confused about the current context object and the value of <code>this</code> or <code>it</code>.</p></blockquote><p>如下是根据预期目的选择合适作用域函数的简单指南。</p><ul><li>在一个非空对象上执行一个lambda表达式：<code>let</code></li><li>引入一个表达式作为局部作用域中的变量：<code>let</code></li><li>对象配置：<code>apply</code></li><li>对象配置并且计算结果：<code>run</code></li><li>需要表达式的运行语句：非扩展的<code>run</code></li><li>附加效果：<code>also</code></li><li>一个对象上的一组方法调用：<code>with</code></li></ul><p>不同方法之间的使用场景存在重叠的情况，所以你可以根据你的项目或团队指定的使用约定来选择合适的作用域函数。</p><p>虽然作用域函数是使代码更简洁的方法，但应该避免过度使用它们：这会降低代码的可读性并容易导致错误。避免嵌套使用作用域函数并且在链式调用时要注意：因为这很容易导致对当前的上下文对象的混乱和对<code>this</code>，<code>it</code>的混乱。</p><h2 id="takeIf-与-takeUnless"><a href="#takeIf-与-takeUnless" class="headerlink" title="takeIf 与 takeUnless"></a>takeIf 与 takeUnless</h2><blockquote><p>In addition to scope functions, the standard library contains the functions <code>takeIf</code> and <code>takeUnless</code>. These functions let you embed checks of the object state in call chains.</p></blockquote><p>除了作用域函数之外，Kotlin标准库还包含了<code>takeIf</code>和<code>takeUnless</code>两个方法。这两个方法使你可以可以在调用链中检查对象的状态。</p><blockquote><p>When called on an object with a predicate provided, <code>takeIf</code> returns this object if it matches the predicate. Otherwise, it returns <code>null</code>. So, <code>takeIf</code> is a filtering function for a single object. In turn, <code>takeUnless</code> returns the object if it doesn’t match the predicate and <code>null</code> if it does. The object is available as a lambda argument (<code>it</code>).</p></blockquote><p>当在提供了predicate的对象上调用时，<code>takeIf</code>返回对象本身如果它是匹配predicate的。否则，返回<code>null</code>。因此，<code>takeIf</code>是一个对单个对象的过滤方法。相反的，<code>takeUnless</code>返回对象本身如果它不匹配predicate，返回<code>null</code>如果它匹配。这个对象在lambda中作为参数可用(<code>it</code>)。</p><pre><code class="kotlin">import kotlin.random.*fun main() {    //sampleStart    val number = Random.nextInt(100)    val evenOrNull = number.takeIf { it % 2 == 0 }    val oddOrNull = number.takeUnless { it % 2 == 0 }    println(&quot;even: $evenOrNull, odd: $oddOrNull&quot;)    //sampleEnd}</code></pre><blockquote><p>When chaining other functions after <code>takeIf</code> and <code>takeUnless</code>, don’t forget to perform the null check or the safe call (<code>?.</code>) because their return value is nullable.</p></blockquote><p>在<code>takeIf</code>或<code>takeUnless</code>后链接其他方法时不要忘记执行null检查或者使用安全调用符号<code>?.</code>，因为它们的返回值是可为空的。</p><pre><code class="kotlin">fun main() {    //sampleStart    val str = &quot;Hello&quot;    val caps = str.takeIf { it.isNotEmpty() }?.toUpperCase()       //val caps = str.takeIf { it.isNotEmpty() }.toUpperCase() //compilation error    println(caps)    //sampleEnd}</code></pre><blockquote><p><code>takeIf</code> and <code>takeUnless</code> are especially useful together with scope functions. A good case is chaining them with <code>let</code> for running a code block on objects that match the given predicate. To do this, call <code>takeIf</code> on the object and then call <code>let</code> with a safe call (<code>?</code>). For objects that don’t match the predicate, <code>takeIf</code> returns <code>null</code> and <code>let</code> isn’t invoked.</p></blockquote><p><code>takeIf</code>和<code>takeUnless</code>和作用域函数一起使用是非常有用的。一个合适的使用场景是使用<code>let</code>链接它们，用来在一个匹配给定的 predicate 的对象上运行代码块。为了这样做，在对象上调用<code>takeIf</code>然后使用<code>?.</code>调用<code>let</code>。对于不匹配 predicate 的对象，<code>takeIf</code>返回<code>null</code>并且不会被<code>let</code>调用。</p><pre><code class="kotlin">fun main() {    //sampleStart    fun displaySubstringPosition(input: String, sub: String) {        input.indexOf(sub).takeIf { it &gt;= 0 }?.let {            println(&quot;The substring $sub is found in $input.&quot;)            println(&quot;Its start position is $it.&quot;)        }    }    displaySubstringPosition(&quot;010000011&quot;, &quot;11&quot;)    displaySubstringPosition(&quot;010000011&quot;, &quot;12&quot;)    //sampleEnd}</code></pre><blockquote><p>This is how the same function looks without the standard library functions:</p></blockquote><p>下面是不使用标准库函数时的代码：</p><pre><code class="kotlin">fun main() {    //sampleStart    fun displaySubstringPosition(input: String, sub: String) {        val index = input.indexOf(sub)        if (index &gt;= 0) {            println(&quot;The substring $sub is found in $input.&quot;)            println(&quot;Its start position is $index.&quot;)        }    }    displaySubstringPosition(&quot;010000011&quot;, &quot;11&quot;)    displaySubstringPosition(&quot;010000011&quot;, &quot;12&quot;)    //sampleEnd}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> kotlin </tag>
            
            <tag> scope function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java ClassLoader的简单介绍</title>
      <link href="/2019/09/28/Language/Java/classloader_detail/"/>
      <url>/2019/09/28/Language/Java/classloader_detail/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-ClassLoader的简单介绍"><a href="#Java-ClassLoader的简单介绍" class="headerlink" title="Java ClassLoader的简单介绍"></a>Java ClassLoader的简单介绍</h1><p>本文是阅读《深入理解Java虚拟机》第七章类加载器相关部分过程中生成的阅读笔记。简单介绍了ClassLoader的是什么，主要的类型和双亲委派模型。</p><h2 id="ClassLoader是什么"><a href="#ClassLoader是什么" class="headerlink" title="ClassLoader是什么"></a>ClassLoader是什么</h2><blockquote><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p><p>​                                                                                                                    –《深入理解Java虚拟机》（周志明）</p></blockquote><p>ClassLoader就是这里提到的类加载器。类加载器的作用就是根据类的全限定名获取类的二进制字节流。这个动作在Java虚拟机的外部实现。</p><h2 id="类与类加载器的关系"><a href="#类与类加载器的关系" class="headerlink" title="类与类加载器的关系"></a>类与类加载器的关系</h2><p>类加载器除了加载类的作用外，还和被加载的类本身共同确保类的唯一性。对于两个相同的Class文件，当使用不同的类加载器加载时他们就i是不同的。</p><p>例如当使用了不同ClassLoader加载同一个类时，会导致instanceof的结果为false。</p><pre><code class="java">package com.suifeng.loader;import java.io.IOException;import java.io.InputStream;public class ClassLoaderTest {    public static void main(String[] args) throws Exception{        ClassLoader myClassLoader = new ClassLoader() {            @Override            public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {                try {                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;                    InputStream is = getClass().getResourceAsStream(fileName);                    if (is == null) {                        return super.loadClass(name);                    }                    byte[] b = new byte[is.available()];                    is.read(b);                    return defineClass(name, b, 0, b.length);                } catch (IOException e) {                    e.printStackTrace();                    throw new ClassNotFoundException(name);                }            }        };        Class&lt;?&gt; aClass = myClassLoader.loadClass(&quot;com.suifeng.loader.TestClass&quot;);        Object obj = aClass.newInstance();        System.out.println(obj.getClass());        System.out.println(obj instanceof com.suifeng.loader.TestClass);    }}</code></pre><p>输出结果为</p><pre><code class="Java"> class com.suifeng.loader.TestClass false</code></pre><p>可以看到这里的obj是TestClass的对象，但使用instanceof关键字判断时仍然返回false。这是因为使用了不同类加载器jvm将他们识别为两个不同的类。obj是自定义类加载的，而另一个是由系统应用程序类加载器加载的。</p><h2 id="类加载器类型"><a href="#类加载器类型" class="headerlink" title="类加载器类型"></a>类加载器类型</h2><p>Java提供了三种类加载器。分别是<code>启动类加载器</code>，<code>扩展类加载器</code>，<code>应用程序类加载器</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> java </tag>
            
            <tag> ClassLoader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo踩坑记录和优化</title>
      <link href="/2019/09/22/Tools/hexo/hexo_help/"/>
      <url>/2019/09/22/Tools/hexo/hexo_help/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo踩坑记录和优化"><a href="#hexo踩坑记录和优化" class="headerlink" title="hexo踩坑记录和优化"></a>hexo踩坑记录和优化</h1><h2 id="本地预览图片丢失"><a href="#本地预览图片丢失" class="headerlink" title="本地预览图片丢失"></a>本地预览图片丢失</h2><p>当新建了博客编写完后执行<code>hexo g</code>和<code>hexo s</code>预览文章发现所有的图片都丢失了，无法正常加载。chrome中按<code>F12</code>查看发现<code>hexo-asset-image</code>插件没有正确地转换图片地址</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/error_src.png" alt="错误图片地址"></p><p>而且生成的资源下也不包含任何图片信息。</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/no_src.png" alt="无图片资源"></p><p>一开始在这个<a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">博客</a>下找到了解决方案。</p><p>找到博客根目录下的<code>/node_modules/hexo-asset-image/index.js</code>文件，将其中的代码修改正博客中的代码，贴上代码如下：</p><pre><code class="js">&#39;use strict&#39;;var cheerio = require(&#39;cheerio&#39;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string--123456794563543543543545435function getPosition(str, m, i) {  return str.split(m, i).join(m).length;}var version = String(hexo.version).split(&#39;.&#39;);hexo.extend.filter.register(&#39;after_post_render&#39;, function(data){  var config = hexo.config;  if(config.post_asset_folder){        var link = data.permalink;    if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)       var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;    else       var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;    // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.    var endPos = link.lastIndexOf(&#39;/&#39;) + 1;    link = link.substring(beginPos, endPos);    var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];    for(var i = 0; i &lt; toprocess.length; i++){      var key = toprocess[i];      var $ = cheerio.load(data[key], {        ignoreWhitespace: false,        xmlMode: false,        lowerCaseTags: false,        decodeEntities: false      });      $(&#39;img&#39;).each(function(){        if ($(this).attr(&#39;src&#39;)){            // For windows style path, we replace &#39;\&#39; to &#39;/&#39;.            var src = $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;/&#39;);            if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;               !/^\s*\//.test(src)) {              // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.              // In addition, to support multi-level local directory.              var linkArray = link.split(&#39;/&#39;).filter(function(elem){                return elem != &#39;&#39;;              });              var srcArray = src.split(&#39;/&#39;).filter(function(elem){                return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;              });              if(srcArray.length &gt; 1)                srcArray.shift();              src = srcArray.join(&#39;/&#39;);              $(this).attr(&#39;src&#39;, config.root + link + src);              console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);            }        }else{            console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);            console.info&amp;&amp;console.info($(this));        }      });      data[key] = $.html();    }  }});</code></pre><p>但是这个解决方案其实是有问题</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/error_src_1.png" alt="方案1"></p><p>可以看到这里的<code>src</code>资源路径还是错误的。原因是这里的方案只支持Hexo的标签方式(Hexo的标签引用<a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="noopener">看这里</a>)的引用，对于markdown的引用方式还是不支持。如果把这里的图片引入方式修改为Hexo的标签方式<code></code>就可以正常显示了。</p><p>但是这有一个问题就是使用标签方式在markdown中无法直接预览效果。</p><p>所以我就基于这个解决方案做了修改。代码如下：</p><pre><code class="javascript">&#39;use strict&#39;;var cheerio = require(&#39;cheerio&#39;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) {    return str.split(m, i).join(m).length;}var version = String(hexo.version).split(&#39;.&#39;);hexo.extend.filter.register(&#39;after_post_render&#39;, function (data) {    var config = hexo.config;    if (config.post_asset_folder) {        var link = data.permalink;        if (version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)            var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;        else            var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;        // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.        var endPos = link.lastIndexOf(&#39;/&#39;) + 1;        link = link.substring(beginPos, endPos);        var beginDir = getPosition(link, &quot;/&quot;, 2)        var endDir = link.length        var srcDir = link.substring(beginDir, endDir)        var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];        for (var i = 0; i &lt; toprocess.length; i++) {            var key = toprocess[i];            var $ = cheerio.load(data[key], {                ignoreWhitespace: false,                xmlMode: false,                lowerCaseTags: false,                decodeEntities: false            });            $(&#39;img&#39;).each(function () {                if ($(this).attr(&#39;src&#39;)) {                    // For windows style path, we replace &#39;\&#39; to &#39;/&#39;.                    var src = $(this).attr(&#39;src&#39;)                    src = src.replace(&#39;\\&#39;, &#39;/&#39;);                    var b1 = !/http[s]*.*|\/\/.*/.test(src)                    if (b1) {                        // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.                        // In addition, to support multi-level local directory.                        var linkArray = link.split(&#39;/&#39;).filter(function (elem) {                            return elem != &#39;&#39;;                        });                        var srcArray = src.split(&#39;/&#39;).filter(function (elem) {                            return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;                        });                        if (srcArray.length &gt; 1)                            srcArray.shift();                        var mSrc = srcArray.join(&#39;/&#39;);                        var realLink = srcDir + mSrc                        $(this).attr(&#39;src&#39;, realLink);                        console.info &amp;&amp; console.info(&quot;update link as:--&gt;&quot; + realLink);                    }                } else {                    console.info &amp;&amp; console.info(&quot;no src attr, skipped...&quot;);                    console.info &amp;&amp; console.info($(this));                }            });            data[key] = $.html();        }    }});</code></pre><p>这样就可以支持markdown的图片引入了</p><p>效果如下：</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/good_src.png" alt="正常显示"></p><h2 id="代码行号丢失"><a href="#代码行号丢失" class="headerlink" title="代码行号丢失"></a>代码行号丢失</h2><p>按照官网文档的推荐使用<a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a>作为代码高亮插件，但是按照官网的配置发现预览网页中没有行号。</p><p>需要做如下修改，打开主题的<code>themes\hexo-theme-matery\source\css\matery.css</code>文件，修改第95~111行如下</p><pre><code class="css">pre {    padding: 1.5rem 1.5rem 1.5rem 3.3rem !important;    margin: 1rem 0 !important;    background: #272822;    overflow: auto;    border-radius: 0.35rem;    tab-size: 4;}code {    padding: 1px 5px;    font-family: Inconsolata, Monaco, Consolas, &#39;Courier New&#39;, Courier, monospace;    /* font-size: 0.91rem;*/    color: #e96900;    background-color: #f8f8f8;    border-radius: 2px;}</code></pre><p>重新生成预览页面就正常了</p><h2 id="代码行号错位"><a href="#代码行号错位" class="headerlink" title="代码行号错位"></a>代码行号错位</h2><p>当代码中存在较长代码自动换行时会导致代码行号与代码不对应。</p><p>使用<code>code-prettify</code>代替</p><h2 id="更换代码高亮插件"><a href="#更换代码高亮插件" class="headerlink" title="更换代码高亮插件"></a>更换代码高亮插件</h2><p>因为<code>hexo-prism-plugin</code>在行号显示和复制代码丢失缩进和换行的问题，所以决定更换代码高亮插件为<a href="https://github.com/google/code-prettify" target="_blank" rel="noopener">code-prettify</a>。</p><p>从<a href="https://github.com/google/code-prettify" target="_blank" rel="noopener">code-prettify</a>clone下来最新代码，复制<code>code-prettify\src\prettify.js</code>文件到博客主题的<code>source\js</code>下</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/copy_prettifyjs.png" alt="复制prettify.js"></p><p>然后复制<code>code-prettify\styles\sons-of-obsidian.css</code>文件到博客的<code>source\css</code>下（这里是使用了<code>sons-of-obsidian</code>代码高亮主题，如果要使用默认主题的话就复制<code>code-prettify\src\prettify.css</code>到这个目录下）。</p><p>然后打开<code>themes\hexo-theme-matery\layout\_partial\head.ejs</code>文件，增加引用新css的代码</p><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%- config.root %&gt;css/sons-of-obsidian.css&quot; media=&quot;screen&quot; type=&quot;text/css&quot;&gt;</code></pre><p> 如果用的是默认的css，这里就设置为对应的css就好了。</p><p>另外很重要的一点是这里还需要添加一段style代码：</p><pre><code class="html">&lt;style&gt;    li.L0, li.L1, li.L2, li.L3, li.L4, li.L5, li.L6, li.L7, li.L8, li.L9    { list-style-type: decimal !important }&lt;/style&gt;</code></pre><p>这其实是为了解决<code>code-prettify</code>的行号bug，不然会出现在代码块中只有一个点但没有代码行号的情况。</p><p>接着打开<code>themes\hexo-theme-matery\layout\_partial\footer.ejs</code>文件，增加加载<code>prettify.js</code>的代码：</p><pre><code class="html">&lt;script src=&quot;&lt;%- config.root %&gt;js/prettify.js&quot;&gt;&lt;/script&gt;</code></pre><p>再给<code>pre</code>标签增加<code>prettyprint</code>和<code>linenums</code>这两个css的class</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;    $(document).ready(function(){        $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;);            prettyPrint();    })&lt;/script&gt;</code></pre><p>最后要记得把博客根目录下的<code>_config.yml</code>中highlight相关的配置都修改为false</p><p>做完这些后就可以执行<code>hexo g</code>和<code>hexo s</code>预览一下效果了，代码块应该是能正常工作了</p><p>参考自：</p><ol><li><p>[<a href="http://masikkk.com/article/hexo-12-google-code-prettify/" target="_blank" rel="noopener">Hexo博客(12)使用google-code-prettify代码高亮</a>]</p></li><li><p><a href="https://www.v2ex.com/t/32260" target="_blank" rel="noopener">https://www.v2ex.com/t/32260</a></p></li></ol><p>下面是我自己对主题的一些修改:</p><h3 id="去除代码隔行背景色"><a href="#去除代码隔行背景色" class="headerlink" title="去除代码隔行背景色"></a>去除代码隔行背景色</h3><p>去除代码的隔行不同背景色，把<code>sons-of-obsidian.css</code>里的69~71行代码注释掉。被注释代码如下</p><pre><code class="css">li.L1, li.L3, li.L5, li.L7, li.L9 {    background: #111;}</code></pre><h3 id="去除代码下背景色"><a href="#去除代码下背景色" class="headerlink" title="去除代码下背景色"></a>去除代码下背景色</h3><p>去除每行代码的背景色，通过查看style发现是在<code>matery.css</code>里的<code>pre code</code>里的<code>background-color</code>控制的，所以这里把<code>background-color</code>的alpha值设为0就好了</p><p>更正：这里的<code>background-color</code>值应该修改为#00000000，否则在其他背景色下还是能看到。</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/code_bg.png" alt="代码背景色"></p><p><img src="/2019/09/22/Tools/hexo/hexo_help/code_bg_1.png" alt="代码取消背景色"></p><h3 id="修复代码块复制后丢失缩进的问题"><a href="#修复代码块复制后丢失缩进的问题" class="headerlink" title="修复代码块复制后丢失缩进的问题"></a>修复代码块复制后丢失缩进的问题</h3><p><code>matery</code>还有这样一个bug，当复制的代码数量大于主题的<code>_config.yml</code>下的<code>copyright</code>中配置的<code>minCharNumber</code>阈值时会导致粘贴时代码丢失缩进，排查后解决方案如下：在<code>themes\hexo-theme-matery\layout\_partial\post-detail.ejs</code>代码中为<code>newdiv</code>增加<code>newdiv.style.whiteSpace = &#39;pre&#39;</code>属性。</p><pre><code class="javascript">// create a div outside of the visible area and fill it with the selected text.var bodyElement = document.getElementsByTagName(&#39;body&#39;)[0];var newdiv = document.createElement(&#39;div&#39;);newdiv.style.position = &#39;absolute&#39;;newdiv.style.left = &#39;-99999px&#39;;newdiv.style.whiteSpace = &#39;pre&#39;; //增加这个属性，以防止空格缩进被去除bodyElement.appendChild(newdiv);var cloneContents = selection.getRangeAt(0).cloneContents()newdiv.appendChild(cloneContents);</code></pre><h3 id="修改代码块背景色"><a href="#修改代码块背景色" class="headerlink" title="修改代码块背景色"></a>修改代码块背景色</h3><p>默认的代码背景色是黑色的，看着眼睛不舒服，所以修改为idea的默认背景色<code>#2B2B2B</code>。对代码块检查发现代码块背景色在<code>sons-of-obsidian.css</code>的61行的<code>.prettyprint</code>里的<code>background</code>属性。</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/code_block_bg_1.png" alt="black_bg"></p><p>所以打开博客根目录下的<code>themes\hexo-theme-matery\source\css\sons-of-obsidian.css</code>，修改 <code>.prettyprint</code>的<code>background</code>属性为<code>#2B2B2B</code>。</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/code_block_bg_2.png" alt="black_bg"></p><p>修改完成后直接刷新界面就能看到修改后的效果了。</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/code_block_bg_3.png" alt="black_bg"></p><p>这样看着就舒服多了。</p><h2 id="线上博客异常"><a href="#线上博客异常" class="headerlink" title="线上博客异常"></a>线上博客异常</h2><p>本地博客push到线上后发现界面排版错误，所有图片无法加载，其实是因为GitHub上的仓库名称命名错误。</p><p>仓库名称应该命名为[GitHub name].github.io</p><h2 id="更新matery1-2-0导致Bug"><a href="#更新matery1-2-0导致Bug" class="headerlink" title="更新matery1.2.0导致Bug"></a>更新matery1.2.0导致Bug</h2><p>刚刚更新了matery的1.2.0版本，导致博客中出现了一些预期之外的bug，下面记录一下具体的Bug和修复记录。</p><h3 id="代码块缩放异常"><a href="#代码块缩放异常" class="headerlink" title="代码块缩放异常"></a>代码块缩放异常</h3><p>matery1.2.0在代码块中增加了代码块的缩放和复制功能，但是这个功能和<code>code-prettify</code>有冲突，导致缩放代码块时代码消失，但代码行号仍然保留的bug。</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/upgrade_codeblock_error.png" alt="codeblock error"></p><p>通过搜索<code>fas fa-angle-up code-expand</code>发现这个关键字只在<code>themes\hexo-theme-matery\source\libs\codeBlock\codeShrink.js</code>被使用，这里设置了代码缩放按钮的点击事件。</p><pre><code class="js">// 代码块收缩$(function () {  var $code_expand = $(&#39;&lt;i class=&quot;fas fa-angle-up code-expand&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#39;);  $(&#39;.code-area&#39;).prepend($code_expand);  $(&#39;.code-expand&#39;).on(&#39;click&#39;, function () {    if ($(this).parent().hasClass(&#39;code-closed&#39;)) {      $(this).siblings(&#39;pre&#39;).find(&#39;code&#39;).show();      $(this).parent().removeClass(&#39;code-closed&#39;);    } else {      $(this).siblings(&#39;pre&#39;).find(&#39;code&#39;).hide();      $(this).parent().addClass(&#39;code-closed&#39;);    }  });});</code></pre><p>这里可以看到，在点击事件里在<code>pre</code>标签下查找<code>code</code>标签然后对其做显示和隐藏以实现代码的缩放功能。但是使用了<code>code-prettify</code>后，pre下不是直接包裹<code>code</code>标签，所以原来的代码直接对code标签做处理导致了这个bug。</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/upgrade_codeblock_error_1.png"></p><p>所以修改这个bug只需要将原来的代码中的<code>find(&#39;code&#39;)</code>修改为<code>find(&#39;ol&#39;)</code>就可以了。修改后代码如下：</p><pre><code class="javascript">// 代码块收缩$(function () {  var $code_expand = $(&#39;&lt;i class=&quot;fas fa-angle-up code-expand&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#39;);  $(&#39;.code-area&#39;).prepend($code_expand);  $(&#39;.code-expand&#39;).on(&#39;click&#39;, function () {    if ($(this).parent().hasClass(&#39;code-closed&#39;)) {      $(this).siblings(&#39;pre&#39;).find(&#39;ol&#39;).show();      $(this).parent().removeClass(&#39;code-closed&#39;);    } else {      $(this).siblings(&#39;pre&#39;).find(&#39;ol&#39;).hide();      $(this).parent().addClass(&#39;code-closed&#39;);    }  });});</code></pre><h3 id="代码块复制Bug"><a href="#代码块复制Bug" class="headerlink" title="代码块复制Bug"></a>代码块复制Bug</h3><p>1.2.0新增的代码复制功能和<code>code-prettify</code>也存在兼容问题。使用<code>code-prettify</code>后导致复制按钮只能复制第一行代码。</p><p>通过搜索<code>fas fa-copy code_copy</code>找到复制按钮的逻辑在<code>themes\hexo-theme-matery\source\libs\codeBlock\codeCopy.js</code>文件中。</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/upgrade_codeblock_copy_1.png"></p><p><img src="/2019/09/22/Tools/hexo/hexo_help/upgrade_codeblock_copy_2.png"></p><p>从这里的第50行可以看出，复制功能bug和代码块缩放bug原因是差不多的。</p><p>所以将这里的<code>find(&#39;code&#39;)</code>修改为<code>find(&#39;ol&#39;)</code>就可以了。</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/upgrade_codeblock_copy_3.png"></p><h3 id="网页末尾的站点总字数丢失"><a href="#网页末尾的站点总字数丢失" class="headerlink" title="网页末尾的站点总字数丢失"></a>网页末尾的站点总字数丢失</h3><p>更新1.2.0后网页末尾的站点总字数丢失，在<code>hexo-theme-matery</code>目录下搜索发现源码中是存在对应功能的，在博客根目录的<code>themes\hexo-theme-matery\layout\_partial\footer.ejs</code>下。</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/upgrade_wordcount_1.png"></p><p>这里对<code>theme.wordCount.totalCount</code>的值做了判断，于是到<code>themes\hexo-theme-matery\_config.yml</code>查找<code>wordCount</code>相关配置，发现在<code>wordCount</code>下只有一个`enabled属性。</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/upgrade_wordcount_2.png">所以这里为它添加一个<code>wordCount</code>属性。</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/upgrade_wordcount_3.png"></p><p>这样就解决了站点总字数统计丢失的问题</p><h3 id="关于页面的图标位置"><a href="#关于页面的图标位置" class="headerlink" title="关于页面的图标位置"></a>关于页面的图标位置</h3><p>更新后1.2.0后关于界面上里的文章统计图标出现上移导致文字部分被遮挡的问题。</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/upgrade_about_1.png"></p><p>通过搜索<code>文章发布统计图</code>发现是在<code>themes\hexo-theme-matery\languages\zh-CN.yml</code>中定义的<code>postPublishChart</code>的中文名。再继续搜索<code>postPublishChart</code>发现是在<code>themes\hexo-theme-matery\layout\_widget\post-charts.ejs</code>。在<code>post-charts.ejs</code>中搜索<code>postPublishChart</code>，<code>categoriesChart</code>，<code>top10TagsChart</code>在统计的属性内修改<code>top</code>属性。</p><p>修改后如下：</p><p><img src="/2019/09/22/Tools/hexo/hexo_help/upgrade_about_2.png"></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> hexo </tag>
            
            <tag> help </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始hexo之旅</title>
      <link href="/2019/09/20/Tools/hexo/start_hexo/"/>
      <url>/2019/09/20/Tools/hexo/start_hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h1><p>这篇博客主要记录hexo使用中的命令</p><ul><li><p>生成静态页面</p><p>  <code>hexo g</code> 或 <code>hexo generate</code></p></li><li><p>启动本地服务，预览效果</p><p>  <code>hexo s</code> 或 <code>hexo server</code></p></li><li><p>上传博客到GitHub并部署</p><p>  <code>hexo d</code> 或 <code>hexo deploy</code></p></li><li><p>清空本地缓存文件和已生成的静态页面<br>  <code>hexo clean</code></p></li><li><p>显示hexo版本<br>  <code>hexo version</code></p></li><li><p>新建默认文章<br>  <code>hexo new [layout] &lt;title&gt;</code><br>  这里的<code>layout</code>可以省略，使用默认的配置，<code>title</code>不可省略，<code>title</code>可以是中英文，如果title中包含空格，则需要用双引号包裹。<br>  这里执行后会默认在<code>source\_posts</code>目录下生成<code>&lt;title&gt;.md</code>命名的文件。</p></li><li><p>新建指定目录文章<br>  <code>hexo new page --path &lt;path&gt; &lt;title&gt;</code><br>  这里会在指定的目录下生成博客文件。<br>  <img src="/2019/09/20/Tools/hexo/start_hexo/new_page.png" alt="new page 新建博客"><br>  这条命令创建了一个标题为<code>开始hexo之旅</code>的博客，指定目录在<code>_posts/hexo/start_hexe</code>下。<br>  <img src="/2019/09/20/Tools/hexo/start_hexo/start_hexo.png" alt="新建的博客目录结构"><br>  如图可以看到这里生成了一个<code>start_hexo</code>文件夹和<code>start_hexo.md</code>文件。</p></li><li><p>文章添加多标签</p><p>为文章添加多标签可以在md文件头添加</p><pre><code class="md">tags:  - tag1- tag2- tag3</code></pre><p>或者</p><pre><code class="md">tags: [tag1, tag2, tag3]</code></pre><p>这两种方式都能达到相同效果</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改hexo博客的主题</title>
      <link href="/2019/09/20/Tools/hexo/hexo_theme/"/>
      <url>/2019/09/20/Tools/hexo/hexo_theme/</url>
      
        <content type="html"><![CDATA[<h1 id="修改hexo博客的主题"><a href="#修改hexo博客的主题" class="headerlink" title="修改hexo博客的主题"></a>修改hexo博客的主题</h1><p>hexo支持自定义主题，官网的主题商店在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">这里</a>，想要更换默认主题可以在这里挑选喜欢的主题，我这里使用了<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">Matery</a>，这个主题的中文文档非常详细，<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">戳这里</a>。</p><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><ul><li>已搭建成功的Hexo环境<br>搭建教程查看上篇<a href="https://suifengczc.github.io/2019/09/07/hexo/build_hexo/">Github+Hexo搭建博客</a></li></ul><h2 id="2-下载主题"><a href="#2-下载主题" class="headerlink" title="2. 下载主题"></a>2. 下载主题</h2><p>下载主题可以直接从主题的GitHub仓库中直接克隆到博客目录的<code>themes</code>目录下。或者下载主题的zip包解压后复制到博客的<code>themes</code>目录下。<br><img src="/2019/09/20/Tools/hexo/hexo_theme/clone_theme.png" alt="复制主题文件到themes文件夹下"><br>克隆或者复制到<code>themes</code>目录下的主题文件夹是可以重命名的，不一定按照原来的名字。</p><h2 id="3-配置主题"><a href="#3-配置主题" class="headerlink" title="3. 配置主题"></a>3. 配置主题</h2><p>新主题复制到<code>themes</code>目录下后打开博客目录下的<code>_config.yml</code>配置文件，在末尾的<code>theme</code>配置处修改为新主题的名称。<br><img src="/2019/09/20/Tools/hexo/hexo_theme/config_theme.png" alt="配置新主题"></p><p>这时候直接执行</p><pre><code class="cmd">hexo ghexo s</code></pre><p>是会报错的，因为<code>Matery</code>主题还需要先配置一些参数，具体的配置可以参考<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">Matery文档</a>，因为官方文档非常详细这里就不再赘述了。<br>另外可以参考<a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-14" target="_blank" rel="noopener">这个博客</a>，里面包含了许多个性化设置。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github+Hexo搭建博客</title>
      <link href="/2019/09/07/Tools/hexo/build_hexo/"/>
      <url>/2019/09/07/Tools/hexo/build_hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="Github-Hexo搭建博客"><a href="#Github-Hexo搭建博客" class="headerlink" title="Github+Hexo搭建博客"></a>Github+Hexo搭建博客</h1><p>本文介绍了如何使用hexo在GitHub上搭建个人博客</p><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h2><ul><li>git</li><li>Node.js</li><li>Github账号</li><li>Hexo</li></ul><h3 id="1-1Git安装"><a href="#1-1Git安装" class="headerlink" title="1.1Git安装"></a>1.1Git安装</h3><p>从<a href="https://git-scm.com/" target="_blank" rel="noopener">git for windows</a>下载git安装.<br>安装完成后在控制台输入<code>git --version</code>验证是否安装成功</p><h3 id="1-2Node-js"><a href="#1-2Node-js" class="headerlink" title="1.2Node.js"></a>1.2Node.js</h3><p>从<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">Node.js</a>下载对应的版本安装即可。<br>安装完成后在控制台输入<code>node -v</code>来验证是否安装成功，并且环境设置正确。</p><h3 id="1-3Github账号"><a href="#1-3Github账号" class="headerlink" title="1.3Github账号"></a>1.3Github账号</h3><p>Github账号自行注册</p><h3 id="1-4安装Hexo"><a href="#1-4安装Hexo" class="headerlink" title="1.4安装Hexo"></a>1.4安装Hexo</h3><p>Node.js安装成功后在控制台执行<code>npm install -g hexo-cli</code>，npm会自动帮我们完成hexo的安装。<br>安装结束后可以输入<code>hexo version</code>验证是否安装成功<br><img src="/2019/09/07/Tools/hexo/build_hexo/hexo_version.png" alt="hexo version"></p><h2 id="2-创建本地博客目录"><a href="#2-创建本地博客目录" class="headerlink" title="2.创建本地博客目录"></a>2.创建本地博客目录</h2><p>首先在本地目录创建一个自己的博客文件夹，例如我这里的本地目录是<code>D:\My_Blogs</code>，接下来开始初始化hexo目录。</p><p>然后打开控制台cd到博客目录下，执行<code>hexo init</code>命令（或者执行<code>hexo init &lt;folder&gt;</code>指定生成博客的目录，没有指定folder时，hexo会在当前目录下初始化），hexo会自动帮我们生成博客。因为我这里已经创建了<code>D:\My_Blogs</code>目录，所有后续的操作都在<code>D:\test</code>下执行。执行完init命令后会在博客文件夹下生成如下的文件。</p><p><code>scaffolds</code>文件夹是hexo的模板文件夹。<br><code>source</code>文件夹顾名思义是存放博客资源的地方，当我们使用hexo命令创建博客时会在这个目录下生成相应的md文件和同名文件夹用来存放资源。<br><code>themes</code>是hexo的主题文件夹，hexo支持多种自定义博客主题，需要切换主题时可以从GitHub上clone主题资源到这个目录下。</p><p><img src="/2019/09/07/Tools/hexo/build_hexo/hexo_init.png" alt="hexo init"></p><p>到这里其实本地博客已经搭建完成了，接下来执行<code>hexo g</code>命令(<code>hexo generate</code>的简写形式，两者作用相同)，会生成本地的静态页面。<br><img src="/2019/09/07/Tools/hexo/build_hexo/hexo_g.png" alt="hexo g"></p><p>可以看到hexo生成了28个文件，用时827ms。不知道为什么这里的<code>Generated:</code>打印都没有具体文件名<br>这里去看本地的博客目录会发现hexo创建了一个public文件夹，下面是hexo生成的博客静态文件</p><p>再执行<code>hexo s</code>命令（<code>hexo server</code>的简写形式）会启动hexo服务。<br><img src="/2019/09/07/Tools/hexo/build_hexo/hexo_s.png" alt="hexo s"><br>如图，表示服务启动成功了。<br>这时候可以在浏览器访问<code>http://localhost:4000</code>查看博客了，默认情况下本地访问都是这个地址。<br>如图，本地的hexo博客已经搭建完成。<br><img src="/2019/09/07/Tools/hexo/build_hexo/hexo_hello.png" alt="hexo hello"></p><h2 id="3-Github创建博客仓库"><a href="#3-Github创建博客仓库" class="headerlink" title="3.Github创建博客仓库"></a>3.Github创建博客仓库</h2><p>打开GitHub主页，点击+号下的<code>New repository</code>创建一个新的仓库</p><p><img src="/2019/09/07/Tools/hexo/build_hexo/github_newrep.png" alt="新建仓库"></p><p>然后在仓库界面填写相关仓库信息</p><p><img src="/2019/09/07/Tools/hexo/build_hexo/new_rep_name.png" alt="填写仓库名称"><br><img src="/2019/09/07/Tools/hexo/build_hexo/warn.png" width="20" height="20" position="0">踩坑提醒：这里一定要保证填写的repository name是你的GitHub名称+github.io的格式，不要写错。<br>（这里因为我已经创建了suifengczc.github.io的仓库所以提示仓库已存在）<br>否则写错了仓库名称会导致后面访问正式线上博客时出现找不到资源或者布局出错的问题。<br>填写完仓库名称和描述（可选）后直接<code>Create repository</code>就行了。</p><p>GitHub仓库创建完成后复制仓库的地址，如下<br><img src="/2019/09/07/Tools/hexo/build_hexo/clone_url.png" alt="clone url"><br>粘贴到博客目录下的<code>_config.yml</code>文件末尾，如下图所示<br><img src="/2019/09/07/Tools/hexo/build_hexo/hexo_dep.png" alt="设置hexo deploy config"><br><code>type</code> 填git<br><code>repository</code> 值填复制来的仓库地址<br><code>branch</code> 默认填master就行<br><img src="/2019/09/07/Tools/hexo/build_hexo/warn.png" width="20" height="20"> 这里一定要注意，hexo的配置文件中所有的value值和<code>:</code>之间必须要有空格，否则会报错</p><p>然后点击仓库界面的<code>Settings</code>进入仓库的设置界面，拉到最下面有<code>GitHub Pages</code><br>这里的<code>Your site is published at xxxxxxxxxx</code>就是可访问的线上博客地址。<br>把这里的url复制到刚刚打开的<code>_config.yml</code>的开头。如下图所示</p><p><img src="/2019/09/07/Tools/hexo/build_hexo/rep_setting.png"></p><p><img src="/2019/09/07/Tools/hexo/build_hexo/blog_url.png"></p><p><img src="/2019/09/07/Tools/hexo/build_hexo/blog_url_config.png"></p><p>这里配置好后可以准备把本地的博客push到GitHub了</p><h2 id="4-push本地博客到GitHub"><a href="#4-push本地博客到GitHub" class="headerlink" title="4.push本地博客到GitHub"></a>4.push本地博客到GitHub</h2><p>首先使用<code>npm i hexo-deployer-git</code>安装一个hexo的git扩展功能。<br><img src="/2019/09/07/Tools/hexo/build_hexo/npm_git.png" alt="npm install deployer"><br>如图表示安装成功。<br>然后依次执行下面三条命令</p><pre><code class="bat">hexo clean  //清除缓存hexo g  //重新生成博客文件hexo d  //push到GitHub</code></pre><p>执行<code>hexo d</code>的时候会要求输入GitHub账号和密码，输入完成后就push成功了。<br>接下来就可以打开我们的线上博客地址查看最新博客了。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><ul><li><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">https://www.simon96.online/2018/10/12/hexo-tutorial/</a></li><li><a href="https://godweiyang.com/2018/04/13/hexo-blog/" target="_blank" rel="noopener">https://godweiyang.com/2018/04/13/hexo-blog/</a></li><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
