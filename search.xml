<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>source insight 4导入源码</title>
      <link href="/2019/11/17/tools/source_insight/import_project/"/>
      <url>/2019/11/17/tools/source_insight/import_project/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python第三方库</title>
      <link href="/2019/11/15/python/install_lib/"/>
      <url>/2019/11/15/python/install_lib/</url>
      
        <content type="html"><![CDATA[<h1 id="Python第三方库"><a href="#Python第三方库" class="headerlink" title="Python第三方库"></a>Python第三方库</h1><h2 id="为什么使用第三方库"><a href="#为什么使用第三方库" class="headerlink" title="为什么使用第三方库"></a>为什么使用第三方库</h2><p>Python在安装完成后就自带了一些库，以满足日常使用。但开发中总会出现标准库不满足需求的情况或有更优秀的第三方库可用。这是就需要安装第三方库了。</p><h2 id="第三方库的安装与升级"><a href="#第三方库的安装与升级" class="headerlink" title="第三方库的安装与升级"></a>第三方库的安装与升级</h2><h3 id="pip是什么"><a href="#pip是什么" class="headerlink" title="pip是什么"></a>pip是什么</h3><p> 从Python 2 版本 &gt;=2.7.9 或 Python 3 版本 &gt;=3.4 开始，在安装完Python后会自动安装pip。 pip是一个以Python写成的软件包管理系统，它可以安装和管理软件包，目前是推荐的Python包管理工具。</p><h3 id="pip的安装"><a href="#pip的安装" class="headerlink" title="pip的安装"></a>pip的安装</h3><p>如果安装过程中没有勾选安装pip，则需要手动安装pip。</p><p>第一步：用curl下载<a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">get-pip.py</a>，在命令行中执行<code>curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</code>，<code>-o</code>后面用来指定下载路径。</p><p>第二步：在命令行中执行<code>python get-pip.py</code>就能安装上pip。</p><p>参考自：<a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="noopener">pip installation</a></p><h3 id="pip使用帮助"><a href="#pip使用帮助" class="headerlink" title="pip使用帮助"></a>pip使用帮助</h3><p>在命令行中执行<code>pip help</code>可以查看pip的相关帮助信息。pip的使用方式是<code>pip &lt;command&gt; [options]</code>。</p><p><img src="/2019/11/15/python/install_lib/pip_usage.png" alt="pip usage"></p><h3 id="使用pip安装第三方库"><a href="#使用pip安装第三方库" class="headerlink" title="使用pip安装第三方库"></a>使用pip安装第三方库</h3><p>pip安装第三方库命令是<code>pip install XXXX</code>，xxxx是第三方库的名字。例如要安装<code>openpyxl</code>库，就执行<code>pip install openpyxl</code>，稍等一会就安装成功。</p><p><img src="/2019/11/15/python/install_lib/pip_command.png" alt="install openpyxl"></p><h3 id="pip安装指定版本第三方库"><a href="#pip安装指定版本第三方库" class="headerlink" title="pip安装指定版本第三方库"></a>pip安装指定版本第三方库</h3><p>有时候我们可能需要安装某个指定版本的第三方库，可以在安装时指定版本号。安装命令是<code>pip install XXXX==XXX</code></p><p>例如安装指定的3.0.1版本的<code>openpyxl</code>。</p><p><img src="/2019/11/15/python/install_lib/pip_install_version.png" alt="install target version"></p><h3 id="使用pip卸载第三方库"><a href="#使用pip卸载第三方库" class="headerlink" title="使用pip卸载第三方库"></a>使用pip卸载第三方库</h3><p>当安装了错误的第三方库或者不在需要某个第三方库时，可以卸载第三方库。卸载命令是<code>pip uninstall xxxx</code>，例如卸载<code>openpyxl</code>库。</p><p><img src="/2019/11/15/python/install_lib/pip_uninstall.png" alt="uninstall openpyxl"></p><h3 id="列出所有安装的第三方库"><a href="#列出所有安装的第三方库" class="headerlink" title="列出所有安装的第三方库"></a>列出所有安装的第三方库</h3><p>当需要查看安装了哪些第三方库时，可以使用<code>pip list</code>。</p><p><img src="/2019/11/15/python/install_lib/pip_list.png" alt="pip list"></p><h3 id="列出所有可升级第三方库"><a href="#列出所有可升级第三方库" class="headerlink" title="列出所有可升级第三方库"></a>列出所有可升级第三方库</h3><p>当需要查看哪些第三方库可以升级时，可以使用<code>pip list -o</code></p><p><img src="/2019/11/15/python/install_lib/pip_list_upgrade.png" alt="pip list upgrade"></p><h3 id="升级第三方库"><a href="#升级第三方库" class="headerlink" title="升级第三方库"></a>升级第三方库</h3><p>当需要升级某个第三方库时，可以使用<code>pip install -U XXXX</code>或者<code>pip install XXXX --upgrade</code></p><h3 id="查看第三方库的详细信息"><a href="#查看第三方库的详细信息" class="headerlink" title="查看第三方库的详细信息"></a>查看第三方库的详细信息</h3><p>当需要查看某个第三方库的详细信息时，可以使用<code>pip show XXXX</code></p><p><img src="/2019/11/15/python/install_lib/pip_show.png" alt="pip show"></p><h3 id="pip自身的升级"><a href="#pip自身的升级" class="headerlink" title="pip自身的升级"></a>pip自身的升级</h3><p>当pip有升级时可以使用<code>python -m pip install pip --upgrade</code>升级pip到最新版本。</p><h3 id="pip换源"><a href="#pip换源" class="headerlink" title="pip换源"></a>pip换源</h3><p>某些情况下安装某些第三方库时会出现总是下载失败的情况，这是可以试试更换pip源。</p><p>国内可用的其他pip源有：</p><blockquote><p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a><br>中国科技大学：<a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a><br>豆瓣(douban)：<a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a><br>清华大学：<a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a><br>中国科学技术大学：<a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">http://pypi.mirrors.ustc.edu.cn/simple/</a></p></blockquote><p>例如更换pip源为清华源地址的命令是：<code>pip install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple/</code></p><h2 id="第三方库的搜索"><a href="#第三方库的搜索" class="headerlink" title="第三方库的搜索"></a>第三方库的搜索</h2><p>当需要查看第三方库的历史版本，安装命令等信息时可以在<a href="https://pypi.org/" target="_blank" rel="noopener">这个网站</a>搜索。</p><h2 id="特殊第三方库的安装方式"><a href="#特殊第三方库的安装方式" class="headerlink" title="特殊第三方库的安装方式"></a>特殊第三方库的安装方式</h2><h3 id="PIL的安装"><a href="#PIL的安装" class="headerlink" title="PIL的安装"></a>PIL的安装</h3><p>PIL是一个强大流行的第三方图像处理库，但是只支持到Python2.7。后续版本都在<a href="https://github.com/python-pillow/Pillow" target="_blank" rel="noopener">Pillow</a>中维护。</p><p>所以当需要使用PIL库时，实际安装的是Pillow库。</p><p>安装命令是<code>pip install Pillow</code></p><p>安装时使用<code>from PIL import Image</code>引用该库。</p><p>官方文档地址： <a href="https://pillow.readthedocs.io/en/stable/?badge=latest" target="_blank" rel="noopener">https://pillow.readthedocs.io/en/stable/?badge=latest</a> </p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> python lib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime设置文件夹右键菜单</title>
      <link href="/2019/11/12/tools/sublime/add_rightmenu/"/>
      <url>/2019/11/12/tools/sublime/add_rightmenu/</url>
      
        <content type="html"><![CDATA[<h1 id="sublime-text3设置文件夹右键菜单"><a href="#sublime-text3设置文件夹右键菜单" class="headerlink" title="sublime text3设置文件夹右键菜单"></a>sublime text3设置文件夹右键菜单</h1><p>安装完sublime后会默认在右键菜单中添加Open With Sublime Text选项。但是没有应用图标，不够美观，我们可以为它添加图标并且添加文件夹的右键打开方式。</p><h2 id="sublime-text3-添加应用图标"><a href="#sublime-text3-添加应用图标" class="headerlink" title="sublime text3 添加应用图标"></a>sublime text3 添加应用图标</h2><p>第一步：Win+R<code>打开运行，输入</code> regedit <code>，打开注册表</code></p><p>第二步：定位到<code>HKEY_CLASSES_ROOT\*\shell\Open with Sublime Text</code></p><p><img src="/2019/11/12/tools/sublime/add_rightmenu/regedit_1.png" alt="Open with Sublime Text"></p><p>第三步：右击<code>Open With Sublime Text</code>,依次点击<code>新建</code>，<code>字符串值</code>，名称设置为icon。</p><p>第四步：双击<code>icon</code>在弹框中设置数据值为sublime的安装路径。</p><p><img src="/2019/11/12/tools/sublime/add_rightmenu/regedit_2.png" alt="add icon"></p><h2 id="sublime-text3-文件夹右键菜单"><a href="#sublime-text3-文件夹右键菜单" class="headerlink" title="sublime text3 文件夹右键菜单"></a>sublime text3 文件夹右键菜单</h2><p>第一步：Win+R<code>打开运行，输入</code> regedit <code>，打开注册表</code></p><p>第二步：定位到<code>HKEY_CLASSES_ROOT\Directory\shell</code></p><p><img src="/2019/11/12/tools/sublime/add_rightmenu/regedit_3.png" alt="dir shell"></p><p>第三步：在<code>shell</code>上右击选择<code>新建</code>，<code>项</code>，命名为<code>Open with Sublime Text</code>。</p><p>第四步：在新建的<code>Open with Sublime Text</code>上右击选择<code>新建</code>，<code>项</code>，命名为<code>command</code>。</p><p>第五步：修改<code>command</code>中的默认值的数据为<code>sublime安装目录的路径+空格+&quot;%1&quot;</code>，这一步是添加右键的打开方式。</p><p><img src="/2019/11/12/tools/sublime/add_rightmenu/regedit_4.png" alt="dir command"></p><p>第六步：在<code>Open with Sublime Text</code>上右击<code>新建</code>，<code>字符串值</code>，名称修改为<code>icon</code>，数据值修改为sublime的安装目录。这一步是为右键菜单增加图标</p><p><img src="/2019/11/12/tools/sublime/add_rightmenu/regedit_5.png" alt="add icon"></p><p>第七步：全部完成后在任务管理器中重启资源管理器，使右键菜单生效。</p><p><img src="/2019/11/12/tools/sublime/add_rightmenu/regedit_6.png" alt="complete"></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin的作用域函数[译]</title>
      <link href="/2019/11/10/kotlin/scope_function/"/>
      <url>/2019/11/10/kotlin/scope_function/</url>
      
        <content type="html"><![CDATA[<h1 id="Kotlin的作用域函数-译"><a href="#Kotlin的作用域函数-译" class="headerlink" title="Kotlin的作用域函数[译]"></a>Kotlin的作用域函数[译]</h1><h2 id="Kotlin的作用域函数的介绍"><a href="#Kotlin的作用域函数的介绍" class="headerlink" title="Kotlin的作用域函数的介绍"></a>Kotlin的作用域函数的介绍</h2><p>本文时对kotlin官方文档的翻译，<a href="https://www.kotlincn.net/docs/reference/scope-functions.html#scope-functions" target="_blank" rel="noopener">文档地址</a></p><blockquote><p>The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a <a href="https://www.kotlincn.net/docs/reference/lambdas.html" target="_blank" rel="noopener">lambda expression</a> provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called <em>scope functions</em>. There are five of them: <code>let</code>, <code>run</code>, <code>with</code>, <code>apply</code>, and <code>also</code> .</p><p>Basically, these functions do the same: execute a block of code on an object. What’s different is how this object becomes available inside the block and what is the result of the whole expression.</p></blockquote><p>kotlin的官方标准库包含了几个函数，这些函数的作用是在对象的上下文内部执行代码块。当你在提供了lambda表达式的对象中调用这些方法时，这将形成一个临时的作用域。在这个作用域中，你可以访问当前对象而不使用它的变量名。这些方法被称为作用域函数。这里共有5个作用域函数，分别为：<code>let</code>,<code>run</code>,<code>with</code>,<code>apply</code>,<code>also</code>。</p><p>基本上，这些方法都做了相同的事情：在对象上执行代码块。不同之处在于这个对象在代码块内部如何变得可用以及整个表达式的结果是什么。</p><blockquote><p>Here’s a typical usage of a scope function: </p></blockquote><p>这里是一个典型的作用域函数使用方式：</p><pre><code class="kotlin">data class Person(var name: String, var age: Int, var city: String) {    fun moveTo(newCity: String) { city = newCity }    fun incrementAge() { age++ }}fun main() {    //sampleStart    Person(&quot;Alice&quot;, 20, &quot;Amsterdam&quot;).let {        println(it)        it.moveTo(&quot;London&quot;)        it.incrementAge()        println(it)    }    //sampleEnd}</code></pre><blockquote><p>If you write the same without <code>let</code>, you’ll have to introduce a new variable and repeat its name whenever you use it. </p></blockquote><p>如果你不使用<code>let</code>这个作用域函数，你需要定义一个变量并且在每个使用到的地方重复它的名字。</p><pre><code class="kotlin">data class Person(var name: String, var age: Int, var city: String) {    fun moveTo(newCity: String) { city = newCity }    fun incrementAge() { age++ }}fun main() {    //sampleStart    val alice = Person(&quot;Alice&quot;, 20, &quot;Amsterdam&quot;)    println(alice)    alice.moveTo(&quot;London&quot;)    alice.incrementAge()    println(alice)    //sampleEnd}</code></pre><blockquote><p>The scope functions do not introduce any new technical capabilities, but they can make your code more concise and readable. </p></blockquote><p>作用域函数不需要引入任何其他的技术能力，但可以使代码更简明易懂。</p><blockquote><p>Due to the similar nature of scope functions, choosing the right one for your case can be a bit tricky. The choice mainly depends on your intent and the consistency of use in your project. Below we’ll provide detailed descriptions of the distinctions between scope functions and the conventions on their usage.</p></blockquote><p>由于作用域函数的相似性，选择一个合适的作用域函数是一件不容易的事情。这个选择主要依赖于你的意图和在项目中的合理性。下面，我们将详细提供关于作用域函数之间的不同和使用惯例的不同。</p><h2 id="作用域函数的区别"><a href="#作用域函数的区别" class="headerlink" title="作用域函数的区别"></a>作用域函数的区别</h2><blockquote><p>Because the scope functions are all quite similar in nature, it’s important to understand the differences between them. There are two main differences between each scope function: </p><ul><li>The way to refer to the context object </li><li>The return value </li></ul></blockquote><p>由于作用域函数在性质上非常相似，所以明白他们之间的不同非常重要，他们之间有两个主要的不同。</p><ul><li><p>引用上下文对象的方式</p></li><li><p>返回值</p></li></ul><h3 id="上下文对象是this还是it"><a href="#上下文对象是this还是it" class="headerlink" title="上下文对象是this还是it"></a>上下文对象是this还是it</h3><blockquote><p>Inside the lambda of a scope function, the context object is available by a short reference instead of its actual name. Each scope function uses one of two ways to access the context object: as a <a href="https://www.kotlincn.net/docs/reference/lambdas.html#带有接收者的函数字面值" target="_blank" rel="noopener">lambda receiver</a> (<code>this</code>) or as a lambda argument (<code>it</code>). Both provide the same capabilities, so we’ll describe the pros and cons of each for different cases and provide recommendations on their use. </p></blockquote><p>在作用域函数的lambda表达式中，上下文对象可以使用短引用的方式替代变量的真实名称。每个作用域函数使用两种访问上下文对象的方式之一：作为lambda接收者(<code>this</code>)或者作为lambda参数(<code>it</code>)。两者提供了相同的功能，所以我们将描述每一个案例下的优缺点并且提供推荐的用法。</p><pre><code class="kotlin">fun main() {    val str = &quot;Hello&quot;    // this    str.run {        println(&quot;The receiver string length: $length&quot;)        //println(&quot;The receiver string length: ${this.length}&quot;) // does the same    }    // it    str.let {        println(&quot;The receiver string&#39;s length is ${it.length}&quot;)    }}</code></pre><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><blockquote><p> <code>run</code>, <code>with</code>, and <code>apply</code> refer to the context object as a lambda receiver - by keyword <code>this</code>. Hence, in their lambdas, the object is available as it would be in ordinary class functions. In most cases, you can omit <code>this</code> when accessing the members of the receiver object, making the code shorter. On the other hand, if <code>this</code> is omitted, it can be hard to distinguish between the receiver members and external objects or functions. So, having the context object as a receiver (<code>this</code>) is recommended for lambdas that mainly operate on the object members: call its functions or assign properties. </p></blockquote><p><code>run</code>，<code>with</code>，<code>apply</code>通过<code>this</code>关键字引用到上下文对象作为一个lambda接收者。因此，在这些lambda中，该上下文对象就像在普通类方法中一样可用的。在多数情况下，当你访问接收对象的成员时可以忽略<code>this</code>关键字，使得代码更短。另一方面，如果<code>this</code>被省略，这会很难区分接收者的成员和外部对象或方法。因此，更推荐持有上下文对象作为主要操作对象成员的lambda表达式的接收者(<code>this</code>)：调用该对象的方法或指定属性。</p><pre><code class="kotlin">data class Person(var name: String, var age: Int = 0, var city: String = &quot;&quot;)fun main() {    //sampleStart    val adam = Person(&quot;Adam&quot;).apply {         age = 20                       // same as this.age = 20 or adam.age = 20        city = &quot;London&quot;    }    //sampleEnd}</code></pre><h4 id="it"><a href="#it" class="headerlink" title="it"></a>it</h4><blockquote><p> In turn, <code>let</code> and <code>also</code> have the context object as a lambda argument. If the argument name is not specified, the object is accessed by the implicit default name <code>it</code>. <code>it</code> is shorter than <code>this</code> and expressions with <code>it</code> are usually easier for reading. However, when calling the object functions or properties you don’t have the object available implicitly like <code>this</code>. Hence, having the context object as <code>it</code> is better when the object is mostly used as an argument in function calls. <code>it</code> is also better if you use multiple variables in the code block. </p></blockquote><p>相反的，<code>let</code>和<code>also</code>持有上下文对象作为lambda表达式的参数。如果参数名称是非指定的，那么这个对象就使用隐式的默认名称<code>it</code>访问。<code>it</code>比<code>this</code>更短，并且使用<code>it</code>的表达式通常更容易阅读。但是，当调用对象的方法或属性时你没有像<code>this</code>方式一样的隐式可用对象。因此，当主要使用对象作为方法调用中的参数时，最好使用<code>it</code>的方式持有上下文对象。同样如果在代码块中多次使用变量使用<code>it</code>也是更好的方式。</p><pre><code class="kotlin">import kotlin.random.Randomfun writeToLog(message: String) {    println(&quot;INFO: $message&quot;)}fun main() {    //sampleStart    fun getRandomInt(): Int {        return Random.nextInt(100).also {                writeToLog(&quot;getRandomInt() generated value $it&quot;)        }    }    val i = getRandomInt()    //sampleEnd}</code></pre><blockquote><p>Additionally, when you pass the context object as an argument, you can provide a custom name for the context object inside the scope. </p></blockquote><p>另外，当你将上下文对象作为参数传递时，你可以为该对象提供一个在当前作用域内使用的自定义名称。</p><pre><code class="kotlin">import kotlin.random.Randomfun writeToLog(message: String) {    println(&quot;INFO: $message&quot;)}fun main() {    //sampleStart    fun getRandomInt(): Int {        return Random.nextInt(100).also { value -&gt;            writeToLog(&quot;getRandomInt() generated value $value&quot;)        }    }    val i = getRandomInt()    //sampleEnd}</code></pre><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><blockquote><p>The scope functions differ by the result they return</p><ul><li><p><code>apply</code> and <code>also</code> return the context object .</p></li><li><p><code>let</code>, <code>run</code>, and <code>with</code> return the lambda result .</p></li></ul><p>These two options let you choose the proper function depending on what you do next in your code.</p></blockquote><p>作用域函数的不同在于返回结果的不同。</p><ul><li><code>apply</code>和<code>also</code>返回上下文对象</li><li><code>let</code>，<code>run</code>，<code>with</code>返回lambda的结果 </li></ul><p>根据你在后续代码中的行为从两个选项中合适的方法。</p><h4 id="上下文对象"><a href="#上下文对象" class="headerlink" title="上下文对象"></a>上下文对象</h4><blockquote><p> The return value of <code>apply</code> and <code>also</code> is the context object itself. Hence, they can be included into call chains as <em>side steps</em>: you can continue chaining function calls on the same object after them. </p></blockquote><p><code>apply</code>和<code>alse</code>的返回值是上下文对象自身。因此，他们可以被包括到调用链中作为连续步骤：你可以在同一个对象上继续链接方法调用。</p><pre><code class="kotlin">fun main() {    //sampleStart    val numberList = mutableListOf&lt;Double&gt;()    numberList.also { println(&quot;Populating the list&quot;) }        .apply {            add(2.71)            add(3.14)            add(1.0)        }        .also { println(&quot;Sorting the list&quot;) }        .sort()    //sampleEnd    println(numberList)}</code></pre><blockquote><p>They also can be used in return statements of functions returning the context object.</p></blockquote><p>他们同样可以被应用在返回上下文对象的方法return语句中。</p><pre><code class="kotlin">import kotlin.random.Randomfun writeToLog(message: String) {    println(&quot;INFO: $message&quot;)}fun main() {    //sampleStart    fun getRandomInt(): Int {        return Random.nextInt(100).also {            writeToLog(&quot;getRandomInt() generated value $it&quot;)        }    }    val i = getRandomInt()    //sampleEnd}</code></pre><h4 id="Lambda表达式结果"><a href="#Lambda表达式结果" class="headerlink" title="Lambda表达式结果"></a>Lambda表达式结果</h4><blockquote><p><code>let</code>, <code>run</code>, and <code>with</code> return the lambda result. So, you can use them when assigning the result to a variable, chaining operations on the result, and so on. </p></blockquote><p><code>let</code>，<code>run</code>和<code>with</code>都返回lambda的结果。因此，你可以在需要将结果赋值给变量，对结果继续链接操作等等情况下选择这三种作用域函数。</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)    val countEndsWithE = numbers.run {        add(&quot;four&quot;)        add(&quot;five&quot;)        count { it.endsWith(&quot;e&quot;) }    }    println(&quot;There are $countEndsWithE elements that end with e.&quot;)    //sampleEnd}</code></pre><blockquote><p>Additionally, you can ignore the return value and use a scope function to create a temporary scope for variables.</p></blockquote><p>另外，你可以忽略返回值并且使用作用域函数为变量创建临时作用域。</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)    with(numbers) {        val firstItem = first()        val lastItem = last()                println(&quot;First item: $firstItem, last item: $lastItem&quot;)    }    //sampleEnd}</code></pre><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><blockquote><p>To help you choose the right scope function for your case, we’ll describe them in detail and provide usage recommendations. Technically, functions are interchangeable in many cases, so the examples show the conventions that define the common usage style. </p></blockquote><p>为了帮助你选择正确的作用域函数，我们将详细描述他们并且提供使用建议。从技术上讲，在许多情况下作用域函数是互通的，因此下面的例子展示了约定俗成的默认的常用使用方式。</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><blockquote><p><strong>The context object</strong> is available as an argument (<code>it</code>). <strong>The return value</strong> is the lambda result.</p><p><code>let</code> can be used to invoke one or more functions on results of call chains. For example, the following code prints the results of two operations on a collection:</p></blockquote><p>上下文对象可用作参数(<code>it</code>)，返回值是lambda表达式的结果。</p><p><code>let</code>可以用于在调用链的结果上调用一个或多个方法。例如，下面的代码打印了一个集合在两个操作后的结果。</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;)    val resultList = numbers.map { it.length }.filter { it &gt; 3 }    println(resultList)        //sampleEnd}</code></pre><p>使用<code>let</code>，你可以重写成这个形式：</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;)    numbers.map { it.length }.filter { it &gt; 3 }.let {         println(it)        // and more function calls if needed        // 需要的话可以调用其他方法    }     //sampleEnd}</code></pre><blockquote><p> If the code block contains a single function with <code>it</code> as an argument, you can use the method reference (<code>::</code>) instead of the lambda: </p></blockquote><p>如果代码块中只包含单个方法并且使用了<code>it</code>作为参数，那么你可以使用方法引用<code>(::)</code>替代lambda表达式。</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;)    numbers.map { it.length }.filter { it &gt; 3 }.let(::println)    //等效于.let{ println(it) }    //sampleEnd}</code></pre><blockquote><p> <code>let</code> is often used for executing a code block only with non-null values. To perform actions on a non-null object, use the safe call operator <code>?.</code> on it and call <code>let</code> with the actions in its lambda. </p></blockquote><p><code>let</code>通常用于执行仅使用非空值的代码块。为了对非空对象执行操作，应该使用安全操作符<code>?.</code>并且调用<code>let</code>在lambda中执行操作。</p><pre><code class="kotlin">fun processNonNullString(str: String) {}fun main() {    //sampleStart    val str: String? = &quot;Hello&quot;       //processNonNullString(str)       // compilation error: str can be null    val length = str?.let {         // 因为使用了?.操作符，当str为null时不会执行到lambda代码块的内容，        // 保证了processNonNullString()方法不会传入空值        println(&quot;let() called on $it&quot;)                processNonNullString(it)      // OK: &#39;it&#39; is not null inside &#39;?.let { }&#39;        it.length    }    //sampleEnd}</code></pre><blockquote><p>Another case for using <code>let</code> is introducing local variables with a limited scope for improving code readability. To define a new variable for the context object, provide its name as the lambda argument so that it can be used instead of the default <code>it</code>. </p></blockquote><p>另一个使用<code>let</code>的案例是在有限的作用域内引入局部变量以提高代码可读性。为了给上下文对象定义一个新变量，为lambda提供一个名称作为参数这样可以使用新名称而不是默认的<code>it</code>。</p><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><blockquote><p> A non-extension function: <strong>the context object</strong> is passed as an argument, but inside the lambda, it’s available as a receiver (<code>this</code>). <strong>The return value</strong> is the lambda result. </p><p> We recommend <code>with</code> for calling functions on the context object without providing the lambda result. In the code, <code>with</code> can be read as “<em>with this object, do the following.</em>” </p></blockquote><p>一个非拓展方法：上下文对象是作为参数传递的，但是在lambda内部，它作为一个接收者(<code>this</code>)。返回值是lambda的结果。</p><p>我们推荐在不需要提供lambda结果的情况下使用<code>with</code>在上下文对象上调用函数。在代码中<code>with</code>可以解释为“在这个对象上执行如下操作”</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)    with(numbers) {        println(&quot;&#39;with&#39; is called with argument $this&quot;)        println(&quot;It contains $size elements&quot;)    }    //sampleEnd}</code></pre><blockquote><p> Another use case for <code>with</code> is introducing a helper object whose properties or functions will be used for calculating a value. </p></blockquote><p>另一个使用<code>with</code>的案例是引入一个辅助对象其属性和方法可以用于计算值。</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)    val firstAndLast = with(numbers) {        &quot;The first element is ${first()},&quot; +        &quot; the last element is ${last()}&quot;    }    println(firstAndLast)    //sampleEnd}</code></pre><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><blockquote><p><strong>The context object</strong> is available as a receiver (<code>this</code>). <strong>The return value</strong> is the lambda result. </p><p> <code>run</code> does the same as <code>with</code> but invokes as <code>let</code> - as an extension function of the context object. </p><p> <code>run</code> is useful when your lambda contains both the object initialization and the computation of the return value. </p></blockquote><p>上下文对象可用作接收者(<code>this</code>)，返回值是lambda结果。</p><p><code>run</code>和<code>with</code>有相同功能，按照<code>let</code>的调用方式 -作为上下文对象的拓展方法。</p><p><code>run</code>很有效当你的lambda表达式中都包含了对象初始化和返回值的计算。</p><pre><code class="kotlin">class MultiportService(var url: String, var port: Int) {    fun prepareRequest(): String = &quot;Default request&quot;    fun query(request: String): String = &quot;Result for query &#39;$request&#39;&quot;}fun main() {    //sampleStart    val service = MultiportService(&quot;https://example.kotlinlang.org&quot;, 80)    val result = service.run {        port = 8080        query(prepareRequest() + &quot; to port $port&quot;)    }    // the same code written with let() function:    val letResult = service.let {        it.port = 8080        it.query(it.prepareRequest() + &quot; to port ${it.port}&quot;)    }    //sampleEnd    println(result)    println(letResult)}</code></pre><blockquote><p>Besides calling <code>run</code> on a receiver object, you can use it as a non-extension function. Non-extension <code>run</code> lets you execute a block of several statements where an expression is required. </p></blockquote><p>除了在接收者对象上调用<code>run</code>方法之外，你还可以使用它作为非拓展方法。非拓展的<code>run</code>使你可以在需要表达式时执行一个包含多个语句的代码块。</p><pre><code class="kotlin">fun main() {    //sampleStart    val hexNumberRegex = run {        val digits = &quot;0-9&quot;        val hexDigits = &quot;A-Fa-f&quot;        val sign = &quot;+-&quot;        Regex(&quot;[$sign]?[$digits$hexDigits]+&quot;)    }    for (match in hexNumberRegex.findAll(&quot;+1234 -FFFF not-a-number&quot;)) {        println(match.value)    }    //sampleEnd}</code></pre><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><blockquote><p><strong>The context object</strong> is available as a receiver (<code>this</code>). <strong>The return value</strong> is the object itself. </p><p> Use <code>apply</code> for code blocks that don’t return a value and mainly operate on the members of the receiver object. The common case for <code>apply</code> is the object configuration. Such calls can be read as “<em>apply the following assignments to the object.</em>” </p></blockquote><p>上下文对象作为接收者(<code>this</code>)，返回值是上下文对象本身。</p><p><code>apply</code>用于不返回值并且主要操作于接受对象的成员的代码块，常见的<code>apply</code>使用场景是对象的配置。<code>apply</code>方法可以解释为“应用如下的分配到对象”</p><pre><code class="kotlin">data class Person(var name: String, var age: Int = 0, var city: String = &quot;&quot;)fun main() {    //sampleStart    val adam = Person(&quot;Adam&quot;).apply {        age = 32        city = &quot;London&quot;            }    //sampleEnd}</code></pre><blockquote><p>Having the receiver as the return value, you can easily include <code>apply</code> into call chains for more complex processing. </p></blockquote><p>持有接收者作为返回值，你可以更容易地把<code>apply</code>包括到调用链中以实现更复杂的处理。</p><h3 id="also"><a href="#also" class="headerlink" title="also"></a>also</h3><blockquote><p> <strong>The context object</strong> is available as an argument (<code>it</code>). <strong>The return value</strong> is the object itself. </p><p> <code>also</code> is good for performing some actions that take the context object as an argument. Use <code>also</code> for additional actions that don’t alter the object, such as logging or printing debug information. Usually, you can remove the calls of <code>also</code> from the call chain without breaking the program logic. </p><p>When you see <code>also</code> in the code, you can read it as “<em>and also do the following</em>”. </p></blockquote><p>上下文对象作为参数(<code>it</code>)，返回值是上下文对象自身。</p><p><code>also</code>对一些将上下文对象作为参数传递的行为很有用。对于其他不改变上下文对象例如log或者打印调试信息的行为也可以使用<code>also</code>。通常，你可以从调用链中移除<code>also</code>调用而不影响原有程序逻辑。</p><p>当你在代码中看到<code>also</code>时，你可以将其解释为“并且执行如下操作”</p><pre><code class="kotlin">fun main() {    //sampleStart    val numbers = mutableListOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)    numbers        .also { println(&quot;The list elements before adding new one: $it&quot;) }        .add(&quot;four&quot;)    //sampleEnd}</code></pre><h2 id="函数选择"><a href="#函数选择" class="headerlink" title="函数选择"></a>函数选择</h2><blockquote><p>To help you choose the right scope function for your purpose, we provide the table of key differences between them. </p></blockquote><p>为了帮助你选择正确的作用域函数，我们提供了他们的主要区别表</p><table><thead><tr><th align="center">方法名</th><th align="center">对象引用</th><th align="center">返回值</th><th align="left">是否拓展函数</th></tr></thead><tbody><tr><td align="center">let</td><td align="center">it</td><td align="center">Lambda结果</td><td align="left">是</td></tr><tr><td align="center">run</td><td align="center">this</td><td align="center">Lambda结果</td><td align="left">是</td></tr><tr><td align="center">run</td><td align="center">-</td><td align="center">Lambda结果</td><td align="left">否：无上下文对象调用</td></tr><tr><td align="center">with</td><td align="center">this</td><td align="center">Lambda结果</td><td align="left">否：上下文对象作为参数传递</td></tr><tr><td align="center">apply</td><td align="center">this</td><td align="center">Context object</td><td align="left">是</td></tr><tr><td align="center">also</td><td align="center">it</td><td align="center">Context object</td><td align="left">是</td></tr></tbody></table><blockquote><p>Here is a short guide for choosing scope functions depending on the intended purpose: </p><ul><li>Executing a lambda on non-null objects: <code>let</code></li><li>Introducing an expression as a variable in local scope: <code>let</code></li><li>Object configuration: <code>apply</code></li><li>Object configuration and computing the result: <code>run</code></li><li>Running statements where an expression is required: non-extension <code>run</code></li><li>Additional effects: <code>also</code></li><li>Grouping function calls on an object: <code>with</code></li></ul><p>The use cases of different functions overlap, so that you can choose the functions based on the specific conventions used in your project or team.</p><p>Although the scope functions are a way of making the code more concise, avoid overusing them: it can decrease your code readability and lead to errors. Avoid nesting scope functions and be careful when chaining them: it’s easy to get confused about the current context object and the value of <code>this</code> or <code>it</code>.</p></blockquote><p>如下是根据预期目的选择合适作用域函数的简单指南。</p><ul><li>在一个非空对象上执行一个lambda表达式：<code>let</code></li><li>引入一个表达式作为局部作用域中的变量：<code>let</code></li><li>对象配置：<code>apply</code></li><li>对象配置并且计算结果：<code>run</code></li><li>需要表达式的运行语句：非扩展的<code>run</code></li><li>附加效果：<code>also</code></li><li>一个对象上的一组方法调用：<code>with</code></li></ul><p>不同方法之间的使用场景存在重叠的情况，所以你可以根据你的项目或团队指定的使用约定来选择合适的作用域函数。</p><p>虽然作用域函数是使代码更简洁的方法，但应该避免过度使用它们：这会降低代码的可读性并容易导致错误。避免嵌套使用作用域函数并且在链式调用时要注意：因为这很容易导致对当前的上下文对象的混乱和对<code>this</code>，<code>it</code>的混乱。</p><h2 id="takeIf-与-takeUnless"><a href="#takeIf-与-takeUnless" class="headerlink" title="takeIf 与 takeUnless"></a>takeIf 与 takeUnless</h2><blockquote><p>In addition to scope functions, the standard library contains the functions <code>takeIf</code> and <code>takeUnless</code>. These functions let you embed checks of the object state in call chains. </p></blockquote><p>除了作用域函数之外，Kotlin标准库还包含了<code>takeIf</code>和<code>takeUnless</code>两个方法。这两个方法使你可以可以在调用链中检查对象的状态。</p><blockquote><p>When called on an object with a predicate provided, <code>takeIf</code> returns this object if it matches the predicate. Otherwise, it returns <code>null</code>. So, <code>takeIf</code> is a filtering function for a single object. In turn, <code>takeUnless</code> returns the object if it doesn’t match the predicate and <code>null</code> if it does. The object is available as a lambda argument (<code>it</code>). </p></blockquote><p>当在提供了predicate的对象上调用时，<code>takeIf</code>返回对象本身如果它是匹配predicate的。否则，返回<code>null</code>。因此，<code>takeIf</code>是一个对单个对象的过滤方法。相反的，<code>takeUnless</code>返回对象本身如果它不匹配predicate，返回<code>null</code>如果它匹配。这个对象在lambda中作为参数可用(<code>it</code>)。</p><pre><code class="kotlin">import kotlin.random.*fun main() {    //sampleStart    val number = Random.nextInt(100)    val evenOrNull = number.takeIf { it % 2 == 0 }    val oddOrNull = number.takeUnless { it % 2 == 0 }    println(&quot;even: $evenOrNull, odd: $oddOrNull&quot;)    //sampleEnd}</code></pre><blockquote><p>When chaining other functions after <code>takeIf</code> and <code>takeUnless</code>, don’t forget to perform the null check or the safe call (<code>?.</code>) because their return value is nullable. </p></blockquote><p>在<code>takeIf</code>或<code>takeUnless</code>后链接其他方法时不要忘记执行null检查或者使用安全调用符号<code>?.</code>，因为它们的返回值是可为空的。</p><pre><code class="kotlin">fun main() {    //sampleStart    val str = &quot;Hello&quot;    val caps = str.takeIf { it.isNotEmpty() }?.toUpperCase()       //val caps = str.takeIf { it.isNotEmpty() }.toUpperCase() //compilation error    println(caps)    //sampleEnd}</code></pre><blockquote><p><code>takeIf</code> and <code>takeUnless</code> are especially useful together with scope functions. A good case is chaining them with <code>let</code> for running a code block on objects that match the given predicate. To do this, call <code>takeIf</code> on the object and then call <code>let</code> with a safe call (<code>?</code>). For objects that don’t match the predicate, <code>takeIf</code> returns <code>null</code> and <code>let</code> isn’t invoked. </p></blockquote><p><code>takeIf</code>和<code>takeUnless</code>和作用域函数一起使用是非常有用的。一个合适的使用场景是使用<code>let</code>链接它们，用来在一个匹配给定的 predicate 的对象上运行代码块。为了这样做，在对象上调用<code>takeIf</code>然后使用<code>?.</code>调用<code>let</code>。对于不匹配 predicate 的对象，<code>takeIf</code>返回<code>null</code>并且不会被<code>let</code>调用。</p><pre><code class="kotlin">fun main() {    //sampleStart    fun displaySubstringPosition(input: String, sub: String) {        input.indexOf(sub).takeIf { it &gt;= 0 }?.let {            println(&quot;The substring $sub is found in $input.&quot;)            println(&quot;Its start position is $it.&quot;)        }    }    displaySubstringPosition(&quot;010000011&quot;, &quot;11&quot;)    displaySubstringPosition(&quot;010000011&quot;, &quot;12&quot;)    //sampleEnd}</code></pre><blockquote><p>This is how the same function looks without the standard library functions:</p></blockquote><p>下面是不使用标准库函数时的代码：</p><pre><code class="kotlin">fun main() {    //sampleStart    fun displaySubstringPosition(input: String, sub: String) {        val index = input.indexOf(sub)        if (index &gt;= 0) {            println(&quot;The substring $sub is found in $input.&quot;)            println(&quot;Its start position is $index.&quot;)        }    }    displaySubstringPosition(&quot;010000011&quot;, &quot;11&quot;)    displaySubstringPosition(&quot;010000011&quot;, &quot;12&quot;)    //sampleEnd}</code></pre>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
            <tag> scope function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/10/26/hello-world/"/>
      <url>/2019/10/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java ClassLoader的简单介绍</title>
      <link href="/2019/09/28/java/classloader_detail/"/>
      <url>/2019/09/28/java/classloader_detail/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-ClassLoader的简单介绍"><a href="#Java-ClassLoader的简单介绍" class="headerlink" title="Java ClassLoader的简单介绍"></a>Java ClassLoader的简单介绍</h1><p>本文是阅读《深入理解Java虚拟机》第七章类加载器相关部分过程中生成的阅读笔记。简单介绍了ClassLoader的是什么，主要的类型和双亲委派模型。</p><h2 id="ClassLoader是什么"><a href="#ClassLoader是什么" class="headerlink" title="ClassLoader是什么"></a>ClassLoader是什么</h2><blockquote><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p><p>​                                                                                                                    –《深入理解Java虚拟机》（周志明）</p></blockquote><p>ClassLoader就是这里提到的类加载器。类加载器的作用就是根据类的全限定名获取类的二进制字节流。这个动作在Java虚拟机的外部实现。</p><h2 id="类与类加载器的关系"><a href="#类与类加载器的关系" class="headerlink" title="类与类加载器的关系"></a>类与类加载器的关系</h2><p>类加载器除了加载类的作用外，还和被加载的类本身共同确保类的唯一性。对于两个相同的Class文件，当使用不同的类加载器加载时他们就i是不同的。</p><p>例如当使用了不同ClassLoader加载同一个类时，会导致instanceof的结果为false。</p><pre><code class="java">package com.suifeng.loader;import java.io.IOException;import java.io.InputStream;public class ClassLoaderTest {    public static void main(String[] args) throws Exception{        ClassLoader myClassLoader = new ClassLoader() {            @Override            public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {                try {                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;                    InputStream is = getClass().getResourceAsStream(fileName);                    if (is == null) {                        return super.loadClass(name);                    }                    byte[] b = new byte[is.available()];                    is.read(b);                    return defineClass(name, b, 0, b.length);                } catch (IOException e) {                    e.printStackTrace();                    throw new ClassNotFoundException(name);                }            }        };        Class&lt;?&gt; aClass = myClassLoader.loadClass(&quot;com.suifeng.loader.TestClass&quot;);        Object obj = aClass.newInstance();        System.out.println(obj.getClass());        System.out.println(obj instanceof com.suifeng.loader.TestClass);    }}</code></pre><p>输出结果为</p><pre><code>&gt; class com.suifeng.loader.TestClass&gt; false</code></pre><p>可以看到这里的obj是TestClass的对象，但使用instanceof关键字判断时仍然返回false。这是因为使用了不同类加载器jvm将他们识别为两个不同的类。obj是自定义类加载的，而另一个是由系统应用程序类加载器加载的。</p><h2 id="类加载器类型"><a href="#类加载器类型" class="headerlink" title="类加载器类型"></a>类加载器类型</h2><p>Java提供了三种类加载器。分别是<code>启动类加载器</code>，<code>扩展类加载器</code>，<code>应用程序类加载器</code>。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> ClassLoader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo踩坑记录和优化</title>
      <link href="/2019/09/22/hexo/hexo_help/"/>
      <url>/2019/09/22/hexo/hexo_help/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo踩坑记录和优化"><a href="#hexo踩坑记录和优化" class="headerlink" title="hexo踩坑记录和优化"></a>hexo踩坑记录和优化</h1><h2 id="本地预览图片丢失"><a href="#本地预览图片丢失" class="headerlink" title="本地预览图片丢失"></a>本地预览图片丢失</h2><p>当新建了博客编写完后执行<code>hexo g</code>和<code>hexo s</code>预览文章发现所有的图片都丢失了，无法正常加载。chrome中按<code>F12</code>查看发现<code>hexo-asset-image</code>插件没有正确地转换图片地址</p><p><img src="/2019/09/22/hexo/hexo_help/error_src.png" alt="错误图片地址"></p><p>而且生成的资源下也不包含任何图片信息。</p><p><img src="/2019/09/22/hexo/hexo_help/no_src.png" alt="无图片资源"></p><p>一开始在这个<a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">博客</a>下找到了解决方案。</p><p>找到博客根目录下的<code>/node_modules/hexo-asset-image/index.js</code>文件，将其中的代码修改正博客中的代码，贴上代码如下：</p><pre><code class="js">&#39;use strict&#39;;var cheerio = require(&#39;cheerio&#39;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string--123456794563543543543545435function getPosition(str, m, i) {  return str.split(m, i).join(m).length;}var version = String(hexo.version).split(&#39;.&#39;);hexo.extend.filter.register(&#39;after_post_render&#39;, function(data){  var config = hexo.config;  if(config.post_asset_folder){        var link = data.permalink;    if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)       var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;    else       var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;    // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.    var endPos = link.lastIndexOf(&#39;/&#39;) + 1;    link = link.substring(beginPos, endPos);    var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];    for(var i = 0; i &lt; toprocess.length; i++){      var key = toprocess[i];      var $ = cheerio.load(data[key], {        ignoreWhitespace: false,        xmlMode: false,        lowerCaseTags: false,        decodeEntities: false      });      $(&#39;img&#39;).each(function(){        if ($(this).attr(&#39;src&#39;)){            // For windows style path, we replace &#39;\&#39; to &#39;/&#39;.            var src = $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;/&#39;);            if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;               !/^\s*\//.test(src)) {              // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.              // In addition, to support multi-level local directory.              var linkArray = link.split(&#39;/&#39;).filter(function(elem){                return elem != &#39;&#39;;              });              var srcArray = src.split(&#39;/&#39;).filter(function(elem){                return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;              });              if(srcArray.length &gt; 1)                srcArray.shift();              src = srcArray.join(&#39;/&#39;);              $(this).attr(&#39;src&#39;, config.root + link + src);              console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);            }        }else{            console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);            console.info&amp;&amp;console.info($(this));        }      });      data[key] = $.html();    }  }});</code></pre><p>但是这个解决方案其实是有问题</p><p><img src="/2019/09/22/hexo/hexo_help/error_src_1.png" alt="方案1"></p><p>可以看到这里的<code>src</code>资源路径还是错误的。原因是这里的方案只支持Hexo的标签方式(Hexo的标签引用<a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="noopener">看这里</a>)的引用，对于markdown的引用方式还是不支持。如果把这里的图片引入方式修改为Hexo的标签方式<code></code>就可以正常显示了。</p><p>但是这有一个问题就是使用标签方式在markdown中无法直接预览效果。</p><p>所以我就基于这个解决方案做了修改。代码如下：</p><pre><code class="javascript">&#39;use strict&#39;;var cheerio = require(&#39;cheerio&#39;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) {    return str.split(m, i).join(m).length;}var version = String(hexo.version).split(&#39;.&#39;);hexo.extend.filter.register(&#39;after_post_render&#39;, function (data) {    var config = hexo.config;    if (config.post_asset_folder) {        var link = data.permalink;        if (version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)            var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;        else            var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;        // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.        var endPos = link.lastIndexOf(&#39;/&#39;) + 1;        link = link.substring(beginPos, endPos);        var beginDir = getPosition(link, &quot;/&quot;, 2)        var endDir = link.length        var srcDir = link.substring(beginDir, endDir)        var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];        for (var i = 0; i &lt; toprocess.length; i++) {            var key = toprocess[i];            var $ = cheerio.load(data[key], {                ignoreWhitespace: false,                xmlMode: false,                lowerCaseTags: false,                decodeEntities: false            });            $(&#39;img&#39;).each(function () {                if ($(this).attr(&#39;src&#39;)) {                    // For windows style path, we replace &#39;\&#39; to &#39;/&#39;.                    var src = $(this).attr(&#39;src&#39;)                    src = src.replace(&#39;\\&#39;, &#39;/&#39;);                    var b1 = !/http[s]*.*|\/\/.*/.test(src)                    if (b1) {                        // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.                        // In addition, to support multi-level local directory.                        var linkArray = link.split(&#39;/&#39;).filter(function (elem) {                            return elem != &#39;&#39;;                        });                        var srcArray = src.split(&#39;/&#39;).filter(function (elem) {                            return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;                        });                        if (srcArray.length &gt; 1)                            srcArray.shift();                        var mSrc = srcArray.join(&#39;/&#39;);                        var realLink = srcDir + mSrc                        $(this).attr(&#39;src&#39;, realLink);                        console.info &amp;&amp; console.info(&quot;update link as:--&gt;&quot; + realLink);                    }                } else {                    console.info &amp;&amp; console.info(&quot;no src attr, skipped...&quot;);                    console.info &amp;&amp; console.info($(this));                }            });            data[key] = $.html();        }    }});    </code></pre><p>这样就可以支持markdown的图片引入了</p><p>效果如下：</p><p><img src="/2019/09/22/hexo/hexo_help/good_src.png" alt="正常显示"></p><h2 id="代码行号丢失"><a href="#代码行号丢失" class="headerlink" title="代码行号丢失"></a>代码行号丢失</h2><p>按照官网文档的推荐使用<a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a>作为代码高亮插件，但是按照官网的配置发现预览网页中没有行号。</p><p>需要做如下修改，打开主题的<code>themes\hexo-theme-matery\source\css\matery.css</code>文件，修改第95~111行如下</p><pre><code class="css">pre {    padding: 1.5rem 1.5rem 1.5rem 3.3rem !important;    margin: 1rem 0 !important;    background: #272822;    overflow: auto;    border-radius: 0.35rem;    tab-size: 4;}code {    padding: 1px 5px;    font-family: Inconsolata, Monaco, Consolas, &#39;Courier New&#39;, Courier, monospace;    /* font-size: 0.91rem;*/    color: #e96900;    background-color: #f8f8f8;    border-radius: 2px;}</code></pre><p>重新生成预览页面就正常了</p><h2 id="代码行号错位"><a href="#代码行号错位" class="headerlink" title="代码行号错位"></a>代码行号错位</h2><p>当代码中存在较长代码自动换行时会导致代码行号与代码不对应。</p><p>使用<code>code-prettify</code>代替</p><h2 id="更换代码高亮插件"><a href="#更换代码高亮插件" class="headerlink" title="更换代码高亮插件"></a>更换代码高亮插件</h2><p>因为<code>hexo-prism-plugin</code>在行号显示和复制代码丢失缩进和换行的问题，所以决定更换代码高亮插件为<a href="https://github.com/google/code-prettify" target="_blank" rel="noopener">code-prettify</a>。</p><p>从<a href="https://github.com/google/code-prettify" target="_blank" rel="noopener">code-prettify</a>clone下来最新代码，复制<code>code-prettify\src\prettify.js</code>文件到博客主题的<code>source\js</code>下</p><p><img src="/2019/09/22/hexo/hexo_help/copy_prettifyjs.png" alt="复制prettify.js"></p><p>然后复制<code>code-prettify\styles\sons-of-obsidian.css</code>文件到博客的<code>source\css</code>下（这里是使用了<code>sons-of-obsidian</code>代码高亮主题，如果要使用默认主题的话就复制<code>code-prettify\src\prettify.css</code>到这个目录下）。</p><p>然后打开<code>themes\hexo-theme-matery\layout\_partial\head.ejs</code>文件，增加引用新css的代码</p><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%- config.root %&gt;css/sons-of-obsidian.css&quot; media=&quot;screen&quot; type=&quot;text/css&quot;&gt;</code></pre><p> 如果用的是默认的css，这里就设置为对应的css就好了。</p><p>另外很重要的一点是这里还需要添加一段style代码：</p><pre><code class="html">&lt;style&gt;     li.L0, li.L1, li.L2, li.L3, li.L4, li.L5, li.L6, li.L7, li.L8, li.L9    { list-style-type: decimal !important }&lt;/style&gt;</code></pre><p>这其实是为了解决<code>code-prettify</code>的行号bug，不然会出现在代码块中只有一个点但没有代码行号的情况。</p><p>接着打开<code>themes\hexo-theme-matery\layout\_partial\footer.ejs</code>文件，增加加载<code>prettify.js</code>的代码：</p><pre><code class="html">&lt;script src=&quot;&lt;%- config.root %&gt;js/prettify.js&quot;&gt;&lt;/script&gt;</code></pre><p>再给<code>pre</code>标签增加<code>prettyprint</code>和<code>linenums</code>这两个css的class</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;    $(document).ready(function(){        $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;);            prettyPrint();    })&lt;/script&gt;</code></pre><p>最后要记得把博客根目录下的<code>_config.yml</code>中highlight相关的配置都修改为false</p><p>做完这些后就可以执行<code>hexo g</code>和<code>hexo s</code>预览一下效果了，代码块应该是能正常工作了</p><p>参考自：</p><ol><li><p>[<a href="http://masikkk.com/article/hexo-12-google-code-prettify/" target="_blank" rel="noopener">Hexo博客(12)使用google-code-prettify代码高亮</a>]</p></li><li><p><a href="https://www.v2ex.com/t/32260" target="_blank" rel="noopener">https://www.v2ex.com/t/32260</a></p></li></ol><p>下面是我自己对主题的一些修改:</p><h3 id="去除代码隔行背景色"><a href="#去除代码隔行背景色" class="headerlink" title="去除代码隔行背景色"></a>去除代码隔行背景色</h3><p>去除代码的隔行不同背景色，把<code>sons-of-obsidian.css</code>里的69~71行代码注释掉。被注释代码如下</p><pre><code class="css">li.L1, li.L3, li.L5, li.L7, li.L9 {    background: #111;}</code></pre><h3 id="去除代码下背景色"><a href="#去除代码下背景色" class="headerlink" title="去除代码下背景色"></a>去除代码下背景色</h3><p>去除每行代码的背景色，通过查看style发现是在<code>matery.css</code>里的<code>pre code</code>里的<code>background-color</code>控制的，所以这里把<code>background-color</code>的alpha值设为0就好了</p><p>更正：这里的<code>background-color</code>值应该修改为#00000000，否则在其他背景色下还是能看到。</p><p><img src="/2019/09/22/hexo/hexo_help/code_bg.png" alt="代码背景色"></p><p><img src="/2019/09/22/hexo/hexo_help/code_bg_1.png" alt="代码取消背景色"></p><h3 id="修复代码块复制后丢失缩进的问题"><a href="#修复代码块复制后丢失缩进的问题" class="headerlink" title="修复代码块复制后丢失缩进的问题"></a>修复代码块复制后丢失缩进的问题</h3><p><code>matery</code>还有这样一个bug，当复制的代码数量大于主题的<code>_config.yml</code>下的<code>copyright</code>中配置的<code>minCharNumber</code>阈值时会导致粘贴时代码丢失缩进，排查后解决方案如下：在<code>themes\hexo-theme-matery\layout\_partial\post-detail.ejs</code>代码中为<code>newdiv</code>增加<code>newdiv.style.whiteSpace = &#39;pre&#39;</code>属性。</p><pre><code class="javascript">// create a div outside of the visible area and fill it with the selected text.var bodyElement = document.getElementsByTagName(&#39;body&#39;)[0];var newdiv = document.createElement(&#39;div&#39;);newdiv.style.position = &#39;absolute&#39;;newdiv.style.left = &#39;-99999px&#39;;newdiv.style.whiteSpace = &#39;pre&#39;; //增加这个属性，以防止空格缩进被去除bodyElement.appendChild(newdiv);var cloneContents = selection.getRangeAt(0).cloneContents()newdiv.appendChild(cloneContents);</code></pre><h3 id="修改代码块背景色"><a href="#修改代码块背景色" class="headerlink" title="修改代码块背景色"></a>修改代码块背景色</h3><p>默认的代码背景色是黑色的，看着眼睛不舒服，所以修改为idea的默认背景色<code>#2B2B2B</code>。对代码块检查发现代码块背景色在<code>sons-of-obsidian.css</code>的61行的<code>.prettyprint</code>里的<code>background</code>属性。</p><p><img src="/2019/09/22/hexo/hexo_help/code_block_bg_1.png" alt="black_bg"></p><p>所以打开博客根目录下的<code>themes\hexo-theme-matery\source\css\sons-of-obsidian.css</code>，修改 <code>.prettyprint</code>的<code>background</code>属性为<code>#2B2B2B</code>。</p><p><img src="/2019/09/22/hexo/hexo_help/code_block_bg_2.png" alt="black_bg"></p><p>修改完成后直接刷新界面就能看到修改后的效果了。</p><p><img src="/2019/09/22/hexo/hexo_help/code_block_bg_3.png" alt="black_bg"> </p><p>这样看着就舒服多了。</p><h2 id="线上博客异常"><a href="#线上博客异常" class="headerlink" title="线上博客异常"></a>线上博客异常</h2><p>本地博客push到线上后发现界面排版错误，所有图片无法加载，其实是因为GitHub上的仓库名称命名错误。</p><p>仓库名称应该命名为[GitHub name].github.io</p><h2 id="更新matery1-2-0导致Bug"><a href="#更新matery1-2-0导致Bug" class="headerlink" title="更新matery1.2.0导致Bug"></a>更新matery1.2.0导致Bug</h2><p>刚刚更新了matery的1.2.0版本，导致博客中出现了一些预期之外的bug，下面记录一下具体的Bug和修复记录。</p><h3 id="代码块缩放异常"><a href="#代码块缩放异常" class="headerlink" title="代码块缩放异常"></a>代码块缩放异常</h3><p>matery1.2.0在代码块中增加了代码块的缩放和复制功能，但是这个功能和<code>code-prettify</code>有冲突，导致缩放代码块时代码消失，但代码行号仍然保留的bug。</p><p><img src="/2019/09/22/hexo/hexo_help/upgrade_codeblock_error.png" alt="codeblock error"></p><p>通过搜索<code>fas fa-angle-up code-expand</code>发现这个关键字只在<code>themes\hexo-theme-matery\source\libs\codeBlock\codeShrink.js</code>被使用，这里设置了代码缩放按钮的点击事件。</p><pre><code class="js">// 代码块收缩$(function () {  var $code_expand = $(&#39;&lt;i class=&quot;fas fa-angle-up code-expand&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#39;);  $(&#39;.code-area&#39;).prepend($code_expand);  $(&#39;.code-expand&#39;).on(&#39;click&#39;, function () {    if ($(this).parent().hasClass(&#39;code-closed&#39;)) {      $(this).siblings(&#39;pre&#39;).find(&#39;code&#39;).show();      $(this).parent().removeClass(&#39;code-closed&#39;);    } else {      $(this).siblings(&#39;pre&#39;).find(&#39;code&#39;).hide();      $(this).parent().addClass(&#39;code-closed&#39;);    }  });});</code></pre><p>这里可以看到，在点击事件里在<code>pre</code>标签下查找<code>code</code>标签然后对其做显示和隐藏以实现代码的缩放功能。但是使用了<code>code-prettify</code>后，pre下不是直接包裹<code>code</code>标签，所以原来的代码直接对code标签做处理导致了这个bug。</p><p><img src="/2019/09/22/hexo/hexo_help/upgrade_codeblock_error_1.png" alt></p><p>所以修改这个bug只需要将原来的代码中的<code>find(&#39;code&#39;)</code>修改为<code>find(&#39;ol&#39;)</code>就可以了。修改后代码如下：</p><pre><code class="javascript">// 代码块收缩$(function () {  var $code_expand = $(&#39;&lt;i class=&quot;fas fa-angle-up code-expand&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&#39;);  $(&#39;.code-area&#39;).prepend($code_expand);  $(&#39;.code-expand&#39;).on(&#39;click&#39;, function () {    if ($(this).parent().hasClass(&#39;code-closed&#39;)) {      $(this).siblings(&#39;pre&#39;).find(&#39;ol&#39;).show();      $(this).parent().removeClass(&#39;code-closed&#39;);    } else {      $(this).siblings(&#39;pre&#39;).find(&#39;ol&#39;).hide();      $(this).parent().addClass(&#39;code-closed&#39;);    }  });});</code></pre><h3 id="代码块复制Bug"><a href="#代码块复制Bug" class="headerlink" title="代码块复制Bug"></a>代码块复制Bug</h3><p>1.2.0新增的代码复制功能和<code>code-prettify</code>也存在兼容问题。使用<code>code-prettify</code>后导致复制按钮只能复制第一行代码。</p><p>通过搜索<code>fas fa-copy code_copy</code>找到复制按钮的逻辑在<code>themes\hexo-theme-matery\source\libs\codeBlock\codeCopy.js</code>文件中。</p><p><img src="/2019/09/22/hexo/hexo_help/upgrade_codeblock_copy_1.png" alt></p><p><img src="/2019/09/22/hexo/hexo_help/upgrade_codeblock_copy_2.png" alt></p><p>从这里的第50行可以看出，复制功能bug和代码块缩放bug原因是差不多的。</p><p>所以将这里的<code>find(&#39;code&#39;)</code>修改为<code>find(&#39;ol&#39;)</code>就可以了。</p><p><img src="/2019/09/22/hexo/hexo_help/upgrade_codeblock_copy_3.png" alt></p><h3 id="网页末尾的站点总字数丢失"><a href="#网页末尾的站点总字数丢失" class="headerlink" title="网页末尾的站点总字数丢失"></a>网页末尾的站点总字数丢失</h3><p>更新1.2.0后网页末尾的站点总字数丢失，在<code>hexo-theme-matery</code>目录下搜索发现源码中是存在对应功能的，在博客根目录的<code>themes\hexo-theme-matery\layout\_partial\footer.ejs</code>下。</p><p><img src="/2019/09/22/hexo/hexo_help/upgrade_wordcount_1.png" alt></p><p>这里对<code>theme.wordCount.totalCount</code>的值做了判断，于是到<code>themes\hexo-theme-matery\_config.yml</code>查找<code>wordCount</code>相关配置，发现在<code>wordCount</code>下只有一个`enabled属性。</p><p><img src="/2019/09/22/hexo/hexo_help/upgrade_wordcount_2.png" alt>所以这里为它添加一个<code>wordCount</code>属性。</p><p><img src="/2019/09/22/hexo/hexo_help/upgrade_wordcount_3.png" alt></p><p>这样就解决了站点总字数统计丢失的问题</p><h3 id="关于页面的图标位置"><a href="#关于页面的图标位置" class="headerlink" title="关于页面的图标位置"></a>关于页面的图标位置</h3><p>更新后1.2.0后关于界面上里的文章统计图标出现上移导致文字部分被遮挡的问题。</p><p><img src="/2019/09/22/hexo/hexo_help/upgrade_about_1.png" alt></p><p>通过搜索<code>文章发布统计图</code>发现是在<code>themes\hexo-theme-matery\languages\zh-CN.yml</code>中定义的<code>postPublishChart</code>的中文名。再继续搜索<code>postPublishChart</code>发现是在<code>themes\hexo-theme-matery\layout\_widget\post-charts.ejs</code>。在<code>post-charts.ejs</code>中搜索<code>postPublishChart</code>，<code>categoriesChart</code>，<code>top10TagsChart</code>在统计的属性内修改<code>top</code>属性。</p><p>修改后如下：</p><p><img src="/2019/09/22/hexo/hexo_help/upgrade_about_2.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> help </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始hexo之旅</title>
      <link href="/2019/09/20/hexo/start_hexo/"/>
      <url>/2019/09/20/hexo/start_hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h1><p>这篇博客主要记录hexo使用中的命令</p><ul><li><p>生成静态页面</p><p>  <code>hexo g</code> 或 <code>hexo generate</code></p></li><li><p>启动本地服务，预览效果</p><p>  <code>hexo s</code> 或 <code>hexo server</code></p></li><li><p>上传博客到GitHub并部署</p><p>  <code>hexo d</code> 或 <code>hexo deploy</code></p></li><li><p>清空本地缓存文件和已生成的静态页面<br>  <code>hexo clean</code></p></li><li><p>显示hexo版本<br>  <code>hexo version</code></p></li><li><p>新建默认文章<br>  <code>hexo new [layout] &lt;title&gt;</code><br>  这里的<code>layout</code>可以省略，使用默认的配置，<code>title</code>不可省略，<code>title</code>可以是中英文，如果title中包含空格，则需要用双引号包裹。<br>  这里执行后会默认在<code>source\_posts</code>目录下生成<code>&lt;title&gt;.md</code>命名的文件。</p></li><li><p>新建指定目录文章<br>  <code>hexo new page --path &lt;path&gt; &lt;title&gt;</code><br>  这里会在指定的目录下生成博客文件。<br>  <img src="/2019/09/20/hexo/start_hexo/new_page.png" alt="new page 新建博客"><br>  这条命令创建了一个标题为<code>开始hexo之旅</code>的博客，指定目录在<code>_posts/hexo/start_hexe</code>下。<br>  <img src="/2019/09/20/hexo/start_hexo/start_hexo.png" alt="新建的博客目录结构"><br>  如图可以看到这里生成了一个<code>start_hexo</code>文件夹和<code>start_hexo.md</code>文件。</p></li><li><p>文章添加多标签</p><p>为文章添加多标签可以在md文件头添加</p><pre><code>tags: - tag1- tag2- tag3</code></pre><p>或者</p><pre><code>tags: [tag1, tag2, tag3]</code></pre><p>这两种方式都能达到相同效果</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改hexo博客的主题</title>
      <link href="/2019/09/20/hexo/hexo_theme/"/>
      <url>/2019/09/20/hexo/hexo_theme/</url>
      
        <content type="html"><![CDATA[<h1 id="修改hexo博客的主题"><a href="#修改hexo博客的主题" class="headerlink" title="修改hexo博客的主题"></a>修改hexo博客的主题</h1><p>hexo支持自定义主题，官网的主题商店在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">这里</a>，想要更换默认主题可以在这里挑选喜欢的主题，我这里使用了<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">Matery</a>，这个主题的中文文档非常详细，<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">戳这里</a>。</p><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><ul><li>已搭建成功的Hexo环境<br>搭建教程查看上篇<a href="https://suifengczc.github.io/2019/09/07/hexo/build_hexo/">Github+Hexo搭建博客</a></li></ul><h2 id="2-下载主题"><a href="#2-下载主题" class="headerlink" title="2. 下载主题"></a>2. 下载主题</h2><p>下载主题可以直接从主题的GitHub仓库中直接克隆到博客目录的<code>themes</code>目录下。或者下载主题的zip包解压后复制到博客的<code>themes</code>目录下。<br><img src="/2019/09/20/hexo/hexo_theme/clone_theme.png" alt="复制主题文件到themes文件夹下"><br>克隆或者复制到<code>themes</code>目录下的主题文件夹是可以重命名的，不一定按照原来的名字。</p><h2 id="3-配置主题"><a href="#3-配置主题" class="headerlink" title="3. 配置主题"></a>3. 配置主题</h2><p>新主题复制到<code>themes</code>目录下后打开博客目录下的<code>_config.yml</code>配置文件，在末尾的<code>theme</code>配置处修改为新主题的名称。<br><img src="/2019/09/20/hexo/hexo_theme/config_theme.png" alt="配置新主题"></p><p>这时候直接执行</p><pre><code>hexo ghexo s</code></pre><p>是会报错的，因为<code>Matery</code>主题还需要先配置一些参数，具体的配置可以参考<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">Matery文档</a>，因为官方文档非常详细这里就不再赘述了。<br>另外可以参考<a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-14" target="_blank" rel="noopener">这个博客</a>，里面包含了许多个性化设置。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github+Hexo搭建博客</title>
      <link href="/2019/09/07/hexo/build_hexo/"/>
      <url>/2019/09/07/hexo/build_hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="Github-Hexo搭建博客"><a href="#Github-Hexo搭建博客" class="headerlink" title="Github+Hexo搭建博客"></a>Github+Hexo搭建博客</h1><p>本文介绍了如何使用hexo在GitHub上搭建个人博客</p><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h2><ul><li>git</li><li>Node.js</li><li>Github账号</li><li>Hexo</li></ul><h3 id="1-1Git安装"><a href="#1-1Git安装" class="headerlink" title="1.1Git安装"></a>1.1Git安装</h3><p>从<a href="https://git-scm.com/" target="_blank" rel="noopener">git for windows</a>下载git安装.<br>安装完成后在控制台输入<code>git --version</code>验证是否安装成功</p><h3 id="1-2Node-js"><a href="#1-2Node-js" class="headerlink" title="1.2Node.js"></a>1.2Node.js</h3><p>从<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">Node.js</a>下载对应的版本安装即可。<br>安装完成后在控制台输入<code>node -v</code>来验证是否安装成功，并且环境设置正确。</p><h3 id="1-3Github账号"><a href="#1-3Github账号" class="headerlink" title="1.3Github账号"></a>1.3Github账号</h3><p>Github账号自行注册</p><h3 id="1-4安装Hexo"><a href="#1-4安装Hexo" class="headerlink" title="1.4安装Hexo"></a>1.4安装Hexo</h3><p>Node.js安装成功后在控制台执行<code>npm install -g hexo-cli</code>，npm会自动帮我们完成hexo的安装。<br>安装结束后可以输入<code>hexo version</code>验证是否安装成功<br><img src="/2019/09/07/hexo/build_hexo/hexo_version.png" alt="hexo version"></p><h2 id="2-创建本地博客目录"><a href="#2-创建本地博客目录" class="headerlink" title="2.创建本地博客目录"></a>2.创建本地博客目录</h2><p>首先在本地目录创建一个自己的博客文件夹，例如我这里的本地目录是<code>D:\My_Blogs</code>，接下来开始初始化hexo目录。</p><p>然后打开控制台cd到博客目录下，执行<code>hexo init</code>命令（或者执行<code>hexo init &lt;folder&gt;</code>指定生成博客的目录，没有指定folder时，hexo会在当前目录下初始化），hexo会自动帮我们生成博客。因为我这里已经创建了<code>D:\My_Blogs</code>目录，所有后续的操作都在<code>D:\test</code>下执行。执行完init命令后会在博客文件夹下生成如下的文件。</p><p><code>scaffolds</code>文件夹是hexo的模板文件夹。<br><code>source</code>文件夹顾名思义是存放博客资源的地方，当我们使用hexo命令创建博客时会在这个目录下生成相应的md文件和同名文件夹用来存放资源。<br><code>themes</code>是hexo的主题文件夹，hexo支持多种自定义博客主题，需要切换主题时可以从GitHub上clone主题资源到这个目录下。</p><p><img src="/2019/09/07/hexo/build_hexo/hexo_init.png" alt="hexo init"></p><p>到这里其实本地博客已经搭建完成了，接下来执行<code>hexo g</code>命令(<code>hexo generate</code>的简写形式，两者作用相同)，会生成本地的静态页面。<br><img src="/2019/09/07/hexo/build_hexo/hexo_g.png" alt="hexo g"></p><p>可以看到hexo生成了28个文件，用时827ms。不知道为什么这里的<code>Generated:</code>打印都没有具体文件名<br>这里去看本地的博客目录会发现hexo创建了一个public文件夹，下面是hexo生成的博客静态文件</p><p>再执行<code>hexo s</code>命令（<code>hexo server</code>的简写形式）会启动hexo服务。<br><img src="/2019/09/07/hexo/build_hexo/hexo_s.png" alt="hexo s"><br>如图，表示服务启动成功了。<br>这时候可以在浏览器访问<code>http://localhost:4000</code>查看博客了，默认情况下本地访问都是这个地址。<br>如图，本地的hexo博客已经搭建完成。<br><img src="/2019/09/07/hexo/build_hexo/hexo_hello.png" alt="hexo hello"></p><h2 id="3-Github创建博客仓库"><a href="#3-Github创建博客仓库" class="headerlink" title="3.Github创建博客仓库"></a>3.Github创建博客仓库</h2><p>打开GitHub主页，点击+号下的<code>New repository</code>创建一个新的仓库<br><img src="/2019/09/07/hexo/build_hexo/github_newrep.png" alt="新建仓库"> </p><p>然后在仓库界面填写相关仓库信息</p><p><img src="/2019/09/07/hexo/build_hexo/new_rep_name.png" alt="填写仓库名称"><br><img src="/2019/09/07/hexo/build_hexo/warn.png" width="20" height="20" position="0">踩坑提醒：这里一定要保证填写的repository name是你的GitHub名称+github.io的格式，不要写错。<br>（这里因为我已经创建了suifengczc.github.io的仓库所以提示仓库已存在）<br>否则写错了仓库名称会导致后面访问正式线上博客时出现找不到资源或者布局出错的问题。<br>填写完仓库名称和描述（可选）后直接<code>Create repository</code>就行了。</p><p>GitHub仓库创建完成后复制仓库的地址，如下<br><img src="/2019/09/07/hexo/build_hexo/clone_url.png" alt="clone url"><br>粘贴到博客目录下的<code>_config.yml</code>文件末尾，如下图所示<br><img src="/2019/09/07/hexo/build_hexo/hexo_dep.png" alt="设置hexo deploy config"><br><code>type</code> 填git<br><code>repository</code> 值填复制来的仓库地址<br><code>branch</code> 默认填master就行<br><img src="/2019/09/07/hexo/build_hexo/warn.png" width="20" height="20"> 这里一定要注意，hexo的配置文件中所有的value值和<code>:</code>之间必须要有空格，否则会报错</p><p>然后点击仓库界面的<code>Settings</code>进入仓库的设置界面，拉到最下面有<code>GitHub Pages</code><br>这里的<code>Your site is published at xxxxxxxxxx</code>就是可访问的线上博客地址。<br>把这里的url复制到刚刚打开的<code>_config.yml</code>的开头。如下图所示<br><img src="/2019/09/07/hexo/build_hexo/rep_setting.png" alt></p><p><img src="/2019/09/07/hexo/build_hexo/blog_url.png" alt></p><p><img src="/2019/09/07/hexo/build_hexo/blog_url_config.png" alt></p><p>这里配置好后可以准备把本地的博客push到GitHub了</p><h2 id="4-push本地博客到GitHub"><a href="#4-push本地博客到GitHub" class="headerlink" title="4.push本地博客到GitHub"></a>4.push本地博客到GitHub</h2><p>首先使用<code>npm i hexo-deployer-git</code>安装一个hexo的git扩展功能。<br><img src="/2019/09/07/hexo/build_hexo/npm_git.png" alt="npm install deployer"><br>如图表示安装成功。<br>然后依次执行下面三条命令</p><pre><code>hexo clean  //清除缓存hexo g  //重新生成博客文件hexo d  //push到GitHub</code></pre><p>执行<code>hexo d</code>的时候会要求输入GitHub账号和密码，输入完成后就push成功了。<br>接下来就可以打开我们的线上博客地址查看最新博客了。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><ul><li><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">https://www.simon96.online/2018/10/12/hexo-tutorial/</a></li><li><a href="https://godweiyang.com/2018/04/13/hexo-blog/" target="_blank" rel="noopener">https://godweiyang.com/2018/04/13/hexo-blog/</a></li><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
